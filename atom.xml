<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENG KANG</title>
  <subtitle>Hello World Anyway</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chengkang.me/"/>
  <updated>2017-05-29T20:20:17.000Z</updated>
  <id>http://chengkang.me/</id>
  
  <author>
    <name>程康·CHENGKANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Core Graphics，第四部分：Path！Path！</title>
    <link href="http://chengkang.me/2017/05/29/core-graphics-part-4/"/>
    <id>http://chengkang.me/2017/05/29/core-graphics-part-4/</id>
    <published>2017-05-29T20:18:57.000Z</published>
    <updated>2017-05-29T20:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-4-a-path-a-path/" target="_blank" rel="external">Core Graphics, Part 4: A Path! A Path!</a><br>看看上一篇吧：<a href="http://chengkang.me/2017/05/23/core-graphics-part-3/">【译】Core Graphics，第三部分：线</a></p>
</blockquote>
<p>在 Core Graphics 中，一个 <code>path</code> 就是对某种形状的一步一步的描述。它可以是一个圆、一个正方形、一个桃心、一个字频柱状图或者可能是一个笑脸。它并不包含任何诸如像素颜色、线宽或渐变这样的信息。路径主要是用于绘制——将其用颜色填充或者描边——用颜色描出轮廓。你之前看到的各种 <a href="https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/" target="_blank" rel="external"><code>GState</code></a> 参数控制着 path 如何被绘制，包括例如 line join 和 dash pattern 在内的所有<a href="https://www.bignerdranch.com/blog/core-graphics-part-three-lines/" target="_blank" rel="external">线属性</a>。</p>
<p>这一次让你看看 path 是什么组成的。下一次你会看到一些用 path 能做的远非简单绘制的很酷的东西。</p>
<a id="more"></a>
<p>虽然一个 path 代表了一个理想图形的配方，它需要被渲染出来才能被人真正看到。每一个 Core Graphics context 都尽其可能将 path 渲染出来。当绘制一个位图时，任何曲线和斜线都是反锯齿化的。这意味着使用阴影来欺骗眼睛使其一位这个形状是平滑的即使它是由方形像素点组成的。当在打印机上绘制时，同样的事情发生着，不过用的是极其小的像素点。当绘制 PDF 时，path 大部分仅仅是原位防止，因为 Core Graphics 绘制模型和 PDF 绘制模型基本是一样的。PDF 引擎（例如 Preview 或者 Adobe Acrobat）会去渲染那些 PDF path 而非 Core Graphics 引擎。</p>
<p>你可以试试 <a href="https://github.com/markd2/grafdemo" target="_blank" rel="external">GrafDemo</a> 里面的 path。大多数这里的截图都来自 GrafDemo 里的 Path 部分、Arcs 以及 All The Parts 窗口。</p>
<h2 id="路径元素"><a href="#路径元素" class="headerlink" title="路径元素"></a>路径元素</h2><p>一个 path 就是由一些被称之为<em>元素</em>的原始形状（曲线、弧和直线）连接起来的一系列点。你可以想象每一个元素是给一个专门的拿着铅笔的机器人的一个指令。你告诉这个机器人要提起铅笔并移动到笛卡尔平面的一个点，但是不要留下任何 印记。你可以告诉这个机器人去把铅笔落下来然后从当前的点到一个新点间画点什么。有五种基本的路径元素：</p>
<p><em>Move to Point</em>——移动当前的点到一个新的位置但不画任何东西。机器人抬起铅笔并且移动它的手臂。</p>
<p><em>Add Line To Point</em>——从当前点到一个新点间添加一条线。机器人将铅笔落下来并画出一条直线。以下是一次<em>移动到点</em>（左下方）和其后的两次<em>添加线到点</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: nextPoint)</span><br><span class="line">path.addLine(to: endPoint)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-moveto---x----158-132x---.gif" alt=""></p>
<p><em>添加二次曲线到点 Add Quad Curve To Point</em>——通过一个控制点，从当前点到一个新点间添加一条二次曲线。机器人落下了铅笔并在绘制一条曲线。这条线并不是直接划到那个控制点——相反这个控制点影响着（线的）形状。控制点离曲线越远，形状就越极端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: firstPoint)</span><br><span class="line">path.addQuadCurve(to: endPoint, control: controlPoint)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-quadcurve---x----155-130x---.gif" alt=""></p>
<p><em>Add Curve To Point</em>——通过两个控制点，从当前点到新点添加一条三次<a href="https://vimeo.com/106757336" target="_blank" rel="external">贝塞尔曲线</a>。和二次曲线一样，控制点影响着这条线该如何画。二次曲线无法自身形成一个环，但是贝塞尔曲线可以。如果你曾在 Photoshop 或者 Illustrator 中使用过钢笔工具，你就和贝塞尔曲线打过交道了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: firstPoint)</span><br><span class="line">path.addCurve(to: endPoint,</span><br><span class="line">              control1: firstControl,</span><br><span class="line">              control2: secondControl)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-beziercurve---x----155-130x---.gif" alt=""></p>
<p><em>Close Subpath</em>——从当前点到路径的第一个点间添加一条直线。更确切地说，最近的那个 move-to-point （的点）。你会希望闭合一个路径而非添加一条线到起始位置。根据你如何计算这些点，累积的浮点化整可能使得计算出的终点和起始点不一样。以下（代码）可以绘制一个三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: nextPoint)</span><br><span class="line">path.addLine(to: endPoint)</span><br><span class="line">path.closeSubpath()</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-closed-path---x----145-132x---.gif" alt=""></p>
<p>注意这个名字是 <em>Close Subpath</em>。通过执行一次 move-to 操作，你可以创建一个包含分离部分的路径，例如这个在我们 <a href="https://www.bignerdranch.com/training/courses/advanced-ios-bootcamp/" target="_blank" rel="external">Advanced iOS bootcamp</a> 中新练习题里的一个柱状图。这些柱形都是用一个路径绘制的。这个路径被用来给它们上色，并且描出轮廓以清楚地区别各个柱形。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-infographic---x----462-298x---.png" alt=""></p>
<h2 id="那样做方便吗？"><a href="#那样做方便吗？" class="headerlink" title="那样做方便吗？"></a>那样做方便吗？</h2><p>简单的图形用那仅有的五个基本路径元素去生成的话（代码、过程）可能会变得很冗长。Core Graphics （或者说 CG）提供了一些简便方法来添加常见的形状，比如矩形、椭圆或者一个圆角矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let squarePath = CGPath(rect: rect1, transform: nil)</span><br><span class="line">let ovalpath = CGPath(ellipseIn: rect2, transform: nil)</span><br><span class="line">let roundedRectanglePath = CGPath(roundedRect: rect3,</span><br><span class="line">                                  cornerWidth: 10.0,</span><br><span class="line">                                  cornerHeight: 10.0,</span><br><span class="line">                                  transform: nil)</span><br></pre></td></tr></table></figure>
<p>这些方法使用了一个 <em>transform</em> 对象作为它们最后一个参数。你会在之后的文章中看到更多关于 transform 的东西，因此暂时只传个 nil 就行了。以上的方法（<code>CGPath(rect:tranform:)</code>、<code>CGPath(ellipseIn:transform:)</code>和<code>CGPath(roundedRect:cornerWidth:cornerHeight:transform:)</code>）生成了这些形状：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-conveniences---x----860-230x---.png" alt=""></p>
<p>同样也还有一些可以让你用一个就能创建更复杂的路径的方法，例如多个矩形或者多个椭圆、多个线段或者一整个别的路径。</p>
<h2 id="Noah-的-ARCtangent"><a href="#Noah-的-ARCtangent" class="headerlink" title="Noah 的 ARCtangent"></a>Noah 的 ARCtangent</h2><p>你也可以加一点弧在里面，就是一个圆形边的部分。用哪一个取决于你手上握着什么值。</p>
<p><em>Arc</em>——需要给定你想要的弧所在的那个圆的圆心、它的半径以及起始和终止角度（用弧度表示）。那个圆从起始角度到终止角度之间的那一段将会被绘制。弧的终点成为了当前点。以下代码绘制了左边的线，外加一个圆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addArc(center: centerPoint,</span><br><span class="line">            radius: radius,</span><br><span class="line">            startAngle: startAngle,</span><br><span class="line">            endAngle: endAngle,</span><br><span class="line">            clockwise: clockwise)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-arc---x----217-262x---.gif" alt=""></p>
<p><em>Relative Arc</em>——这个与正常的弧类似。需要给定圆心、半径和起始角度。但并不是要给定一个终止角度，而是你要说明要从起始角度往前或者往后画多少个弧度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addRelativeArc(center: centerPoint,</span><br><span class="line">                    radius: radius,</span><br><span class="line">                    startAngle: startAngle,</span><br><span class="line">                    delta: deltaAngle)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-relative-arc---x----217-262x---.gif" alt=""></p>
<p><em>Arc to Point</em>——这个就有点奇怪了。你需要给定圆半径和两个控制点。在后台呢，当前的店会和第一个控制点连接，然后与第二个控制点形成一个角度。这些线接下来被用于构建一个有着给定半径并正切于这些线的圆。我将这种弧称作 “Arc to Point” 是因为其底层的 C API 名字叫 <code>CGContextAddArcToPoint</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addArc(tangent1End: tangent1Point,</span><br><span class="line">            tangent2End: tangent2Point,</span><br><span class="line">            radius: radius)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-arc-to-point---x----217-192x---.gif" alt=""></p>
<p>我在试着想出一个这个方法的好的应用场景时，朋友 <a href="https://www.bignerdranch.com/about/the-team/jeremy-sherman/" target="_blank" rel="external">Jeremy W. Sherman</a> 想到一个很酷的应用：如果你想做一个曲面的交叉影线时可能比较有用，想想“给一把剑的顶部加一点阴影”——你可以重复同样的正切并且改变半径来画一些离顶部越来越远的弧。</p>
<p>你可能已经注意到了这些弧的方法可以用直线段来连接圆弧。用前两个弧方法来创建一个新的路径是不会创建这个连接用的线段的。Arc to point 可能会包含那个初始的部分。</p>
<h2 id="Path-vs-Context-操作"><a href="#Path-vs-Context-操作" class="headerlink" title="Path vs Context 操作"></a>Path vs Context 操作</h2><p>有两种在代码里创建路径的方法。第一种方式是告诉 context：“嘿，创建一个新的 path” 并开始累积 path 元素。这个 path 在你描边或者填充时就消失了。没了。拜拜了。这个 path 也并没有被保存或者可以在你保存恢复 GState 的时候恢复——它实际上并不是 GState 的一部分。每一个 context 只有一个在用状态的 path。</p>
<p>一下是当前 context 被用于构建和描边一个 path 时的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let context = UIGraphicsGetCurrentContext()</span><br><span class="line">context.beginPath()</span><br><span class="line">context.move(to: controlPoints[0])</span><br><span class="line">context.addQuadCurve(to: controlPoints[1], control: controlPoints[2])</span><br><span class="line">context.strokePath()</span><br></pre></td></tr></table></figure>
<p>这些对于那些一次性的只创建一次、用一次然后被遗忘的 path 非常棒。</p>
<p>你也可以创建一个新的 <code>CGMutablePath</code> path 对象（一个 <code>CGPath</code> 类型的 mutable 子类，与 <code>NSArray / NSMutableArray</code> 间的关系类似）并在其中累积 path 组件。这是一个你可以一直用的实例。要用一个 path 对象绘制的话，你要将这个 path 添加到 context 中然后执行描边与/或填充操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let path = CGMutablePath()</span><br><span class="line">path.move(to: controlPoints[0])</span><br><span class="line">path.addQuadCurve(to: controlPoints[1], control: controlPoints[2])</span><br><span class="line"></span><br><span class="line">context.addPath(path)</span><br><span class="line">context.strokePath()</span><br></pre></td></tr></table></figure>
<p>对于你常用的形状（比如卡片游戏里的那一套图标），你可能希望创建一个红心 path 和一个方片 path 一次然后用它们一次次绘制。</p>
<h2 id="如何创建？"><a href="#如何创建？" class="headerlink" title="如何创建？"></a>如何创建？</h2><p>那么你如何才能创建出有用又有趣的 path 呢，比如心形或者笑脸？一个方法是做好数学功课并计算出点、线、曲线和弧需要怎么走。</p>
<p>另一个方法就是用软件工具。有一些可以让你画形状的的应用，然后返回给你一堆可以直接粘贴到你的应用中的 CG 代码。同时也有一些可以将其他形式数据（例如来自 Illustrator的、PDF 或者 SVG）转换成 path 的库。我在给 <a href="https://www.bignerdranch.com/blog/protocols-part-2-delegation/" target="_blank" rel="external">Protocols part 2: Delegation</a> 准备的 world demo app 中的可点击地图中使用了 SVG。</p>
<h2 id="路径，结构"><a href="#路径，结构" class="headerlink" title="路径，结构"></a>路径，结构</h2><p>Core Graphics 路径是不透明数据类型。你先累积路径元素然后在 context 中渲染它。为了了解内部情况，使用 <code>CGPath</code> 的 <code>apply(info:function:)</code> 方法来遍历路径组件。你可以提供一个被每一个路径元素重复调用的方法（在 Swift 中你可以用闭包）。（你可以忽略 info 参数通过传 <code>nil</code>。这是在 Swift Core Graphics API 底下的 C API 的一个延续。在 C 里面你需要提供一个方法并传递任何你需要在里面使用到的对象。用闭包的话你就只需要用你需要的那些。）</p>
<p>也因为其对 C 的继承，这个传进来的方法或闭包是一个 <code>UnsafePointer&lt;CGPathElement&gt;</code>。这是一个指向内存中 <code>CGPathElement</code> 的指针。你需要通过 <code>pointee</code> 来引用那个指针以得到实际的 <code>CGPathElement</code>。这个 path 元素有一个用于表现其类型的枚举值，还有一个指向一个指针数组里的第一个 <code>CGPoint</code> 的 <code>UnsafeMutablePointer&lt;CGPoint&gt;</code>。你需要自己去搞清楚你可以从那个数组里面安全读取多少指针。</p>
<p>下面是一个 <code>CGPath</code> 扩展，它可以让一个 path 倾倒出其内容。你也可以从这个 <a href="https://gist.github.com/markd2/7bd2a5e2969b000f296828b3bcbf49f8" target="_blank" rel="external">gist</a> 中找到这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import CoreGraphics</span><br><span class="line"></span><br><span class="line">extension CGPath &#123;</span><br><span class="line">    func dump() &#123;</span><br><span class="line">        self.apply(info: nil) &#123; info, unsafeElement in</span><br><span class="line">            let element = unsafeElement.pointee</span><br><span class="line"></span><br><span class="line">            switch element.type &#123;</span><br><span class="line">            case .moveToPoint:</span><br><span class="line">                let point = element.points[0]</span><br><span class="line">                print(&quot;moveto - \(point)&quot;)</span><br><span class="line">            case .addLineToPoint:</span><br><span class="line">                let point = element.points[0]</span><br><span class="line">                print(&quot;lineto - \(point)&quot;)</span><br><span class="line">            case .addQuadCurveToPoint:</span><br><span class="line">                let control = element.points[0]</span><br><span class="line">                let point = element.points[1]</span><br><span class="line">                print(&quot;quadCurveTo - \(point) - \(control)&quot;)</span><br><span class="line">            case .addCurveToPoint:</span><br><span class="line">                let control1 = element.points[0]</span><br><span class="line">                let control2 = element.points[1]</span><br><span class="line">                let point = element.points[2]</span><br><span class="line">                print(&quot;curveTo - \(point) - \(control1) - \(control2)&quot;)</span><br><span class="line">            case .closeSubpath:</span><br><span class="line">                print(&quot;close&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出之前创建那个 arc to point 图片的 path 展示出这条弧是一系列 curveTo 操作及连接用的直线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addArc(tangent1End: tangent1Point,</span><br><span class="line">            tangent2End: tangent2Point,</span><br><span class="line">            radius: radius)</span><br><span class="line">path.addLine(to: secondSegmentPoint)</span><br><span class="line">path.addLine(to: endPoint)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">moveto - (5.0, 91.0)      // explicit code</span><br><span class="line">lineto - (72.3, 91.0)     // explicit code</span><br><span class="line">lineto - (71.6904767391754, 104.885702433811)   // added by addArc</span><br><span class="line">curveTo - (95.5075588575432, 131.015122621923)</span><br><span class="line">        - (71.0519422129889, 118.678048199439)</span><br><span class="line">        - (81.7152130919145, 130.376588095736)</span><br><span class="line">curveTo - (113.012569145714, 124.955236840146)</span><br><span class="line">        - (101.903264013406, 131.311220082842)</span><br><span class="line">        - (108.168814214539, 129.14221144167)</span><br><span class="line">lineto - (129.666666666667, 91.0) // explicit code</span><br><span class="line">lineto - (197.0, 91.0)   // explicit code</span><br></pre></td></tr></table></figure>
<p>即使是一个用 <code>CGPath(ellipseIn:transform:)</code> 创建的“简单的”椭圆也有些复杂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curveTo - (62.5, 107.0) - (110.0, 86.4050984922165) - (88.7335256169627, 107.0)</span><br><span class="line">curveTo - (15.0, 61.0) - (36.2664743830373, 107.0) - (15.0, 86.4050984922165)</span><br><span class="line">curveTo - (62.5, 15.0) - (15.0, 35.5949015077835) - (36.2664743830373, 15.0)</span><br><span class="line">curveTo - (110.0, 61.0) - (88.7335256169627, 15.0) - (110.0, 35.5949015077835)</span><br></pre></td></tr></table></figure>
<h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2><p>这一次你看到了创建一个 path、绘制它以及其中发生的一切。还有很多你可以用 path 做的事情，下次继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-4-a-path-a-path/&quot;&gt;Core Graphics, Part 4: A Path! A Path!&lt;/a&gt;&lt;br&gt;看看上一篇吧：&lt;a href=&quot;http://chengkang.me/2017/05/23/core-graphics-part-3/&quot;&gt;【译】Core Graphics，第三部分：线&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Core Graphics 中，一个 &lt;code&gt;path&lt;/code&gt; 就是对某种形状的一步一步的描述。它可以是一个圆、一个正方形、一个桃心、一个字频柱状图或者可能是一个笑脸。它并不包含任何诸如像素颜色、线宽或渐变这样的信息。路径主要是用于绘制——将其用颜色填充或者描边——用颜色描出轮廓。你之前看到的各种 &lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/&quot;&gt;&lt;code&gt;GState&lt;/code&gt;&lt;/a&gt; 参数控制着 path 如何被绘制，包括例如 line join 和 dash pattern 在内的所有&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-three-lines/&quot;&gt;线属性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这一次让你看看 path 是什么组成的。下一次你会看到一些用 path 能做的远非简单绘制的很酷的东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】哥们儿，我的方法哪儿去了？</title>
    <link href="http://chengkang.me/2017/05/25/dude-where-is-my-call/"/>
    <id>http://chengkang.me/2017/05/25/dude-where-is-my-call/</id>
    <published>2017-05-25T19:09:58.000Z</published>
    <updated>2017-05-25T19:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/dude-wheres-my-call/" target="_blank" rel="external">Dude, Where’s my Call?</a></p>
</blockquote>
<p>想象有一天你正在给 Swift 编译器喂一些看起来无害的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// xcrun -sdk macosx swiftc -emit-executable cg.swift</span><br><span class="line"></span><br><span class="line">import CoreGraphics</span><br><span class="line"></span><br><span class="line">let path = CGPathCreateMutable()</span><br><span class="line">CGPathMoveToPoint(path, nil, 0.0, 23.0)</span><br></pre></td></tr></table></figure>
<p>然后一个冲击波打来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cg.swift:7:12: error: &apos;CGPathCreateMutable()&apos; has been replaced by &apos;CGMutablePath.init()&apos;</span><br><span class="line">&lt;unknown&gt;:0: note: &apos;CGPathCreateMutable()&apos; has been explicitly marked unavailable here</span><br><span class="line">cg.swift:8:1: error: &apos;CGPathMoveToPoint&apos; has been replaced by instance method &apos;CGMutablePath.moveTo(_:x:y:)&apos;</span><br><span class="line">&lt;unknown&gt;:0: note: &apos;CGPathMoveToPoint&apos; has been explicitly marked unavailable here</span><br></pre></td></tr></table></figure>
<p>它们哪儿去了？被重命名了。</p>
<a id="more"></a>
<p>Swift 3 一个重大的特性就是由 Swift-Evolution 提议 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="external">SE-0005 (Better Translation of Objective-C APIs Into Swift)</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md" target="_blank" rel="external">SE-0006 (Apply API Guidelines to the Standard Library)</a> 带来的”超级重命名“，这次超级重命名重命名了 C 和 Objective-C API 中的一些方法以给它们一种更 Swift 的感觉。Xcode 里面有一个移植器会将你的 Swift 2 代码转换成新的风格。它会执行很多机械的改变，给你留一些由于其他语言改变需要扫尾的工作，例如<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md" target="_blank" rel="external">移除 C 的 for 循环</a>。</p>
<p>有一些重命名相当轻微，比如 NSView 中的这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Swift 2</span><br><span class="line">let localPoint = someView.convertPoint(event.locationInWindow, fromView: nil)</span><br><span class="line"></span><br><span class="line">// Swift 3</span><br><span class="line">let localPoint = someView.convert(event.locationInWindow, from: nil)</span><br></pre></td></tr></table></figure>
<p>在这里 <code>Point</code> 从方法名里移除了。你知道自己正在处理一个 point，所以没必要重复这一事实。<code>fromView</code> 重命名为了 <code>from</code> 因为 <code>View</code> 只是提供了冗余的类型信息，并没有让这个调用更清楚。</p>
<p>其他的改变更大一些，比如 Core Graphics：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Swift 2 / (Objective-C)</span><br><span class="line">let path = CGPathCreateMutable()</span><br><span class="line">CGPathMoveToPoint (path, nil, points[i].x, points[i].y)</span><br><span class="line">CGPathAddLineToPoint (path, nil, points[i + 1].x, points[i + 1].y)</span><br><span class="line">CGContextAddPath (context, path)</span><br><span class="line">CGContextStrokePath (context)</span><br><span class="line"></span><br><span class="line">// Swift 3</span><br><span class="line">let path = CGMutablePath()</span><br><span class="line">path.move (to: points[i])</span><br><span class="line">path.addLine (to: points[i + 1])</span><br><span class="line"></span><br><span class="line">context.addPath (path)</span><br><span class="line">context.strokePath ()</span><br></pre></td></tr></table></figure>
<p>喔噢。这变化太大了。这个 API 现在看起来就是让人喜欢的 Swift 风格 API 而不是旧式的 C API。Apple 在 Swift 里面完全改变了 Core Graphics API （还有 GCD）以让它们更好用。你在 Swift 3 里不能再用老式的 CG C 风格的 API，因此你需要开始习惯新的风格。我已经将 GrafDemo （我这些 <a href="http://chengkang.me/2017/05/23/core-graphics-part-1/">Core Graphics</a> 博文的示例程序） 在自动翻译器中跑过（两次）了。你可以在这个 <a href="https://github.com/markd2/GrafDemo/pull/17/files" target="_blank" rel="external">pull</a> 请求中看到 Swift 3 第一个版本前后的变化，在这个 <a href="https://github.com/markd2/GrafDemo/pull/18/files" target="_blank" rel="external">pull</a> 请求中看到 Xcode8b6 的 Swift 3 版本前后变化。</p>
<h2 id="他们干什么了？"><a href="#他们干什么了？" class="headerlink" title="他们干什么了？"></a>他们干什么了？</h2><p>Core Graphics API 就是一堆全局变量和全局自由方法。就是说，方法并不是直接和某些比如说类或者结构体这样的实例绑定的。用 <code>CGContextAddArcToPoint</code> 来操作 <code>CGContext</code> 仅仅是一个传统，不过你传进去一个 <code>CGColor</code> 也不会有人拦着你。无非就是会在运行时爆炸而已。只是在 C 风格的面向对象你才有一个隐晦类型作为第一个参数传过去，作为某种神奇饼干。<code>CGContext*</code> 方法需要一个 <code>CGContextRef</code>。<code>CGColor*</code> 方法需要一个 <code>CGColorRef</code>。</p>
<p>通过一些编译器的魔法，Apple 将这些隐晦引用转成了类，并且添加了一些方法给这些类以将其映射到 C API。当编译器看到类似这样的东西时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let path = CGMutablePath()</span><br><span class="line">path.addLines(between: self.points)</span><br><span class="line">context.addPath(path)</span><br><span class="line">context.strokePath()</span><br></pre></td></tr></table></figure>
<p>实际上，在背后，正在发出这一系列调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let path = CGPathCreateMutable()</span><br><span class="line">CGPathAddLines(path, nil, self.points, self.points.count)</span><br><span class="line">CGContextAddPath(context, path)</span><br><span class="line">CGContextStrokePath(context)</span><br></pre></td></tr></table></figure>
<h2 id="“新的”类"><a href="#“新的”类" class="headerlink" title="“新的”类"></a>“新的”类</h2><p>以下是已经接受 Swift 3.0 治疗的常见的隐晦类型 （忽略了一些专用的类型比如 <code>CGDisplayMode</code> 或者 <code>CGEvent</code>），还有一两个作为代表的方法：</p>
<ul>
<li><code>CGAffineTransform - translateBy(x:30, y:50), rotate(by: CGFloat.pi / 2.0)</code></li>
<li><code>CGPath / CGMutablePath - contains(point, using: evenOdd), .addRelativeArc(center: x, radius: r, startAngle: sa, delta: deltaAngle)</code></li>
<li><code>CGContext - context.addPath(path), context.clip(to: cgrectArray)</code></li>
<li><code>CGBitmapContext (folded in to CGContext) - let c = CGContext(data: bytes, width: 30, height: 30, bitsPerComponent: 8, bytesPerRow: 120, space: colorspace, bitmapInfo: 0)</code></li>
<li><code>CGColor - let color = CGColor(red: 1.0, green: 0.5, blue: 0.333, alpha: 1.0)</code></li>
<li><code>CGFont - let font = CGFont(&quot;Helvetica&quot;), font.fullName</code></li>
<li><code>CGImage - image.masking(imageMask), image.cropping(to: rect)</code></li>
<li><code>CGLayer - let layer = GCLayer(context, size: size, auxilaryInfo: aux), layer.size</code></li>
<li><code>CGPDFContext (folded in to CGContext) / CGPDFDocument - context.beginPDFPage(pageInfo)</code></li>
</ul>
<p><code>CGRect</code> 和 <code>CGPoint</code> 在 Swift 3 之前早已有了一些很不错的扩展。</p>
<h2 id="怎么做到的？"><a href="#怎么做到的？" class="headerlink" title="怎么做到的？"></a>怎么做到的？</h2><p>编译器有一个内置的语法转换器，它将 Objective-C 的明明风格转换成更 Swift 些的形式。去掉重复的单词和那些仅仅是重复类型信息的单词。还去掉了一些之前是在方法调用左括号之前的单词并将它们移到括号里面作为参数标签。通过这样自动清理了一大堆调用方法。</p>
<p>当然，人类喜欢搞一些微妙复杂的言辞，因此在 Swift 编译器里有一个允许手动重写自动翻译器翻译的部分的机制。这是具体的实现了（别在输出产品时依靠他们），不过他们提供了深入了解用于让现存 API 出现在 Swift 中所做的那些工作的机会。</p>
<p>其中一个涉及到的机制是 ”overlay“，它是当你引入一个框架或者 C 库时编译器引用的第二个库。<a href="https://raw.githubusercontent.com/apple/swift/master/docs/Lexicon.rst" target="_blank" rel="external">Swift Lexicon</a> 将 overlay 形容为”当库在系统中不发被修改时在系统中增强和扩大这个库“。一些一直都存在很棒的 <code>CGRect</code> 和 <code>CGPoint</code> 扩展，例如<code>someRect.divide(30.0, fromEdge: .MinXEdge)</code>，怎么来的？他们来自 overlay。工具链想啊”噢，我看到你在链接 Core Graphics。让我再加点方便方法吧。“</p>
<p>还有另外一个机制，<a href="https://github.com/apple/swift/tree/master/apinotes" target="_blank" rel="external">apinotes</a>，特别是 <a href="https://github.com/apple/swift/blob/master/apinotes/CoreGraphics.apinotes" target="_blank" rel="external">CoreGraphics.apinotes</a>，一字一词地控制着 Core Graphics 中地命名和可见性。</p>
<p>例如，在 Swift 中像 <code>CGRectMake</code> 这样用来初始化基础结构体的调用没有作用，因为已经有它们的初始化方法了。所以就让这些调用方法不可用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># The below are inline functions that are irrelevant due to memberwise inits</span><br><span class="line">- Name: CGPointMake</span><br><span class="line">  Availability: nonswift</span><br><span class="line">- Name: CGSizeMake</span><br><span class="line">  Availability: nonswift</span><br><span class="line">- Name: CGVectorMake</span><br><span class="line">  Availability: nonswift</span><br><span class="line">- Name: CGRectMake</span><br><span class="line">  Availability: nonswift</span><br></pre></td></tr></table></figure>
<p>然后还有其他的映射——如果你在 Swift 中看到这个，那就调用那个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># The below are fixups that inference didn&apos;t quite do what we wanted, and are</span><br><span class="line"># pulled over from what used to be in the overlays</span><br><span class="line">- Name: CGRectIsNull</span><br><span class="line">  SwiftName: &quot;getter:CGRect.isNull(self:)&quot;</span><br><span class="line">- Name: CGRectIsEmpty</span><br><span class="line">  SwiftName: &quot;getter:CGRect.isEmpty(self:)&quot;</span><br></pre></td></tr></table></figure>
<p>如果编译器看到了比如 <code>rect.isEmpty()</code> 这样的东西，它会发送一个请求给 <code>CGRectIsEmpty</code>。</p>
<p>以下还是一些方法和功能的重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># The below are attempts at providing better names than inference</span><br><span class="line">- Name: CGPointApplyAffineTransform</span><br><span class="line">  SwiftName: CGPoint.applying(self:_:)</span><br><span class="line">- Name: CGSizeApplyAffineTransform</span><br><span class="line">  SwiftName: CGSize.applying(self:_:)</span><br><span class="line">- Name: CGRectApplyAffineTransform</span><br><span class="line">  SwiftName: CGRect.applying(self:_:)</span><br></pre></td></tr></table></figure>
<p>当编译器看到 <code>rect.applying(transform)</code>，它就知道调用 <code>CGRectApplyAffineTransform</code>。</p>
<p>编译器只能自动重命名 Objective-C API，因为其遵循良好的系统命名法。C API （比如 Core Graphics）需要通过 overlay 和 apinote 来实现。</p>
<h2 id="你能做什么"><a href="#你能做什么" class="headerlink" title="你能做什么"></a>你能做什么</h2><p>你可以通过 <code>NS_SWIFT_NAME</code> 做一些类似 apinote 机制的事情。你可以用这个宏来注释 C/Objective-C 头文件，表示在 Swift 里要用那个名字。编译器会对你的 <code>NS_SWIFT_NAME</code> 采用同样的替换（”如果看到 X，就调用 Y“）。</p>
<p>例如，这是一个 Intents(Siri) 框架中的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)resolveWorkoutNameForEndWorkout:(INEndWorkoutIntent *)intent</span><br><span class="line">                         withCompletion:(void (^)(INSpeakableStringResolutionResult *resolutionResult))completion</span><br><span class="line">     NS_SWIFT_NAME(resolveWorkoutName(forEndWorkout:with:));</span><br></pre></td></tr></table></figure>
<p>从 Objective-C 中调用它的话看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSObject&lt;INEndWorkoutIntentHandling&gt; *workout = ...;</span><br><span class="line"></span><br><span class="line">[workout resolveWorkoutNameForEndWorkout: intent  withCompletion: ^(INSpeakableStringResolutionResult) &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>而在 Swift 中是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let workout: INEndWorkoutIntentHandling = ...</span><br><span class="line">workout.resolveWorkoutName(forEndWorkout: workout) &#123;</span><br><span class="line">    response in</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NS_SWIFT_NAME</code>，和 Objective-C 中的轻量级泛型，nullability 注释，以及 Swift 编译器中的自动 Objective-C API 重命名一起，可以让你立刻有一种接口都回到 Swift 世界中的感觉。</p>
<p>使用自制的 overlay 和 apinote 是可以的，但那些原本是在 Swift 和 Apple 的 SDK 结合在一起时用的。你可以在你自己的框架中分发 apinote，但是 overlay 需要从 Swift 编译器树中编译。</p>
<p>为了自己创建更 Swift 的 API，你必须尽可能地做好头文件旁听（比如添加 nullability 注释和 NS_SWIFT_NAME），然后在你的项目中放一些 Swift 文件来伪造 overlay 以覆盖任何多余情况。这些 ”overlay” 文件在有 ABI 稳定性前都需要作为源文件传送。</p>
<p>轻掠过 iOS 10 头文件，看起来新的 API 喜欢用 <code>NS_SWIFT_NAME</code>，而老一点的更久远一些的 API 用 apinote。这样有一些道理因为这些头文件是在不同 Swift 版本中共享的，而给更久远的头文件可能添加新的 <code>NS_SWIFT_NAME</code> 可能会在编译器未改变的情况下破坏当前的代码。而且，apinote 可以由编译器团队或者社区成员添加，而头文件的改变需要拥有这个头文件的团队的注意。而那个团队可能已经准备好正要发布他们的功能了。</p>
<h2 id="它好吗？"><a href="#它好吗？" class="headerlink" title="它好吗？"></a>它好吗？</h2><p>Swift 3 版本的 Core Graphics 绝对是更优秀更加 Swift 化。老实说，我也想在 Objective-C 上这样用。你可能因此失掉一些可 Google 性，并且需要当你在 Stack Overflow 的文章或者网上的教程中看到现有的 CG 代码时做一些脑内转换。不过那也不必这些日子普通的 Swift 代码所需的脑力运动多多少。</p>
<p>有一些由于 CG 类似 OO 本质及其如何进入 Swift 中带来的 API 的不协调。在这个 <code>CoreGraphics.apinotes</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Name: CGBitmapContextGetWidth</span><br><span class="line">  SwiftName: getter:CGContext.width(self:)</span><br><span class="line">- Name: CGPDFContextBeginPage</span><br><span class="line">  SwiftName: CGContext.beginPDFPage(self:_:)</span><br></pre></td></tr></table></figure>
<p><code>CGBitmapContext</code> 和 <code>CGPDFContext</code> 方法都被 <code>CGContext</code> 偷去了。这意味着你可以对任何 <code>CGContext</code> 要它的宽度，或者叫它开始一个 PDF 页面。如果你找一个非位图 context 要它的宽，你会得到这样的运行时错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Error&gt;: CGBitmapContextGetWidth: invalid context 0x100e6c3c0.</span><br><span class="line">If you want to see the backtrace, please set CG_CONTEXT_SHOW_BACKTRACE environmental variable.</span><br></pre></td></tr></table></figure>
<p>因此即使这个 API 非常 Swift 化了，编译器并不能捕获某些类型的 API 错用。Xcode 会高高兴兴地给你其实实际上不合适的方法补全。某种意义上来说，C API 更安全一点，因为 <code>CGBitmapContextGetWidth</code> 很清楚地告诉你它要的是一个位图 context 即使第一个参数从技术上来说就还是一个 <code>CGContextRef</code>。我希望这仅仅是一个 bug （<a href="https://openradar.appspot.com/radar?id=6161102635270144" target="_blank" rel="external">rdar://27626070</a>）。</p>
<p>如果你想了解更多想超级重命名以及像 NS_SWIFT_NAME 这样的工具，看看这个吧 <a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="external">WWDC 2016 Session 403 - iOS API Design Guidelines</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/dude-wheres-my-call/&quot;&gt;Dude, Where’s my Call?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想象有一天你正在给 Swift 编译器喂一些看起来无害的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// xcrun -sdk macosx swiftc -emit-executable cg.swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import CoreGraphics&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let path = CGPathCreateMutable()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGPathMoveToPoint(path, nil, 0.0, 23.0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后一个冲击波打来：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cg.swift:7:12: error: &amp;apos;CGPathCreateMutable()&amp;apos; has been replaced by &amp;apos;CGMutablePath.init()&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;unknown&amp;gt;:0: note: &amp;apos;CGPathCreateMutable()&amp;apos; has been explicitly marked unavailable here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cg.swift:8:1: error: &amp;apos;CGPathMoveToPoint&amp;apos; has been replaced by instance method &amp;apos;CGMutablePath.moveTo(_:x:y:)&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;unknown&amp;gt;:0: note: &amp;apos;CGPathMoveToPoint&amp;apos; has been explicitly marked unavailable here&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它们哪儿去了？被重命名了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics，第三部分：线</title>
    <link href="http://chengkang.me/2017/05/25/core-graphics-part-3/"/>
    <id>http://chengkang.me/2017/05/25/core-graphics-part-3/</id>
    <published>2017-05-24T23:23:05.000Z</published>
    <updated>2017-05-24T23:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-three-lines/" target="_blank" rel="external">Core Graphics, Part 2: Contextually Speaking</a><br>看看上一篇吧：<a href="http://chengkang.me/2017/05/23/core-graphics-part-2/">【译】Core Graphics, 第二部分：说说 context （上下文）</a></p>
</blockquote>
<p>设想这样一条简单的线：就是连接两点的一条直像素序列。有一些有名的算法你可以用来自己做绘制，但是近些日子，我们有了工具箱来帮忙做繁杂的工作。在 Core Graphics 中，一条线就只是一种路径。路径对于许多 Core Graphics 的特性来说都是中心，下一回你会得知很多路径的信息。不过现在，先把线想成被描出轮廓（而非填充）的一系列线的片段。有一大堆普遍的 <code>GState</code> 参数能影响线（的颜色、宽度、阴影及形变），同样也有 GState 的值与绘制线有关。</p>
<p>你在这看到的所有线的图片都是用 GrafDemo 创建的。你可以在 <a href="https://github.com/markd2/GrafDemo" target="_blank" rel="external">GitHub</a> 上找到源码，这里使用的版本为”Release cg-pt3“。</p>
<a id="more"></a>
<p>这就是 Lines 窗口的样子，左边是 Objective-C 的 NSView，右边是 Swift 的 NSView。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-grafdemo-window.png" alt=""></p>
<p>回想一下，CG path 只是形状的描述。它们并不实际包含任何像素点。<code>GState</code> 控制着 path 实际上如何被渲染，在 view 里面、image 里面或者 PDF 里面也好，无论是被填充或者是描边。有四个 <code>GState</code> 属性专属于 stroked lines：Join，Miter Limit，End Cap 和 Dash。</p>
<h2 id="Join-的阴暗面"><a href="#Join-的阴暗面" class="headerlink" title="Join 的阴暗面"></a>Join 的阴暗面</h2><p><code>line join</code> 这个属性控制着当线转角时发生的事情，并且通过以下枚举值来描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum CGLineJoin &#123;</span><br><span class="line">    kCGLineJoinMiter       // default</span><br><span class="line">    kCGLineJoinRound</span><br><span class="line">    kCGLineJoinBevel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过以下调用来设置它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineJoin (context, kCGLineJoinMiter)</span><br></pre></td></tr></table></figure>
<p><code>miter join</code> （斜角连接）有一个凸出来的点。<code>round join</code> （圆角连接） 在链接的”膝关节“处有一个半圆，而 <code>bevel join</code> （斜切连接） 则是一个平的样子。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-joinstyles.png" alt=""></p>
<p>那条中间的白线是给 Quartz 的那个理想的路径。蓝色部分是这个 path 在特定 <code>GState</code> 状态下被描的轮廓，<code>GState</code> 提供了轮廓颜色、线宽和线属性。</p>
<p>这个图有两个线段连接处。在一个 path 中的所有线段都是用同一个 <code>line join</code> 值，所以如果你想混搭 <code>join</code> 类型，你需要在 context 中设置 <code>line join</code>，然后画一组线，设置 <code>line join</code> 为另一个值，然后画另一组线。你无法在一个绘制操作中混搭。</p>
<h2 id="秘诀就是-Limit"><a href="#秘诀就是-Limit" class="headerlink" title="秘诀就是 Limit"></a>秘诀就是 Limit</h2><p>圆角连接和斜切连接有些无聊。端点就是个圆，或者拐角处被切掉了。不过，斜角连接是酷的。斜角连接画的那个突出的部分的长度是根据那两条线夹角变化的：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-miterlimit-1.gif" alt=""></p>
<p>不过还是有一个问题——如果两条线的夹角非常锐的话，突出端可能变得相当长。有另外一个 GState 参数可以控制这个：Miter Limit。这是一个 CGFloat 值，它告诉 CG 什么时候该画这个突出斜角的东西，又或是该把这个连接处变成斜切的。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-miterlimit-2.gif" alt=""></p>
<p>Miter Limit API 很简单，假设你知道这个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetMiterLimit (context, 5.0);</span><br></pre></td></tr></table></figure>
<p>当在决定是斜角还是斜切时，Quartz 用 GState 中的 line width 来除它准备绘制的斜角的长度。超过了 miter limit 就意味着”使用斜切连接“。因为斜角的长度与线宽成比例（线越宽斜角越长），miter limit 实际上就与线宽无关了——这个关系被解除了。只要你把你的绘制代码调整到有优秀的斜角/斜切行为，你就不用担心线宽变不变了。</p>
<h2 id="嘿，嘿，他刚说了”屁股“"><a href="#嘿，嘿，他刚说了”屁股“" class="headerlink" title="嘿，嘿，他刚说了”屁股“"></a>嘿，嘿，他刚说了”屁股“</h2><p>你不仅可以控制连接处怎么样，也可以控制线的开头和末端是如何。这里是三个 Line Cap 样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum CGLineCap &#123;</span><br><span class="line">    kCGLineCapButt    // default</span><br><span class="line">    kCGLineCapRound</span><br><span class="line">    kCGLineCapSquare</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个改变 cap 样式的调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineCap (context, kCGLineCapButt)</span><br></pre></td></tr></table></figure>
<p>butt cap 不在线的末端画任何额外的东西。round cap 加上了一个半圆，square cap 则有一个半正方形在末端。这个额外部分的大小是和线宽成比例的。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-capitation.png" alt=""></p>
<p>和 line join 样式一样，你不能在一条线上混搭 cap 样式。</p>
<h2 id="冲破大风雪"><a href="#冲破大风雪" class="headerlink" title="冲破大风雪"></a>冲破大风雪</h2><p>line join 和 line cap 是从 PostScript 中继承来的，另一个很酷的属性也是：line dash。</p>
<p>line dash 是通过一个由”标记空间“的浮点数值组成的数组组指定的一个重复图形。元素零是这条虚线第一个部分的长度。元素一是要留的空白的大小。元素二是另一个线的长度，元素三是另一个空白，如此下去。这个模式一直循环到 CG （或者 PostScript）用光了这个数组的元素。</p>
<p>下面是一组线的组成部分的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGFloat lengths[] = &#123; 12.0, 8.0, 6.0, 14.0, 16.0, 7.0 &#125;;</span><br></pre></td></tr></table></figure>
<p>以及其相关的线的模式：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-1.png" alt=""></p>
<p>下面是用这个模式画的一条线：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-2.png" alt=""></p>
<p>这里使用了斜角连接样式。因此两个角都是斜角连接。那个消失的下方的连接处是虚线图形在原本连接处有一个空白区域造成的。</p>
<p>虚线图形在线的第一个点初固定了：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-3.gif" alt=""></p>
<p>每一个独立的图形区间都有末端 cap 属性在做用着，因此在有一个虚线图形以及 cap 或者 butt 末端 cap 时，cap 可能互相重叠而形成一条实线。</p>
<h2 id="Set-Phasers-to-Stun"><a href="#Set-Phasers-to-Stun" class="headerlink" title="Set Phasers to Stun"></a>Set Phasers to Stun</h2><p>下面是你如何设置 line phase：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void CGContextSetLineDash (CGContextRef c,</span><br><span class="line">                           CGFloat phase,</span><br><span class="line">                           const CGFloat lengths[], size_t count)</span><br></pre></td></tr></table></figure>
<p>你传入一个长度数组以及这个数组中元素的个数（并不是它的字节长度），同时还有一个 phase 值。这个 phase 值告诉 Quartz 从哪儿开始使用这个模式。你可以通过用不同的 phase 值调用 <code>SetLineDash</code> 让这个虚线动起来。</p>
<p>下面是同样一条线，仅仅是 phase 被改变时的样子：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-4.gif" alt=""></p>
<h2 id="一个-Swift-化的分段星球"><a href="#一个-Swift-化的分段星球" class="headerlink" title="一个 Swift 化的分段星球"></a>一个 Swift 化的分段星球</h2><p>Swift 尤其便于制定线分段，你仅仅需要直接用一个 CGFloat 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let phase = CGFloat(linePhaseSlider.floatValue)</span><br><span class="line">let lengths = [</span><br><span class="line">    dash0Slider.floatValue, space0Slider.floatValue,</span><br><span class="line">    dash1Slider.floatValue, space1Slider.floatValue,</span><br><span class="line">    dash2Slider.floatValue, space2Slider.floatValue</span><br><span class="line">].map &#123; CGFloat($0) &#125;</span><br><span class="line">CGContextSetLineDash (context, phase, lengths, lengths.count)</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 这一边，你需要用一个 NSNumbers 数组并且手动取出浮点值，或者维护一个 CGFloat 的 buffer。</p>
<p>简单说明一下：那个 floatValue 和 map 在一起是干什么的？这个数组需要是 CGFloat 类型。 NSSlider 并没有一种将其返回值表达成 CGFloat 的方式。一种选择是给 NSSlider 写一个 extension，用以将一个现有的 slider 值方法转换成 CGFloat。那样挺烦人的，并且你在和其他项目共享这段代码时得记得将它一起拖过来。你也可以将每一个每一个 slider floatValue 都转换了，不过那样就在视觉上很扰目，很难看清楚是哪一个 slider 在贡献它的值。通过获取一个 floatsValues 数组然后映射它们到 CGFloat，它仍然可读，并且 <code>CGContextSetLineDash</code> 得到了它想要的浮点类型。</p>
<h2 id="Construction-Zone"><a href="#Construction-Zone" class="headerlink" title="Construction Zone"></a>Construction Zone</h2><p>Core Graphics 提供了一系列用于创建 line path 的调用方法。</p>
<p>及时我还没有谈到 path API，如果你曾用过 <code>NSBezierPath</code> 的话，第一种形式应该多少有点熟悉：移动到一个点，然后添加一个新点作为新线段的末端，组成一条连续的线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"></span><br><span class="line">CGPathMoveToPoint (path, NULL, self.points[0].x, self.points[0].y);</span><br><span class="line"></span><br><span class="line">for (NSInteger i = 1; i &lt; kPointCount; i++) &#123;</span><br><span class="line">    CGPathAddLineToPoint (path, NULL, self.points[i].x, self.points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path);</span><br><span class="line">CGContextStrokePath (context);</span><br></pre></td></tr></table></figure>
<p><code>self.points</code> 返回的是一个 CGFloat 指针指向一个包含四个 CGPoints 的 C 数组。</p>
<p>Swift 形式非常相似。<code>points</code> 是一个原生 Swift CGFloat 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let path = CGPathCreateMutable()</span><br><span class="line"></span><br><span class="line">CGPathMoveToPoint (path, nil, points[0].x, points[0].y)</span><br><span class="line"></span><br><span class="line">for i in 1 ..&lt; points.count &#123;</span><br><span class="line">    CGPathAddLineToPoint (path, nil, points[i].x, points[i].y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path)</span><br><span class="line">CGContextStrokePath (context)</span><br></pre></td></tr></table></figure>
<p>下一种形式用到资格 CGPoints 数组，并且在内部进行了如你所见过的相同类型的循环。这也得到一个 path。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"></span><br><span class="line">CGPathAddLines (path, NULL, self.points, kPointCount);</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path);</span><br><span class="line">CGContextStrokePath (context);</span><br></pre></td></tr></table></figure>
<p>Swift 实现也还是差不多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let path = CGPathCreateMutable()</span><br><span class="line"></span><br><span class="line">CGPathAddLines (path, nil, self.points, self.points.count)</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path)</span><br><span class="line">CGContextStrokePath (context)</span><br></pre></td></tr></table></figure>
<p>第三种画线方法是分别画出每一条线段。每一条线段有其自己的 end-cap，并且有相应的 line dash 应用在上面。在连接处不会有斜角连接出现，因为对 CG 来说并没有连接在一起的线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i = 0; i &lt; kPointCount - 1; i++) &#123;</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"></span><br><span class="line">    CGPathMoveToPoint (path, NULL, self.points[i].x, self.points[i].y);</span><br><span class="line">    CGPathAddLineToPoint (path, NULL, self.points[i + 1].x, self.points[i + 1].y);</span><br><span class="line"></span><br><span class="line">    CGContextAddPath (context, path);</span><br><span class="line">    CGContextStrokePath (context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 当然也是几乎一模一样，除了循环结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ..&lt; points.count - 1 &#123;</span><br><span class="line">    let path = CGPathCreateMutable()</span><br><span class="line">    CGPathMoveToPoint (path, nil, points[i].x, points[i].y)</span><br><span class="line">    CGPathAddLineToPoint (path, nil, points[i + 1].x, points[i + 1].y)</span><br><span class="line"></span><br><span class="line">    CGContextAddPath (context, path)</span><br><span class="line">    CGContextStrokePath (context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种形式也是绘制单独的线段。<code>CGContextStrokeLineSegements</code> 用到一个点对数组，并且以偶数点 X 作为开始到 X+1 作为结束画线段。因此，对于包含三个线段的，它从 0-&gt;1，2-&gt;3 以及 4-&gt;5 画线。GrafDemo 的数据并不是一个渐变形势，因此有一些数据重排的工作需要做。</p>
<p>Objective-C 这一边使用了一个堆栈缓冲区来维持这些点。如果有可能其大小变得巨大的话，使用动态大小的堆栈缓冲区时要当心。如果你预期有大量的点，可能要想着动态分配一些内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGPoint segments[kPointCount * 2];</span><br><span class="line">CGPoint *scan = segments;</span><br><span class="line"></span><br><span class="line">for (NSInteger i = 0; i &lt; kPointCount - 1; i++) &#123;</span><br><span class="line">    *scan++ = self.points[i];</span><br><span class="line">    *scan++ = self.points[i + 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Strokes points 0-&gt;1 2-&gt;3 4-&gt;5</span><br><span class="line">CGContextStrokeLineSegments (context, segments, kPointCount * 2);</span><br></pre></td></tr></table></figure>
<p>Swift 很相似，不过免除了要注意堆栈缓冲区的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var segments: [CGPoint] = []</span><br><span class="line"></span><br><span class="line">for i in 0 ..&lt; points.count - 1 &#123;</span><br><span class="line">    segments += [points[i]]</span><br><span class="line">    segments += [points[i + 1]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Strokes points 0-&gt;1 2-&gt;3 4-&gt;5</span><br><span class="line">CGContextStrokeLineSegments (context, segments, segments.count)</span><br></pre></td></tr></table></figure>
<h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>在进行总结之前的最后一点。Core Graphics 可以相当快，但它有一个问题就是在一个 path 中重叠线段的计算开销很高。当 Quartz 渲染一个 path，它不可能就说，”好吧，画这个线段。现在画这个线段。“而不管其他进程。想想一下你在画一个绿色半透明的线。如果你盲目的将线段互相画在其它各自之上，你可能会因为有一些图层的半透明绿色”颜料“重叠而得到深一些的颜色。在画一个线段之前，Quartz 需要搞清楚重叠的部分在哪一集不要重复绘制。</p>
<p>下面是将一组线作为一个 path 绘制或者作为多个线段绘制的效果：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-overlap.png" alt=""></p>
<p>注意看看当你有一大堆互相重叠的线时的表现——重叠部分的计算成本（相对于所有其它 Quartz 的工作）是大于 O(N) 的并且当有大量线段是变得相当高昂。</p>
<h2 id="下一次"><a href="#下一次" class="headerlink" title="下一次"></a>下一次</h2><p>都是关于 path 的。Path！Path！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-three-lines/&quot;&gt;Core Graphics, Part 2: Contextually Speaking&lt;/a&gt;&lt;br&gt;看看上一篇吧：&lt;a href=&quot;http://chengkang.me/2017/05/23/core-graphics-part-2/&quot;&gt;【译】Core Graphics, 第二部分：说说 context （上下文）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设想这样一条简单的线：就是连接两点的一条直像素序列。有一些有名的算法你可以用来自己做绘制，但是近些日子，我们有了工具箱来帮忙做繁杂的工作。在 Core Graphics 中，一条线就只是一种路径。路径对于许多 Core Graphics 的特性来说都是中心，下一回你会得知很多路径的信息。不过现在，先把线想成被描出轮廓（而非填充）的一系列线的片段。有一大堆普遍的 &lt;code&gt;GState&lt;/code&gt; 参数能影响线（的颜色、宽度、阴影及形变），同样也有 GState 的值与绘制线有关。&lt;/p&gt;
&lt;p&gt;你在这看到的所有线的图片都是用 GrafDemo 创建的。你可以在 &lt;a href=&quot;https://github.com/markd2/GrafDemo&quot;&gt;GitHub&lt;/a&gt; 上找到源码，这里使用的版本为”Release cg-pt3“。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics, 第二部分：说说 context （上下文）</title>
    <link href="http://chengkang.me/2017/05/24/core-graphics-part-2/"/>
    <id>http://chengkang.me/2017/05/24/core-graphics-part-2/</id>
    <published>2017-05-24T15:20:19.000Z</published>
    <updated>2017-05-24T15:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/" target="_blank" rel="external">Core Graphics, Part 2: Contextually Speaking</a><br>看看上一篇吧：<a href="http://chengkang.me/2017/05/23/core-graphics-part-1/">【译】Core Graphics，第一部分：序章</a></p>
</blockquote>
<p>context （上下文）就是 Quartz 的核心：你需要按照某种规范来与当前的 Core Graphics context 交互以真正绘制东西，因此熟悉它、它做什么以及为什么它是这样的是有益处的。</p>
<p>Core Graphics 里面一个基础的操作是创建一个 path。Path 是形状的数学描述。一个 path 可以是一个矩形，或一个圆、一个牛仔帽，或者甚至是泰姬陵。Path 可以用颜色填充——就是说，这个 path 中的所有的点都被设置成特定的颜色。Path 也可以画出轮廓（outlined），或者说叫描边（stroked）。这就像是用一支美术钢笔在路径周围画出一个轮廓。下面分别是一个只画出了轮廓的、一个只填充颜色的和一个既填充了黄色由描蓝边的帽子：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/12/hat-path.png" alt=""></p>
<a id="more"></a>
<p>你可以看到，实际的轮廓可以变得非常复杂。它可以是一种特定的颜色。（轮廓）线也可以有虚线图案。可以用粗线条描边也可以用细线。线的末端可以是方的或圆的，等等等等。有很多种属性。</p>
<p>如果你仔细研读 Core Graphics API，你并不会看到某个方法调用使用了所有的这些设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGStrokePath (path, fillColor, strokeColor, lineWidth, dashPattern, bloodType, endCap)</span><br></pre></td></tr></table></figure>
<p>相反，仅仅是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CGContextStrokePath(CGContextRef c)</span><br></pre></td></tr></table></figure>
<p>那，那些额外的值从哪儿来的？它们就从 context 中来。</p>
<h2 id="一桶零碎"><a href="#一桶零碎" class="headerlink" title="一桶零碎"></a>一桶零碎</h2><p>Context 维持着一堆关于绘制的全局状态，它们是一堆独立的值：</p>
<ul>
<li>current path</li>
<li>current fill 和 stroke colors</li>
<li>line width 和 pattern</li>
<li>line cap 和 join (miter) styles</li>
<li>alpha (transparency), antialiasing 和 blend mode</li>
<li>shadows</li>
<li>transformation matrix</li>
<li>text atrributes （文字属性） (font, size, matrix)</li>
<li>一些冷僻的东西比如 line flatness 和 interpolation quality</li>
<li>以及更多</li>
</ul>
<p>有很多状态量。Core Graphics 维持的状态量的全集并没有被写入文档，因此可能还有更多的设置项。不同种类的 context （比如，图片与 PDF）可能包含额外种类的数据。</p>
<p>不管什么时候当 Core Graphics 被告知要绘制什么东西时，比如“填充一条路径（path），”它都从当前的 context 中去找需要的那部分数据。根据 context 中包含什么，同样的一个代码序列可以有完全不同的结果。一方面，这很强大。一段泛型的绘制代码可以通过 context 改变得到不同的结果。另一方面，context 是一大堆全局状态，而全局状态很容易被无意中搞得乱七八糟。</p>
<p>比如说有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw orange square:</span><br><span class="line">    set color to orange in the current context</span><br><span class="line">    fill a rectangle</span><br></pre></td></tr></table></figure>
<p>你将得到一个橙色正方形。现在假设你还要绘制一个桃心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw red valentine:</span><br><span class="line">    set color to red in the current context</span><br><span class="line">    fill a valentine</span><br></pre></td></tr></table></figure>
<p>耶！一个红心。现在比如说你把画桃心的代码加到你的第一个方法里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">draw orange square:</span><br><span class="line">    set color to orange in the current context</span><br><span class="line">    draw red valentine</span><br><span class="line">    fill a rectangle</span><br></pre></td></tr></table></figure>
<p>你的矩形会是红色而不是橙色。为什么呢？绘制桃心的代码抢占了当前的绘制颜色。你填充矩形的时候那个颜色本来是橙色，但是现在是红的了。如何避免这样的 bug 呢？</p>
<p>有两种方式。一种是在改变状态之前将状态保存起来——如果你要改变全局颜色，保存现在的颜色，改变颜色，绘制，然后恢复之前的颜色。这样只有一两个参数的时候还行，但是如果你要改变很多的时候这个方法并不能扩大规模。还有一些设置项因为一些副作用被改变，因此你也得考虑它们。噢，然后其实在 Core Graphics 里是没法这么做的，因为根本没有当前 context 的 getter。抱歉咯。</p>
<h2 id="这些桶的栈（context-栈）"><a href="#这些桶的栈（context-栈）" class="headerlink" title="这些桶的栈（context 栈）"></a>这些桶的栈（context 栈）</h2><p>另外一种方式是在改变任何东西前保存<em>完整</em>的 context。保存 context，改变颜色或者线宽，绘制，然后恢复完整的 context。Core Graphics API 提供了保存和恢复当前 context 设置的方法。这些设置叫做 graphics state，或者是 GState。事实上，它在背后维持着一个 GStates 栈。</p>
<p>当你保存了当前 context 的设置，它们被压入一个栈中。每一个 context 都有一个栈。当你恢复 graphics state，之前保存的 GState 从栈中弹出来并且编程 context 当前的值。将桃心绘制代码这样修改可以修复“橙色矩形是红色”的 bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">draw red valentine:</span><br><span class="line">    save graphics state</span><br><span class="line">    set color to red in the current context</span><br><span class="line">    fill a valentine</span><br><span class="line">    restore graphics state</span><br></pre></td></tr></table></figure>
<p>然后。完整的绘制调用序列是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set color to orange in the current context</span><br><span class="line">save graphics state</span><br><span class="line">set color to red in the current context</span><br><span class="line">fill a valentine</span><br><span class="line">restore graphics state</span><br><span class="line">fill a rectangle</span><br></pre></td></tr></table></figure>
<p>下面是 GState 的改变：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/12/gstates.png" alt=""></p>
<h2 id="Core-Graphics-API"><a href="#Core-Graphics-API" class="headerlink" title="Core Graphics API"></a>Core Graphics API</h2><p>好了，在抽象层面还行，但是这些东西在你实际看到它时是什么样呢？并不完全如你所想。Core Graphics 是一个 Core Foundation 味道的 API。有很多 Core Foundation 的传统影响着 Core Graphics。最主要的古怪点在于 Core Foundation 对于用指针声明东西有一种莫名其妙的恐惧。结果就是用 Objective-C 中的 “Ref” 类型，比如 <code>CGContextRef</code> 或者 <code>CGColorRef</code>。这些其实是类型重定义之后隐藏了那颗星的指针。</p>
<p>以下是正确的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef currentContext = ....; // 实际上是个指针</span><br></pre></td></tr></table></figure>
<p>以下不正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef *currentContext = ...; // 指向指针的指针</span><br></pre></td></tr></table></figure>
<p>你的绘制代码很少会创建它在其中绘制的 context，而是使用当前 context。你可以在 iOS 中这样获取当前 context：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = UIGraphicsGetCurrentContext ();</span><br></pre></td></tr></table></figure>
<p>在 Desktop Cocoa，OS X 10.10 之前，用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = [NSGraphicsContext.currentContext graphicsPort]</span><br></pre></td></tr></table></figure>
<p>在 10.10 之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = [NSGraphicsContext.currentContext CGContext]</span><br></pre></td></tr></table></figure>
<h2 id="画啊，朋友！"><a href="#画啊，朋友！" class="headerlink" title="画啊，朋友！"></a>画啊，朋友！</h2><p>因为 CG API 是一个面对对象的 C API，方法都是根据它们所操作的“对象”命名的（比如，<code>CGColor</code> 或者 <code>CGContext</code>），并且方法的第一个参数如同 Objective-C 中的 reveiver。因此就是那个“对象”被这些调用改变。</p>
<p>例如，下面是一个画矩形轮廓的 CGContext 调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = ...;  // 参照上方对应平台的调用</span><br><span class="line">CGRect bounds = someView.bounds;</span><br><span class="line">CGContextStrokeRect (context, bounds);</span><br></pre></td></tr></table></figure>
<p>（想了解更多关于矩形的东西？这有两篇 <a href="https://www.bignerdranch.com/blog/rectangles-part-1/" target="_blank" rel="external">Part 1</a>, <a href="https://www.bignerdranch.com/blog/rectangles-part-2/" target="_blank" rel="external">Part 2</a>关于它们的文章。）</p>
<p><code>CGContextStrokeRect</code> 取 <code>CGContextRef</code> 作为第一个参数。这个方法的目的是画出一个特定矩形的轮廓。如果 context 是 image context，或者是用来在屏幕上渲染图形的 context，一个矩形这么多的像素会被设置成 context 当前的颜色（当前的线宽，样式，等等）。如果当前的 context 是 PDF context，那一些指令会被记录下来，在这个 PDF 将来被渲染的时候最终绘制出一个矩形。</p>
<h2 id="清洁-Context"><a href="#清洁-Context" class="headerlink" title="清洁 Context"></a>清洁 Context</h2><p>是时候来点拟真代码了。GrafDemo 是一个将会包含越来越多涉及 CG 各方面 demo 的 app。你可以在 <a href="https://github.com/markd2/GrafDemo" target="_blank" rel="external">GitHub</a> 上找到源码。当前版本在这里 <a href="https://github.com/markd2/GrafDemo/releases/tag/release-cg-pt2" target="_blank" rel="external">Release cg-pt2</a>。</p>
<p>GrafDemo 包含一个绘制了一个在白色背景上由粗蓝线包围的绿色圆形的 NSView，整个 view 由细黑边包围。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/12/good-vs-sloppy-drawing.png" alt=""></p>
<p>这段代码有两个版本：一个有良好的清洁的 GState，另一个没有。请注意在那个 sloppy 版本，蓝色粗线泄露并污染了边界。如果你实际运行这个程序，你会看到这两个 view 并排在一起。一个是 Objective-C 版本；另一个是 Swift 版本。</p>
<p>这个 view 的子类有一个 convenience 方法用来获取当前 context。这应该会让其转移到 iOS 时更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGContextRef) currentContext &#123;</span><br><span class="line">    return [NSGraphicsContext.currentContext graphicsPort];</span><br><span class="line">&#125; // 挡墙 context</span><br></pre></td></tr></table></figure>
<p>这个 view 的 <code>drawRect</code> 实现单纯地设置了描边和填充颜色，期望他们能被背景和边缘绘制方法给用上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawSloppily &#123;</span><br><span class="line">    CGContextRef context = self.currentContext;</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBStrokeColor (context, 0.0, 0.0, 0.0, 1.0); // Black</span><br><span class="line">    CGContextSetRGBFillColor (context, 1.0, 1.0, 1.0, 1.0); // White</span><br><span class="line"></span><br><span class="line">    [self drawSloppyBackground];</span><br><span class="line">    [self drawSloppyContents];</span><br><span class="line">    [self drawSloppyBorder];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背景和边缘的方法非常直接明了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawSloppyBackground &#123;</span><br><span class="line">    CGContextFillRect (self.currentContext, self.bounds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) drawSloppyBorder &#123;</span><br><span class="line">    CGContextStrokeRect (self.currentContext, self.bounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他们都假设 context 是像 <code>drawRect</code> 设置的那样。但是！问题来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawSloppyContents &#123;</span><br><span class="line">    CGContextRef context = self.currentContext;</span><br><span class="line"></span><br><span class="line">    CGRect innerRect = CGRectInset (self.bounds, 20, 20);</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBFillColor (context, 0.0, 1.0, 0.0, 1.0); // Green</span><br><span class="line">    CGContextFillEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBStrokeColor (context, 0.0, 0.0, 1.0, 1.0); // Blue</span><br><span class="line">    CGContextSetLineWidth (context, 6.0);</span><br><span class="line">    CGContextStrokeEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意颜色和线宽的改变。context 保持的是一些全局的状态，因此当前的填充和描边颜色，以及当前的线宽都被污染了。</p>
<h2 id="把我压进去，把你弹出来"><a href="#把我压进去，把你弹出来" class="headerlink" title="把我压进去，把你弹出来"></a>把我压进去，把你弹出来</h2><p>修复这个问题的方法就是在绘制内容前将 graphics context 压入栈。<code>CGContextSaveGState</code> 将当前的 graphics context、 state 的一份拷贝压入栈中。<code>CGContextRestoreGState</code> 从栈顶弹出并替换当前的 context。</p>
<p>下面是会保存 graphics state 的好一点的版本的内容绘制（代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawNiceContents &#123;</span><br><span class="line">    CGContextRef context = self.currentContext;</span><br><span class="line"></span><br><span class="line">    CGContextSaveGState (context); &#123;</span><br><span class="line">        CGRect innerRect = CGRectInset (self.bounds, 20, 20);</span><br><span class="line"></span><br><span class="line">        CGContextSetLineWidth (context, 6.0);</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBFillColor (context, 0.0, 1.0, 0.0, 1.0); // Green</span><br><span class="line">        CGContextFillEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBStrokeColor (context, 0.0, 0.0, 1.0, 1.0); // Blue</span><br><span class="line">        CGContextStrokeEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">    &#125; CGContextRestoreGState (context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过简单地包裹保存、恢复就阻止了这个方法污染其他的方法。</p>
<p>一点关于花括号的事情：这是我个人在有一些平衡的调用时的假模假式，比如说在保存和恢复 GState，或者锁定和解锁互斥。这样非常清楚什么是处在保护中的，并且让它很清楚地能在一眼看下来时被发现有一个保护伞存在，这比一堆左对齐的代码容易看见得多。它们实际上并非 Core Graphics API 的一部分。</p>
<h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>好了，那 Swift 怎么样？GrafDemo 有平行的 Objective-C 实现和 Swift 实现，因此随便选择你要研读哪一段示例代码吧。</p>
<p>幸运的是，用 Swift 写的 CG 的代码和它在 Objective-C 中一样，只是没有了结尾的分号。下面是 sloppy 内容绘制在 Swift 中的样子。<code>currentContext</code> 是一个返回当前绘制 context 的属性（稍后更多细节）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func drawSloppyContents() &#123;</span><br><span class="line">    let innerRect = CGRectInset(bounds, 20.0, 20.0)</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBFillColor (currentContext, 0.0, 1.0, 0.0, 1.0) // Green</span><br><span class="line">    CGContextFillEllipseInRect (currentContext, innerRect)</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBStrokeColor (currentContext, 0.0, 0.0, 1.0, 1.0) // Blue</span><br><span class="line">    CGContextSetLineWidth (currentContext, 6.0)</span><br><span class="line">    CGContextStrokeEllipseInRect (currentContext, innerRect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Scope-的把戏"><a href="#Scope-的把戏" class="headerlink" title="Scope 的把戏"></a>Scope 的把戏</h2><p>不幸的是，我的小把戏在 Swift 中不管用：未经修饰的花括号对变成了一个闭包并造成了语法错误。一种方法是通过创建一个包含这个闭包的函数，并且用它来包裹保存和恢复 context。这个方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private func saveGState(drawStuff: () -&gt; ()) -&gt; () &#123;</span><br><span class="line">    CGContextSaveGState (currentContext)</span><br><span class="line">    drawStuff()</span><br><span class="line">    CGContextRestoreGState (currentContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及相关的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func drawNiceContents() &#123;</span><br><span class="line">    saveGState &#123;</span><br><span class="line">        let innerRect = CGRectInset(self.bounds, 20.0, 20.0)</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBFillColor (self.currentContext, 0.0, 1.0, 0.0, 1.0) // Green</span><br><span class="line">        CGContextFillEllipseInRect (self.currentContext, innerRect)</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBStrokeColor (self.currentContext, 0.0, 0.0, 1.0, 1.0) // Blue</span><br><span class="line">        CGContextSetLineWidth (self.currentContext, 6.0)</span><br><span class="line">        CGContextStrokeEllipseInRect (self.currentContext, innerRect)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的缺点就是你必须使用 <code>self</code> 来在那个块里引用东西。我还没有决定是否要一直使用这个方法。</p>
<h2 id="获取-Context"><a href="#获取-Context" class="headerlink" title="获取 Context"></a>获取 Context</h2><p>获取 <code>CGContext</code> 在 iOS 和 OS X 10.10（以及之后）中相当简单。谢天谢地，Swift 舍弃了类型中的 ”Ref“ 部分，因此你只需要 CGContext。下面是如何在 iOS 中获取当前 context：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let context = UIGraphicsGetCurrentContext()</span><br></pre></td></tr></table></figure>
<p><code>context</code> 是推断类型 CGContext？。它可以为 nil 因为有可能当前没有 context。Objective-C 中 <code>UIGraphicsGetCurrentContext()</code> 返回一个 <code>CGContextRef</code>，因此这个转换是非常容易的。</p>
<p>OS X 10.10 中给 <code>NSGraphicsContext</code> 添加了一个 <code>CGContext</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let context = NSGraphicsContext.currentContext?.CGContext</span><br></pre></td></tr></table></figure>
<p>OS X 10.9 就没这么幸运。<code>NSGraphicsContext -graphicsPort</code> 的调用返回一个 <code>void*</code>。Swift 并没有让改变指针类型变得简单。下面是一个解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private var currentContext : CGContext? &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        // The 10.10 SDK provides a CGContext on NSGraphicsContext, but</span><br><span class="line">        // that&apos;s not available to folks running 10.9, so perform this</span><br><span class="line">        // violence to get a context via a void*.</span><br><span class="line">        // iOS can just use UIGraphicsGetCurrentContext.</span><br><span class="line"></span><br><span class="line">        let unsafeContextPointer = NSGraphicsContext.currentContext()?.graphicsPort</span><br><span class="line"></span><br><span class="line">        if let contextPointer = unsafeContextPointer &#123;</span><br><span class="line">            let opaquePointer = COpaquePointer(contextPointer)</span><br><span class="line">            let context: CGContextRef = Unmanaged.fromOpaque(opaquePointer).takeUnretainedValue()</span><br><span class="line">            return context</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，<code>unsafeContextPointer</code> 是一个 <code>UnsafeMutablePointer&lt;Void&gt;?</code>。如果它不为 nil，用一个 <code>COpaquePointer</code> 将其包裹起来。这只是为了你可以将它传入 <code>Unmanaged</code>。<code>Unmanaged</code> 可以使用这个指针的值，并且因为 <code>CGContext</code> 像 <code>NSObject</code> 一样有引用计数，使用 unretain 的值就将生命周期所有权转交给 ARC 了。<code>takeUnretained</code> 是说”嘿 ARC，这个值你管着吧。它现在是 unretain 的状态，并且可能在 autorelease 池放干时跑不见了。你想办法让它在需要的时候一直在吧。“</p>
<h2 id="联盟中的-GState"><a href="#联盟中的-GState" class="headerlink" title="联盟中的 GState"></a>联盟中的 GState</h2><p>这一次，你遇见了 Core Graphics context，这是一筐筐绘制属性。context 是一个不透明的结构，因此你并不知道里面潜藏着什么。也因为这个全局状态，以及有一些 Core Graphics 调用有副作用的事实（之后会看到，当 path 重新出现的时候），几乎不可能在改变绘制属性之前保存它们。</p>
<p>Core Graphics 有 graphics state 栈的概念，这也存在于 PostScript 中。你可以用 <code>CGContextSaveGState</code> 来将当前 graphics state 的一份拷贝压入栈并且可以通过 <code>CGContextRestoreGState</code> 弹出保存的状态有效地撤销任何对 context 的改变。有一些会污染 context 导致后续绘制出错的代码？用 Save/Restore 包裹把它起来。</p>
<p>Core Graphics 的代码在 Objective-C 和 Swift 中几乎一模一样。在 iOS 和 OS X 上业绩会一模一样，因此 Core Graphics 代码是在相对 Apple 生态系统中的其他部分中移植性相当好的。Swift 中唯一真正困难的是在 Mavericks 系统中从 Cocoa 将 <code>void*</code> 装换成 <code>CGContext</code> （基本上只是从内存地址 A 到内存地址 B 复制 4-8 位），因为 Swift 试图让程序员远离那些底层细节。如果你针对的是 Yosemite 及之后的版本，这就不是个问题了。</p>
<p>下一次：Lines！（是 Lines-爽-耶-开心-好玩-时间，而非 Lines-隐式-未展开的-可选值。）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/&quot;&gt;Core Graphics, Part 2: Contextually Speaking&lt;/a&gt;&lt;br&gt;看看上一篇吧：&lt;a href=&quot;http://chengkang.me/2017/05/23/core-graphics-part-1/&quot;&gt;【译】Core Graphics，第一部分：序章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;context （上下文）就是 Quartz 的核心：你需要按照某种规范来与当前的 Core Graphics context 交互以真正绘制东西，因此熟悉它、它做什么以及为什么它是这样的是有益处的。&lt;/p&gt;
&lt;p&gt;Core Graphics 里面一个基础的操作是创建一个 path。Path 是形状的数学描述。一个 path 可以是一个矩形，或一个圆、一个牛仔帽，或者甚至是泰姬陵。Path 可以用颜色填充——就是说，这个 path 中的所有的点都被设置成特定的颜色。Path 也可以画出轮廓（outlined），或者说叫描边（stroked）。这就像是用一支美术钢笔在路径周围画出一个轮廓。下面分别是一个只画出了轮廓的、一个只填充颜色的和一个既填充了黄色由描蓝边的帽子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.bignerdranch.com/assets/img/blog/2014/12/hat-path.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics，第一部分：序章</title>
    <link href="http://chengkang.me/2017/05/23/core-graphics-part-1/"/>
    <id>http://chengkang.me/2017/05/23/core-graphics-part-1/</id>
    <published>2017-05-23T21:20:01.000Z</published>
    <updated>2017-05-23T21:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-1-in-the-beginning/" target="_blank" rel="external">Core Graphics, Part 1: In the Beginning - Mark Dalrymple</a></p>
</blockquote>
<p>Mac 和 iOS 开发者有许多不同的让东西显示在屏幕上的编程接口。UIKit 和 AppKit 有各种各样的 image、color 和 path 类。Core Animation 让你可以移动 layer。OpenGL 让你可以在三维空间渲染东西。SpriteKit 让你可以做动画。AVFoundation 让你可以播放视频。</p>
<p>Core Graphics，或者它在市场中被人熟知的名字“Quartz”，是这个平台上最老的图形相关 API 之一。Quartz 构建了大多数二维的东西的基础。想要画些图形，给它们填充上渐变并且加上阴影？用 Core Graphics。想要在屏幕上合成图片？Core Graphics 能解决。想要创建 PDF？还是 Core Graphics。</p>
<a id="more"></a>
<p>CG 是一个相当大的 API，包括了从基本的几何数据结构（例如：点、大小、向量和矩形）和用于操作它们的方法、用于将像素渲染进图片或者屏幕的东西，一直到事件处理。你可以用 CG 来创建“events taps”，它能帮你监听和操作应用中的事件流（鼠标点击、屏幕点击、任意键盘按键）。</p>
<p>好吧。最后一项是有点奇怪。为什么一个 graphics API 要处理用户事件呢？这啊和别的一样，还得从历史说起。而且了解一点历史也可以帮助理解为什么 CG 是那样工作的。</p>
<h2 id="历史中的-PostScript"><a href="#历史中的-PostScript" class="headerlink" title="历史中的 PostScript"></a>历史中的 PostScript</h2><p>从时间的迷雾往回看（二十世纪八十年代，Duran Duran 还在上升期时），graphic API 相比今天还非常初级。你能做的只有从有限的色盘中挑选颜色、绘制独立的像素点、连线和画一些基本的图形比如矩形和椭圆。你可以设置剪切范围来告诉别人，“嘿，这儿不能画，”而且有时候你会有一些不受控的特性比如调整线有多宽。经常会有一些“像素位块传输”的功能用于将像素块到处复制。Mac 上的 QuickDraw 有一个很酷的功能叫做 <code>regions</code>，它能让你创建任意形状的区域然后使用它们来绘制、剪切、绘制轮廓或者 hit -test。不过基本上，当时的 API 都是面向像素的。</p>
<p>1985 年，Apple 发布了 LaserWriter，一个是其链接的计算机价格两倍的打印机。它包含一个比其链接的计算机更强劲的微处理器，以及一个 12 倍的 RAM。归功于一个叫做 PostScript 的技术，这款打印机（在当时）制作出了魅力惊人的打印制品。</p>
<p>PostScript 是一个来自 Adobe 的基于栈的计算机语言，与 FORTH 类似。PostScript， 这种技术，是为了创建矢量图（艺术的数学描述）而非基于像素。在 LaserWriter 中内嵌了一个 PostScript 解释器，因此当 Mac 上的程序想要打印什么东西的时候，这个程序（或者某个打印机驱动）将会生成一段程序代码，将其载入打印机并执行。</p>
<p>下面是一个 PostScript 代码的例子以及结果图像：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/postscript-code.png" alt=""></p>
<p>你可以在 <a href="https://github.com/markd2/CGPS" target="_blank" rel="external">Github</a> 上找到这个项目。</p>
<p>将页面用代码形式来展现是一个非常重要的设计上的决策。这使得程序可以以算法的形式展现页面中的内容，因此用于执行这段程序的设备能够用其最大分辨率来绘制页面。对于当时大多数打印机，这个值是 300dpi。对于其他的，1200dpi。它们都是由同样的生成的程序绘制的。</p>
<p>除了渲染页面，PostScript 是图灵完备的，并且可以被当作通用编程语言。你甚至可以用它写 Web Server。</p>
<h2 id="Companion-CuBEs"><a href="#Companion-CuBEs" class="headerlink" title="Companion CuBEs"></a>Companion CuBEs</h2><p>NeXT 工程师在设计他们的系统时，他们选择了 PostScript 作为渲染模型。Display PostScript，简称 DPS，扩展了 PostScript 模型，使其能够在窗口化的计算机显示器工作。不过其核心仍是一个 PostScript 解释器。NeXT 的应用可以用 PostScript 代码实现其屏幕绘制，并且用同一段代码进行打印。你同样也可以用 C 函数来包裹 postScript （使用一个叫 pswrap 的程序）以从应用代码中调用。</p>
<p>Display PostScript 是用户交互的基础。事件（鼠标、键盘、更新等等）通过 DPS 系统然后被分发到应用中去。</p>
<p>NeXT 并非当时唯一使用 PostScript 的窗口化系统。Sun 的 NeWS（除了名字像之外，和 NeXT 没有一点关系）也有一个用于驱动系统中用户交互的内嵌 PostScript 解释器。</p>
<h2 id="说说-Quartz"><a href="#说说-Quartz" class="headerlink" title="说说 Quartz"></a>说说 Quartz</h2><p>为什么 OS X 和 iOS 不用 Display PostScript？基本上是钱的原因。Adobe 收取 Display PostScript 证书费用。同时，Apple 也是有名的想要尽可能有更多他们自有的技术栈。通过实现 PostScript 绘制模型，但并不真正使用 PostScript，他们既避免了付证书费也有了 Core Graphics 的代码。</p>
<p>有一种普遍的说法是 Quartz 是“基于” PDF 的，在某种意义上的确如此。PDF 就是没有任意编程功能的 PostScript 绘制模型。Quartz 被设计成其 API 的典型使用和 PDF 本身支持的非常接近，以至于在这个平台上创建 PDF 几乎不费吹灰之力。</p>
<p>哪怕 Display PostScript 被 Quartz 取代了，同样的基本原理被保留下来了，包括事件处理。看看 Cocoa 栈轨迹的 18 帧吧。DPS 仍在！</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/stack-trace.png" alt=""></p>
<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>我会在接下来的几周讲到更多 Quartz 细节的各个方面，但是有一个重点是用于“画东西”的那段代码被从实际图形渲染中抽象出来了。“渲染”可以是“让东西在 NSView 中显示”，或者“让东西显示在 UIImage 里面”，甚至是“让东西显示在 PDF 中”。</p>
<p>你所有的 CG 绘制都在一个“context（上下文）”中执行，它是数据结构和用于控制如何绘制的方法的指针的集合。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/output.png" alt=""></p>
<p>Context 有很多种，比如（在 Mac 上）有 NSWindowGraphicsContext。这一特定 context 获取你的代码安排的绘制指令，然后在你的应用的地址空间里中一块共享内存里绘制出像素。这一段内存也与窗口服务器共享。窗口服务器将所有正在运行的应用的窗口表面样子一起展示在屏幕上。</p>
<p>另一种 CG Context 是一种图片 context。任何你运行的绘制代码都会将像素布置在一个位图图片中。你可以使用这个图片来绘入其它 context 中或者作为 PNG 或 JPEG 保存在文件系统。同样也有一个 PDF context。运行的绘制代码不会变成像素，而是变成了 PDF 命令并被存进一个文件中。此后，PDF查看器可以使用那些 PDF 命令来渲染成某种可以查看的东西。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/different-results.png" alt=""></p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>下一次，更近距离来看看 context，以及一些 Core Graphics 中的便捷 API。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-1-in-the-beginning/&quot;&gt;Core Graphics, Part 1: In the Beginning - Mark Dalrymple&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mac 和 iOS 开发者有许多不同的让东西显示在屏幕上的编程接口。UIKit 和 AppKit 有各种各样的 image、color 和 path 类。Core Animation 让你可以移动 layer。OpenGL 让你可以在三维空间渲染东西。SpriteKit 让你可以做动画。AVFoundation 让你可以播放视频。&lt;/p&gt;
&lt;p&gt;Core Graphics，或者它在市场中被人熟知的名字“Quartz”，是这个平台上最老的图形相关 API 之一。Quartz 构建了大多数二维的东西的基础。想要画些图形，给它们填充上渐变并且加上阴影？用 Core Graphics。想要在屏幕上合成图片？Core Graphics 能解决。想要创建 PDF？还是 Core Graphics。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>react-native-lahk-marquee-label（跑马灯文字组件）</title>
    <link href="http://chengkang.me/2017/04/11/react-native-lahk-marquee-label/"/>
    <id>http://chengkang.me/2017/04/11/react-native-lahk-marquee-label/</id>
    <published>2017-04-11T17:33:17.000Z</published>
    <updated>2017-04-14T21:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>A react-native marquee label component.</p>
<p>一个 react-native 跑马灯文字组件。</p>
</blockquote>
<p>If you need a vertical marquee label, please use <a href="https://github.com/cheng-kang/react-native-lahk-marquee-label-vertical" target="_blank" rel="external">react-native-lahk-marquee-label-vertical</a>.</p>
<p><a href="https://badge.fury.io/js/react-native-lahk-marquee-label" target="_blank" rel="external"><img src="https://badge.fury.io/js/react-native-lahk-marquee-label.svg" alt="npm version"></a></p>
<h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ol>
<li><a href="#desc">Desc</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#props">Props</a></li>
<li><a href="#中文介绍">中文介绍</a></li>
</ol>
<h2 id="Desc"><a href="#Desc" class="headerlink" title="Desc"></a>Desc</h2><p><a href="#install">Skip this part, go to <strong>#Install</strong></a></p>
<p>I needed a marquee label in one of my recent project and I didn’t find a good one online, so I decided to create my own marquee label component.</p>
<p>I intended to make it work well on both iOS and Android, still there remains one thing in iOS which I cannot fix. I found that in <strong>iOS</strong>, when you use <code>View</code> component to wrap child components and don’t explicitly set the parent <code>View</code> component width (e.g. use <code>flex</code>), the parent <code>View</code> component will have the same width as it’s child. </p>
<p>It becomes a problem in this custom component because I use a child <code>View</code> component to wrap <code>Text</code> component in order to make the text expand and show in one line. I <strong>set the text containner <code>View</code> component size to be bigger than the <code>Text</code> so that it will not have multiple lines nor have the overflow text replaced by ellipsis.</strong> The default value of text container width is 1000, which is usually larger than the actual label width. This results in the problem mentioned above, the wrapper <code>View</code> width becomes 1000 also.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View <span class="class"><span class="keyword">class</span></span>=<span class="string">"marquee-label"</span>&gt;</span><br><span class="line">  &lt;View class="marquee-label-text-container"&gt;</span><br><span class="line">    &lt;Text class="marquee-label-text"&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>In Andorid, you can use both <code>width</code> or <code>flex</code> to layout the view.</li>
<li>In iOS, use <code>width</code> to layout the view. <code>flex</code> layout is not supported.</li>
</ul>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native-lahk-marquee-label</span><br></pre></td></tr></table></figure>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol>
<li>Import</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MarqueeLabel <span class="keyword">from</span> <span class="string">'react-native-lahk-marquee-label'</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>Use</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarqueeLabel</span><br><span class="line">  duration=&#123;<span class="number">8000</span>&#125;</span><br><span class="line">  text=&#123;<span class="string">'This is a Marquee Label.'</span>&#125;</span><br><span class="line">  textStyle=&#123;&#123; fontSize: <span class="number">13</span>, color: <span class="string">'white'</span> &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarqueeLabel</span><br><span class="line">  speed=&#123;<span class="number">250</span>&#125;</span><br><span class="line">  textStyle=&#123;&#123; fontSize: <span class="number">13</span>, color: <span class="string">'white'</span> &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  This is a Marquee Label.</span><br><span class="line">&lt;<span class="regexp">/MarqueeLabel&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ul>
<li><code>children</code>: string, the text to show in the marquee. Alternative to <code>text</code>.</li>
<li><code>text</code>: string, the text to show in the marquee. Alternative to <code>children</code>.</li>
<li><code>duration</code>: number(unit: millisecond), the duration for the marquee to run one round. e.g. 6000 (for 6 seconds a round). Alternative to <code>speed</code>.</li>
<li><code>speed</code>: number(unit: px/s, px per second), the speed of the marquee. Alternative to <code>duration</code>.</li>
<li><code>bgViewStyle</code>: stylesheet object, background view component custom styles.</li>
<li><code>textStyle</code>: stylesheet object, text component custom styles.</li>
<li><code>textContainerWidth</code>: number, text container component width. If the text is not shown in one line, increase this value.</li>
<li><code>textContainerHeight</code>: number, text container component height. If the text is not shown in one line, increase this value.</li>
<li><code>textContainerStyle</code>: stylesheet object, not recommended to use, text containner component custom style.</li>
</ul>
<h2 id="中文介绍"><a href="#中文介绍" class="headerlink" title="中文介绍"></a>中文介绍</h2><p><a href="#install">跳转到 <strong>#install</strong></a></p>
<p>我在一个项目中需要用到跑马灯，但是在网上没找到好用的。所以我就自己写了一个跑马灯的组件。</p>
<p>本来打算让它可以在 iOS 和 Android 平台上都好用的，不过还是在 iOS 平台上存在一个问题没法解决。</p>
<p>我发现在 iOS 平台上，当使用 <code>View</code> 组件来包裹子组件的时候，如果没有显示设置父级 <code>View</code> 组件的宽度（width 样式）（比如用 <code>flex</code> 布局），那么父级 <code>View</code> 组件的宽度会被自动设置成子组件的宽度。（至少当子组件比父组件宽度大时是这样的，另外一种情况我没有做试验。）</p>
<p>我的跑马灯组件中的问题在于，我用了一个子级 <code>View</code> 组件来包裹 <code>Text</code> 组件以保证文字是在一行全部显示。<strong>通过将 text container 的宽度设置得比 <code>Text</code> 组件宽度大，保证了文字不会换行，也不会用省略号替换溢出文字。</strong> text container 默认宽度为 1000，这比一般的跑马灯标签实际宽度要大。而这也就导致了上述的问题，最外层的 <code>View</code> 的宽度也变成了 1000。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View <span class="class"><span class="keyword">class</span></span>=<span class="string">"marquee-label"</span>&gt;</span><br><span class="line">  &lt;View class="marquee-label-text-container"&gt;</span><br><span class="line">    &lt;Text class="marquee-label-text"&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>因此要注意：</strong></p>
<ul>
<li>在 Android 平台上，通过 <code>width</code> 或者 <code>flex</code> 布局来设置最外层 <code>View</code> 的样式都没问题。</li>
<li>在 iOS 平台上，请使用并且只能使用 <code>width</code> 来设置样式。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A react-native marquee label component.&lt;/p&gt;
&lt;p&gt;一个 react-native 跑马灯文字组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you need a vertical marquee 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DoubanFMPlayer, A mimic of Douban.fm player</title>
    <link href="http://chengkang.me/2017/02/03/DoubanFMPlayer,%20A%20mimic%20of%20Douban.fm%20player/"/>
    <id>http://chengkang.me/2017/02/03/DoubanFMPlayer, A mimic of Douban.fm player/</id>
    <published>2017-02-03T22:31:30.000Z</published>
    <updated>2017-02-12T19:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Project Page: <a href="https://github.com/cheng-kang/DoubanFMPlayer" target="_blank" rel="external">https://github.com/cheng-kang/DoubanFMPlayer</a></p>
</blockquote>
<p>A mimic of Douban.fm player on <a href="https://douban.fm/" target="_blank" rel="external">Douban.fm</a>. <em>Also a Flex practice project.</em></p>
<p>You can use it on your website or <strong>embed it in your Hexo theme</strong>.</p>
<h2 id="Showcase"><a href="#Showcase" class="headerlink" title="Showcase"></a>Showcase</h2><p>Click <a href="http://chengkang.me/DoubanFMPlayer/">here</a> to check live demo.</p>
<h3 id="Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page"><a href="#Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page" class="headerlink" title="Dark Theme (the color of the player is dark, used in light color web page)"></a>Dark Theme (the color of the player is dark, used in light color web page)</h3><p><img src="https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-1.gif" alt=""></p>
<h3 id="Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page"><a href="#Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page" class="headerlink" title="Light Theme (the color of the player is light, used in dark color web page)"></a>Light Theme (the color of the player is light, used in dark color web page)</h3><p><img src="https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-2.gif" alt=""></p>
<a id="more"></a>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>Feel free to download source code from <code>/src</code> folder.</p>
<p>Alternatively, use the cdn I’ve set up:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbfmplayer.js: http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js</span><br><span class="line">dbfmplayer.css: http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.css</span><br></pre></td></tr></table></figure></p>
<h3 id="1-Use-it-on-your-website"><a href="#1-Use-it-on-your-website" class="headerlink" title="1. Use it on your website"></a>1. Use it on your website</h3><ol>
<li><p>Add any numbers of <code>dbfmplayer</code> tag to your HTML file.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dbfmplayer </span><br><span class="line">    title=&quot;茜さす 帰路照らされど…&quot; </span><br><span class="line">    singer=&quot;椎名林檎&quot;</span><br><span class="line">    album=&quot;https://img1.doubanio.com/lpic/s2722629.jpg&quot;</span><br><span class="line">    music=&quot;http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4&quot;</span><br><span class="line">&gt;&lt;/dbfmplayer&gt;</span><br></pre></td></tr></table></figure>
<p> You <strong>must</strong> set <code>title</code>, <code>singer</code>, <code>album</code> and <code>music</code> attributes of your <code>dbfmplayer</code> tags.</p>
<ul>
<li><code>title</code>: name of the music</li>
<li><code>singer</code>: name of the singer/musician</li>
<li><code>album</code>: URL of a picture related to this music (both absolute URL or relative URL)</li>
<li><p><code>music</code>: URL of the music (both absolute URL or relative URL)</p>
<p><strong>Optional</strong> attributes are <code>theme</code> and <code>loop</code>.</p>
</li>
<li><p><code>theme</code>: “dark” or “light”. Default theme is “dark”, which is suitable for light color background web pages; theme “light” is suitable for dark color background web pages.</p>
</li>
<li><code>loop</code>: “true” or “false”. Default value is “false”. If <code>loop</code> is set to “true”, the music will loop after it ends.</li>
<li><p><code>autoplay</code>: “true” or “false”. Default value is “false”. If <code>autoplay</code> is set to “true”, the music will automatically start when it’s loaded.</p>
<p>You can set <code>loop</code> and <code>autoplay</code> to “true” in a convenient way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dbfmplayer </span><br><span class="line">    title=&quot;茜さす 帰路照らされど…&quot; </span><br><span class="line">    singer=&quot;椎名林檎&quot;</span><br><span class="line">    album=&quot;https://img1.doubanio.com/lpic/s2722629.jpg&quot;</span><br><span class="line">    music=&quot;http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4&quot;</span><br><span class="line">    loop</span><br><span class="line">    autoplay</span><br><span class="line">&gt;&lt;/dbfmplayer&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Add the following script to your HTML file.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123; // DON&apos;T EDIT BELOW THIS LINE</span><br><span class="line">    var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = &apos;http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js&apos;;</span><br><span class="line">    (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-Embed-it-in-your-Hexo-theme"><a href="#2-Embed-it-in-your-Hexo-theme" class="headerlink" title="2. Embed it in your Hexo theme"></a>2. Embed it in your Hexo theme</h3><ol>
<li><p>Add the following script to your layout file for <strong>Post</strong> (or anywhere else you want):</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123; // DON&apos;T EDIT BELOW THIS LINE</span><br><span class="line">    var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = &apos;http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js&apos;;</span><br><span class="line">    (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now users can add music to their page by adding the <code>dbfmplayer</code> tag to their articles (markdown files) by following <a href="#1-use-it-on-your-website">1.1 Add any numbers of <code>dbfmplayer</code> tag to your HTML file.</a>. </p>
</li>
</ol>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Most SVG icons come from <a href="https://icomoon.io/" target="_blank" rel="external">Iconmoon.io</a>.</p>
<p>Designed by <a href="https://douban.fm" target="_blank" rel="external">Douban.fm</a>.</p>
<h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p><strong>All copyright of the design belongs to who creates it.</strong> </p>
<p>Any copyright issue, please contact <a href="mailto:hi@chengkang.me">hi@chengkang.me</a>.</p>
<dbfmplayer title="茜さす 帰路照らされど…" singer="椎名林檎" album="https://img1.doubanio.com/lpic/s2722629.jpg" music="http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4" theme="dark" loop autoplay></dbfmplayer>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Project Page: &lt;a href=&quot;https://github.com/cheng-kang/DoubanFMPlayer&quot;&gt;https://github.com/cheng-kang/DoubanFMPlayer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A mimic of Douban.fm player on &lt;a href=&quot;https://douban.fm/&quot;&gt;Douban.fm&lt;/a&gt;. &lt;em&gt;Also a Flex practice project.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You can use it on your website or &lt;strong&gt;embed it in your Hexo theme&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Showcase&quot;&gt;&lt;a href=&quot;#Showcase&quot; class=&quot;headerlink&quot; title=&quot;Showcase&quot;&gt;&lt;/a&gt;Showcase&lt;/h2&gt;&lt;p&gt;Click &lt;a href=&quot;http://chengkang.me/DoubanFMPlayer/&quot;&gt;here&lt;/a&gt; to check live demo.&lt;/p&gt;
&lt;h3 id=&quot;Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page&quot;&gt;&lt;a href=&quot;#Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page&quot; class=&quot;headerlink&quot; title=&quot;Dark Theme (the color of the player is dark, used in light color web page)&quot;&gt;&lt;/a&gt;Dark Theme (the color of the player is dark, used in light color web page)&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page&quot;&gt;&lt;a href=&quot;#Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page&quot; class=&quot;headerlink&quot; title=&quot;Light Theme (the color of the player is light, used in dark color web page)&quot;&gt;&lt;/a&gt;Light Theme (the color of the player is light, used in dark color web page)&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Examples to understand how to find Nash equilibrium by eliminating “dominated strategies”</title>
    <link href="http://chengkang.me/2017/01/18/Examples%20to%20understand%20how%20to%20find%20Nash%20equilibrium%20by%20eliminating%20%E2%80%9Cdominated%20strategies%E2%80%9D/"/>
    <id>http://chengkang.me/2017/01/18/Examples to understand how to find Nash equilibrium by eliminating “dominated strategies”/</id>
    <published>2017-01-18T17:14:22.000Z</published>
    <updated>2017-01-18T17:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is a summarization of contents from two different sources. It aims at helping people (at least myself) to understand what <code>dominated strategies</code> are and especially what <strong>weakly dominated strategy</strong> is.</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Suppose <em>si</em> and <em>s’i</em> are two strategies for player <em>i</em> in a normal form game.</p>
<p>We say <em>s’i</em> is <strong>strictly dominated</strong> by <em>si</em> if, for every choice of strategies of the other players, <em>i</em>’s payoff from choosing <em>si</em> is <code>strictly greater than</code> <em>i</em>’s payoff from choosing <em>s’i</em>.</p>
<p>We call <em>s’i</em> dominated strategy and <em>si</em> dominant strategy.</p>
<p>We say <em>s’i</em> is <strong>weakly dominated</strong> by <em>si</em> if, for every choice of strategies of the other players, <em>i</em>’s payoff from chossing <em>si</em> is <code>at least as great as</code> <em>i</em>’s payoff from choosing <em>s’i</em>.</p>
<a id="more"></a>
<h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h2><ol>
<li>If a unique strategy remains for the player, we call this the player’s dominant strategy.</li>
<li>If a unique strategy remains for all players, we call this strategy profile a dominant<br>strategy equilibrium.</li>
<li>A dominant strategy equilibrium is a Nash equilibrium. And we can eliminate<br>dominated strategies without losing any Nash equilibria.</li>
<li>If the iterated elimination of weakly dominated strategies leaves exactly one strategy<br>for each player, the resulting strategy profile is a Nash equilibrium. <strong>However some Nash equilibria can be discarded this way.</strong></li>
</ol>
<h2 id="Example-of-eliminating-strictly-dominated-strategies"><a href="#Example-of-eliminating-strictly-dominated-strategies" class="headerlink" title="Example of eliminating strictly dominated strategies"></a>Example of eliminating strictly dominated strategies</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">Agent2</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">L</td>
<td style="text-align:center">C</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center"><strong>Agent1</strong></td>
<td style="text-align:center">T</td>
<td style="text-align:center">73, 25</td>
<td style="text-align:center">57, 42</td>
<td style="text-align:center">66,32</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">80, 26</td>
<td style="text-align:center">35, 12</td>
<td style="text-align:center">32,54</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:center">28, 27</td>
<td style="text-align:center">63, 31</td>
<td style="text-align:center">54,29</td>
</tr>
</tbody>
</table>
<p>L can be eliminated since it is strictly dominated by R, and then M can be eliminated since it is strictly dominated by both T and B, and then R can be eliminated since it is strictly dominated by C. Now Agent1 will choose B, which will result in a payoff of <strong>63, 31</strong>.</p>
<h2 id="Example-of-eliminating-weakly-dominated-strategies"><a href="#Example-of-eliminating-weakly-dominated-strategies" class="headerlink" title="Example of eliminating weakly dominated strategies"></a>Example of eliminating weakly dominated strategies</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">Agent2</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">L</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center"><strong>Agent1</strong></td>
<td style="text-align:center">T</td>
<td style="text-align:center">1, 1</td>
<td style="text-align:center">0, 0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">1, 1</td>
<td style="text-align:center">2, 1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:center">0, 0</td>
<td style="text-align:center">2, 1</td>
</tr>
</tbody>
</table>
<p>This example illustrates the difficulties that may occur when eliminating weakly dominated strategies.</p>
<p>The actions that survive iterated elimination of weakly dominated strategiescan depend on the order in which the actions are eliminated.</p>
<ol>
<li><p>For example, T can be eliminated since it is weakly dominated by M,and then L can be eliminated since it is weakly dominated by R. Now, agent2 will choose action R, which will result in a payoff of <strong>(2, 1)</strong> for which ever action agent 1 selects.</p>
</li>
<li><p>On the other hand, action B could have been eliminated first since it is weakly dominated by M, and then R could have been eliminated since it is weakly dominated by L. Now, the payoff is <strong>(1, 1)</strong> for which ever action agent 1 selects.</p>
</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1]<a href="http://tuvalu.santafe.edu/~jkchoi/ch2_a.pdf" target="_blank" rel="external">Leading fromStrength: Eliminating Dominated Strategies</a></p>
<p>[2]<a href="https://cs.uwaterloo.ca/~klarson/teaching/F08-886/WeaklyDominatedStrats.pdf" target="_blank" rel="external">Weakly Dominated Strategies</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is a summarization of contents from two different sources. It aims at helping people (at least myself) to understand what &lt;code&gt;dominated strategies&lt;/code&gt; are and especially what &lt;strong&gt;weakly dominated strategy&lt;/strong&gt; is.&lt;/p&gt;
&lt;h2 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h2&gt;&lt;p&gt;Suppose &lt;em&gt;si&lt;/em&gt; and &lt;em&gt;s’i&lt;/em&gt; are two strategies for player &lt;em&gt;i&lt;/em&gt; in a normal form game.&lt;/p&gt;
&lt;p&gt;We say &lt;em&gt;s’i&lt;/em&gt; is &lt;strong&gt;strictly dominated&lt;/strong&gt; by &lt;em&gt;si&lt;/em&gt; if, for every choice of strategies of the other players, &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;si&lt;/em&gt; is &lt;code&gt;strictly greater than&lt;/code&gt; &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;s’i&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We call &lt;em&gt;s’i&lt;/em&gt; dominated strategy and &lt;em&gt;si&lt;/em&gt; dominant strategy.&lt;/p&gt;
&lt;p&gt;We say &lt;em&gt;s’i&lt;/em&gt; is &lt;strong&gt;weakly dominated&lt;/strong&gt; by &lt;em&gt;si&lt;/em&gt; if, for every choice of strategies of the other players, &lt;em&gt;i&lt;/em&gt;’s payoff from chossing &lt;em&gt;si&lt;/em&gt; is &lt;code&gt;at least as great as&lt;/code&gt; &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;s’i&lt;/em&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Theory" scheme="http://chengkang.me/tags/Game-Theory/"/>
    
      <category term="Dominated Strategies" scheme="http://chengkang.me/tags/Dominated-Strategies/"/>
    
  </entry>
  
  <entry>
    <title>QnA，一个 Hexo FAQ 主题</title>
    <link href="http://chengkang.me/2017/01/14/QnA%EF%BC%8C%E4%B8%80%E4%B8%AA%20Hexo%20FAQ%20%E4%B8%BB%E9%A2%98/"/>
    <id>http://chengkang.me/2017/01/14/QnA，一个 Hexo FAQ 主题/</id>
    <published>2017-01-14T11:47:03.000Z</published>
    <updated>2017-01-14T12:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前在 Gitbook 上创建了一个 FAQ 网站，但是 Gitbook 使用起来偏麻烦，而且主题不好看。预期创建一个 Gitbook 主题，不如创建一个 Hexo 主题，然后将网站部署到 Github 上。于是我便动手制作了这个主题。</p>
<p>这个主题的最初目的是为了服务这个网站 <a href="http://chengkang.me/Swift-Newbie/">Swift Newbie: 给 Swift 新手的知识库</a>，对 Swift 学习感兴趣的同学可以点开看看，有意贡献的同学可以联系我 <code>hi@chengkang.me</code>。</p>
<p>项目主页：<a href="https://github.com/cheng-kang/hexo-theme-qna" target="_blank" rel="external">《Theme QnA for Hexo》</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cheng-kang/hexo-theme-qna/master/QnA.png" alt=""></p>
<p>为 Hexo 设计的『知识库』类主题。</p>
<a id="more"></a>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="./Documentation.md">Documentation English Version</a></li>
</ul>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示:"></a>展示:</h2><ul>
<li><a href="http://chengkang.me/hexo-theme-qna/">预览</a></li>
<li><a href="http://chengkang.me/Swift-Newbie/">Swift Newbie: 给 Swift 新手的知识库</a></li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/cheng-kang/hexo-theme-qna.git themes/QnA</span><br></pre></td></tr></table></figure>
<h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>修改根目录中 <code>_config.yml</code> 的 <code>theme</code> 为 <code>QnA。</code></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/QnA</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="发布到-Github"><a href="#发布到-Github" class="headerlink" title="发布到 Github"></a>发布到 Github</h3><p>安装 Hexo 插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>编辑你 Hexo 博客根目录中的 <code>_config.yml</code> 文件。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> git</span><br><span class="line"><span class="attr">  repo:</span> &lt;repository url&gt; <span class="comment"># https://github.com/cheng-kang/hexo-theme-qna.git</span></span><br><span class="line"><span class="attr">  branch:</span> [branch] <span class="comment"># master</span></span><br></pre></td></tr></table></figure>
<h3 id="启用中文站内搜索"><a href="#启用中文站内搜索" class="headerlink" title="启用中文站内搜索"></a>启用中文站内搜索</h3><blockquote>
<p>QnA 默认只支持英文站内搜索。</p>
</blockquote>
<p>安装 Hexo 插件 <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="external">hexo-generator-search</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<h3 id="添加新页面"><a href="#添加新页面" class="headerlink" title="添加新页面"></a>添加新页面</h3><ol>
<li><p>添加一个新页面，例如：about 页面。改变页面内容请修改根目录下 source/about/index.md 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 theme/QnA 中的 <code>_config.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> /</span><br><span class="line"><span class="attr">  Archive:</span> /archives</span><br><span class="line">  <span class="comment"># Add new page config here</span></span><br><span class="line">  <span class="comment"># Page Dispay Name: /pagename</span></span><br><span class="line">  <span class="comment"># e.g.</span></span><br><span class="line"><span class="attr">  About:</span> /about</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前在 Gitbook 上创建了一个 FAQ 网站，但是 Gitbook 使用起来偏麻烦，而且主题不好看。预期创建一个 Gitbook 主题，不如创建一个 Hexo 主题，然后将网站部署到 Github 上。于是我便动手制作了这个主题。&lt;/p&gt;
&lt;p&gt;这个主题的最初目的是为了服务这个网站 &lt;a href=&quot;http://chengkang.me/Swift-Newbie/&quot;&gt;Swift Newbie: 给 Swift 新手的知识库&lt;/a&gt;，对 Swift 学习感兴趣的同学可以点开看看，有意贡献的同学可以联系我 &lt;code&gt;hi@chengkang.me&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/cheng-kang/hexo-theme-qna&quot;&gt;《Theme QnA for Hexo》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/hexo-theme-qna/master/QnA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为 Hexo 设计的『知识库』类主题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DanmuManager 一个简单的弹幕工具</title>
    <link href="http://chengkang.me/2017/01/05/DanmuManager%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%B9%E5%B9%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://chengkang.me/2017/01/05/DanmuManager 一个简单的弹幕工具/</id>
    <published>2017-01-05T18:14:32.000Z</published>
    <updated>2017-01-05T13:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目首页： <a href="https://github.com/cheng-kang/DanmuManager" target="_blank" rel="external">DanmuManager Github Repository</a></p>
</blockquote>
<h2 id="使用方法-Usage"><a href="#使用方法-Usage" class="headerlink" title="使用方法 Usage"></a>使用方法 Usage</h2><p><code>DanmuManager</code> 和 <code>VideoDanmuManager</code> 有不同的应用场景，后者用于视频弹幕。</p>
<p>你可以运行项目中的测试，来了解二者的使用方法。<br><a id="more"></a></p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-1.gif" width="200"><br><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-2.gif" width="200"><br><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-3.gif" width="200"></p>
<h3 id="DanmuManager"><a href="#DanmuManager" class="headerlink" title="DanmuManager"></a>DanmuManager</h3><ol>
<li><p>创建 DanmuManager</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dm = DanmuManager(with: self.view)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>初始化 `init` 方法允许自定义： 

- `top`、`bottom`弹幕显示在 `view` 中的上下位置范围;
- `speed` 弹幕的速度;
- `customFont` 弹幕字体（`UIFont`, 包括字体家族和大小，默认为系统字体，字号 20）。
</code></pre><ol>
<li><p>添加一条弹幕 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dm.add(with: “Wow so cool!!!”, at: 4)</span><br></pre></td></tr></table></figure>
<p> 添加弹幕 <code>add</code> 方法有两个必传参数，<code>text</code>（弹幕文字） 和 <code>line</code>（弹幕所在行）;可选参数 <code>hasBorder</code> 用于设置该条弹幕是否有边框（默认 borderColor = UIColor.black.cgColor，borderWidth = 1）,默认值为 false;可选参数 <code>isAdvance</code> 用于设置该条弹幕是否开启高级功能（目前支持修改 文字颜色 和 背景颜色），默认值为 false。</p>
<p> 如果需要弹幕出现在随机行，可以使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func addRandom(with text: String = &quot;This is a test Danmu.&quot;, at line: Int = 0, hasBorder: Bool = false, isAdvanced: Bool = false)`。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>暂停/继续 弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dm.pause()</span><br><span class="line">dm.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以使用 `dm.toggle()` 来快捷切换 暂停/继续。
</code></pre><h3 id="VideoDanmuManager"><a href="#VideoDanmuManager" class="headerlink" title="VideoDanmuManager"></a>VideoDanmuManager</h3><ol>
<li><p>创建 VideoDanmuManager</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let vdm = VideoDanmuManager(view: self.view,</span><br><span class="line">                               videoLength: 10,</span><br><span class="line">                               danmuData: [</span><br><span class="line">                                   (3.4, &quot;3.4 Wowowowowowow!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 SOOOO COOOOOOOOOOL!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 Amazing!!!!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 I love you~&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 MY BABY!!!!&quot;),</span><br><span class="line">                                   (1.1, &quot;1.1 This is a test Danmu!!!&quot;),</span><br><span class="line">                                   (2.0, &quot;2.0 Another test Danmu.&quot;),</span><br><span class="line">                                   (4.1, &quot;4.1 Amazing!!!!&quot;),</span><br><span class="line">                                   (6.1, &quot;6.1 Test!!!!&quot;),</span><br><span class="line">                                   (8.1, &quot;8.1 Test!!!!&quot;),</span><br><span class="line">                                   (9.1, &quot;9.1 Test!!!!&quot;),</span><br><span class="line">                                   (10, &quot;10 Test!!!!&quot;),</span><br><span class="line">           ],</span><br><span class="line">                               isSorted: false</span><br><span class="line">       )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>`VideoDanmuManager` 的创建有三个必选参数，`view`（显示弹幕的视图），`videoLength`（视频时长，精确到 0.1 秒）和 `danmuData`（已经存在的弹幕列表）。

可选参数 `videoCurrent` 默认为 0，即开始时刻；你可以通过传入不同的时间值来设置显示弹幕的初始时间（比如在视频从 1 分 15 秒开始播放，则应设置 `videoCurrent` 为 75）。
可选参数 `isSorted` 默认为 true，即默认数据集已经按照弹幕显示时间从先到后排序；如传入 false，则将自动调用 `func sort()` 对数据进行排序。

可选参数 `top` 和 `bottom` 同 `DanmuManager`。
</code></pre><ol>
<li><p>开启弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.start()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你需要在视频开始播放的同时，手动开启弹幕。
</code></pre><ol>
<li><p>暂停/继续 弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vdm.pause()</span><br><span class="line">vdm.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以使用 `vdm.toggle()` 来快捷切换 暂停/继续。
</code></pre><ol>
<li><p>中止弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.stop()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>重新开始弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.restart()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以在指定时间点重新开始弹幕：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.restart(at: 75)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p><code>DanmuManager</code> 通过设置的字体大小计算文本显示高度 <code>lineHeight</code>，通过 <code>numberOfLines = Int(floor((bottom - top) / lineHeight))</code> 得到可以显示的弹幕行数；使用 <code>inUsingLines</code>，<code>enteringTimers</code> 和 <code>waitingQueues</code> 来分别记录 正在使用的行（有尾部还没有完全进入视图的弹幕的行），正在进入视图的弹幕的计时器 和 正在等待进入的弹幕队列。</p>
<p>为了防止弹幕重叠，只有当 当前行中前一条弹幕尾部进入视图 时（之后），下一条弹幕才可以发射。</p>
<p><code>enteringTimers</code> 中每一个 Timer 都对应一条正在进入视图的弹幕，当计时器结束时，通过 NotificationCenter 发通知将该弹幕所在的行的状态更改为 false。</p>
<p>因为弹幕存在暂停状态，如果弹幕对应的 Timer 不同时暂停，将导致 弹幕所在行状态 提前更改为 false。为了解决这个问题，我参考他人的想法并改进后创建了 PauseableTimer，并在本项目中使用上了。我的另外一篇博客更详细地介绍了 <a href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/">《PauseableTimer》</a>。</p>
<p>为了避免手动发射弹幕和自动发射队列中的弹幕出现冲突（弹幕重叠），所有弹幕通过 <code>taskTimer</code> 定时任务统一调度。</p>
<h2 id="下一步-Next-Step"><a href="#下一步-Next-Step" class="headerlink" title="下一步 Next Step"></a>下一步 Next Step</h2><p>现在流行的弹幕功能越来越复杂、高级，DanmuManager 只是完成了最基础的滚动文字弹幕功能。未来可能会学习常见的弹幕，添加一些更高级的功能，比如 对滚动弹幕的操作，居中弹幕 等。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目首页： &lt;a href=&quot;https://github.com/cheng-kang/DanmuManager&quot;&gt;DanmuManager Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方法-Usage&quot;&gt;&lt;a href=&quot;#使用方法-Usage&quot; class=&quot;headerlink&quot; title=&quot;使用方法 Usage&quot;&gt;&lt;/a&gt;使用方法 Usage&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DanmuManager&lt;/code&gt; 和 &lt;code&gt;VideoDanmuManager&lt;/code&gt; 有不同的应用场景，后者用于视频弹幕。&lt;/p&gt;
&lt;p&gt;你可以运行项目中的测试，来了解二者的使用方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Pauseable Timer 一个可暂停的计时器</title>
    <link href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    <id>http://chengkang.me/2017/01/05/PauseableTimer 一个可暂停的计时器/</id>
    <published>2017-01-05T15:31:35.000Z</published>
    <updated>2017-01-05T13:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目主页: <a href="https://github.com/cheng-kang/PauseableTimer" target="_blank" rel="external">PauseableTimer Github Repository</a><br>英文介绍： <a href="http://chengkang.me/2017/01/04/Pauseable%20Timer/">Pauseable Timer</a></p>
</blockquote>
<p>PauseableTimer 是一个用 Swift 写的可暂停的计时器。</p>
<p>有时候我们需要暂停计时器，但是这个功能在 Timer(Swift3) 中并没有被实现。因此，经过一些失败的尝试，我创建了这个可以暂停的计时器，希望对你也有用。</p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif" alt=""></p>
<a id="more"></a>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol>
<li><p>创建一个计时器 Timer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let timer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: aSelector, userInfo: nil, repeats: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个可暂停的计时器 PauseableTimer，并将之前创建的 Timer 作为参数传入 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let pauseableTimer = PauseableTimer(timer: timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停 然后 重新开始！</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">pauseableTimer.pause()</span><br><span class="line">pauseableTimer.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>如果用于初始化 PauseableTimer 的 Timer 不是通过 scheduledTimer 方法初始化的或没有被加入到 RunLoop 中，那么你需要手动将它加入到 RunLoop 中。你可以这样做，<code>RunLoop.current.add(timer, forMode: .commonModes)</code>。</li>
<li>如果你需要操作用于初始化 PauseableTimer 的 Timer 或者需要获取它的属性，请使用 PauseableTimer 的 <code>timer</code> 属性。就像这样，<code>pauseableTimer.timer.firedate = Date()</code>。</li>
<li><code>invalidate()</code> 方法是为便于手动让 timer 失效而创建的。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PauseableTimer 并没有重新实现 Swift 中的 Timer，而是将 Timer 作为一个属性然后在它的帮助下实现了 暂停 的功能。</p>
<p>这个功能的原理受到 <a href="http://www.jianshu.com/p/e554a164d0da" target="_blank" rel="external">NSTimer 总结1(包括计时器不准的解决)</a> 的启发。 </p>
<p>主要思想是 <code>当你需要暂停的时候，将 Timer 的 firedate 设置为一个无法达到的日期（这样计时器会一直等待，感觉起来就像是暂停了 :D）；当你需要重新开始的时候，将 firedate 设置回原来的时间（这样计时器就可以『照常』触发）</code>。 </p>
<p>简单聪明！</p>
<p>你可能注意到了加了引号的『照常』。事实上，这个方法可能无法达到你的期望，因为</p>
<ol>
<li><p>Firedate 过期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">现在的时间是 2017.01.04 10:25。</span><br><span class="line">原本的 firedate 是 2017.01.04 10:30。</span><br><span class="line">你现在暂停了这个计时器，并且在十分钟后（2017.01.04 10:35）重新开始。这时，计时器已经错过了它预计的 firedate（2017.01.04 10:30）。</span><br><span class="line">然而，如果这个计时器已经在 RunLoop 当中的话，当你在 2017.01.04 10:35 将 firedate 设置回 2017.01.04 10:30 时，计时器会立即触发一次。</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们希望计时器继续等待剩下的等待时间。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">现在的时间是 2017.01.04 10:25:00。</span><br><span class="line">计时器的 timeInterval 是 60 秒。现在计时器被加入到 RunLoop，它应该在 60 秒后触发，也就是在 2017.01.04 10:26:00。</span><br><span class="line">然后你因为某种原因在 10 秒后暂停了它，也就是在 2017.01.04 10:25:10。你在 2017.01.04 10:25:50 的时候重新开始了计时器。</span><br><span class="line">不过，你仍然希望它是在设置好后，等待 60 秒再触发，不管暂停的那段时间。所以它应该再等待 50 秒，然后在 2017.01.04 10:26:40 触发。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完美的解决方案应该是满足以上所述三种情况的（另一种情况是我们不在乎原始 firedate 是否过期）。不过，这个项目目前只解决了第二个情况，因为这是我在其他项目中所遇到的需要解决的问题。</p>
<p>未来我可能会继续这个小项目，然后将每一种情况的解决方案都完善起来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/cheng-kang/PauseableTimer&quot;&gt;PauseableTimer Github Repository&lt;/a&gt;&lt;br&gt;英文介绍： &lt;a href=&quot;http://chengkang.me/2017/01/04/Pauseable%20Timer/&quot;&gt;Pauseable Timer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PauseableTimer 是一个用 Swift 写的可暂停的计时器。&lt;/p&gt;
&lt;p&gt;有时候我们需要暂停计时器，但是这个功能在 Timer(Swift3) 中并没有被实现。因此，经过一些失败的尝试，我创建了这个可以暂停的计时器，希望对你也有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Pauseable Timer</title>
    <link href="http://chengkang.me/2017/01/04/Pauseable%20Timer/"/>
    <id>http://chengkang.me/2017/01/04/Pauseable Timer/</id>
    <published>2017-01-04T22:58:48.000Z</published>
    <updated>2017-01-05T13:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Project Page: <a href="https://github.com/cheng-kang/PauseableTimer" target="_blank" rel="external">PauseableTimer Github Repository</a></p>
<p>Chinese Version: <a href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/">《Pauseable Timer 一个可暂停的计时器》</a></p>
</blockquote>
<p>Pauseable Timer is a pause-able timer written in Swift.</p>
<p>There are occassions when we need timers to pause, however, this feature is not implemented in Timer(Swift3). Thus, after some failed attempts, I create this pause-able timer which hopefully could be useful to you.</p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif" alt=""></p>
<a id="more"></a>
<h2 id="How-to-Use"><a href="#How-to-Use" class="headerlink" title="How to Use"></a>How to Use</h2><ol>
<li><p>Create a Timer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let timer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: aSelector, userInfo: nil, repeats: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a Pauseable Timer and pass the timer as an argument.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let pauseableTimer = PauseableTimer(timer: timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pause and Resume!</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">pauseableTimer.pause()</span><br><span class="line">pauseableTimer.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>Notice</strong></p>
<ul>
<li>If the timer you use to initialize a PauseableTimer is not scheduled (or added to RunLoop) already, you need to manually schedule it (ro add it to RunLoop). You can do it by <code>RunLoop.current.add(timer, forMode: .commonModes)</code>. </li>
<li>Use <code>timer</code> property of PauseableTimer if you need to manipulate the timer or get it’s properties. Like this <code>pauseableTimer.timer.firedate = Date()</code>.</li>
<li>A convinient method <code>invalidate()</code> is created to invalidate the timer.</li>
</ul>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Pauseable Timer does not re-implement Timer in Swift, but takes a Timer as a property and implement ‘Pause’ feature with the help of it.</p>
<p>The concept of this feature is inspired by <a href="http://www.jianshu.com/p/e554a164d0da" target="_blank" rel="external">NSTimer 总结1(包括计时器不准的解决)</a>. </p>
<p>The main idea is <code>set the firedate of Timer to a un-reachable date when you want it pause (the timer will wait until forever and you can take it as pausing :D), and set it back to its original firedate when you want it resume (and the timer will fire &quot;as expected&quot;).</code></p>
<p>Simple and Excellent!</p>
<p>You might have noticed the double qouted “as expected”. Acctually, this might fail your expectation because</p>
<ol>
<li><p>The firedate is expried.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">The current time is 2017.01.04 10:25.</span><br><span class="line">The original firedate is 2017.01.04 10:30.</span><br><span class="line">You pause the timer at this moment and resume it 10 mins after which is 2017.01.04 10:35. So the timer has missed it&apos;s expected firedate. </span><br><span class="line">However it will fire once you set the firedate back to 2017.01.04 10:30 at 2017.01.04 10:35, if the timer is already added to RunLoop.</span><br></pre></td></tr></table></figure>
</li>
<li><p>The timer is expected to wait for the remaining waiting time.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">The current time is 2017.01.04 10:25:00.</span><br><span class="line">The timeInterval of the timer is 60 seconds. It&apos;s scheduled at this moment, and should fire 60 seconds later at 2017.01.04 10:26:00.</span><br><span class="line">And for some reason you pause it 10 seconds after, which is 2017.01.04 10:25:10. And you resume the timer at 2017.01.04 10:25:50.</span><br><span class="line">However, you still want it to fire 60 seconds after it&apos;s scheduled, regardless the pausing part. So it should wait for 50 seconds more and fire at 2017.01.04 10:26:40.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>An ideal solution should be one that fits all 3 conditions (another one is the condition that someone doesn’t care if the original firedate is expired or not) discussed above. However, this project only deals with condition 2 because that is the problem I encountered with.</p>
<p>Hopefully, I will continue this small project in the future and complete it with solutions to every condition.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Project Page: &lt;a href=&quot;https://github.com/cheng-kang/PauseableTimer&quot;&gt;PauseableTimer Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Chinese Version: &lt;a href=&quot;http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/&quot;&gt;《Pauseable Timer 一个可暂停的计时器》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pauseable Timer is a pause-able timer written in Swift.&lt;/p&gt;
&lt;p&gt;There are occassions when we need timers to pause, however, this feature is not implemented in Timer(Swift3). Thus, after some failed attempts, I create this pause-able timer which hopefully could be useful to you.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】我最喜欢的 JavaScript 设计模式</title>
    <link href="http://chengkang.me/2016/07/02/my-favorite-javascript-pattern/"/>
    <id>http://chengkang.me/2016/07/02/my-favorite-javascript-pattern/</id>
    <published>2016-07-02T09:50:25.000Z</published>
    <updated>2016-07-02T02:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.sitepoint.com/my-favorite-javascript-design-pattern/" target="_blank" rel="external">My Favorite JavaScript Design Pattern</a></p>
</blockquote>
<h1 id="我最喜欢的-JavaScript-设计模式"><a href="#我最喜欢的-JavaScript-设计模式" class="headerlink" title="我最喜欢的 JavaScript 设计模式"></a>我最喜欢的 JavaScript 设计模式</h1><p>我觉得聊一下我爱用的 JavaScript 设计模式应该很有意思。我是一步一步才定下来的，经过一段时间从各种来源吸收和适应直到达到一个能提供我所需的灵活性的模式。</p>
<p>让我给你看看概览，然后再来看它是怎么形成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function MyScript()&#123;&#125;</span><br><span class="line">(function()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  var THIS = this;</span><br><span class="line"></span><br><span class="line">  function defined(x)</span><br><span class="line">  &#123;</span><br><span class="line">    return typeof x != &apos;undefined&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.ready = false;</span><br><span class="line"></span><br><span class="line">  this.init = function(</span><br><span class="line">  &#123;</span><br><span class="line">    this.ready = true;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.doSomething = function()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;;   </span><br><span class="line"></span><br><span class="line">  var options = &#123;</span><br><span class="line">      x : 123,</span><br><span class="line">      y : &apos;abc&apos;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  this.define = function(key, value)</span><br><span class="line">  &#123;</span><br><span class="line">    if(defined(options[key]))</span><br><span class="line">    &#123;</span><br><span class="line">      options[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;).apply(MyScript);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如你在实例代码中看到的，整体框架是一个函数直接量（function literal）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>函数直接量基本上就是一个自执行域，相当于定义一个有名的函数然后立即调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p>我最初开始使用函数直接量是为了<code>封装</code>——任何格式的任何脚本都可以被封装在那个闭包里，并且它有效地将它<code>密封</code>在私有域中，从而保护它不会与同一个域里的其它脚本或者数据冲突。在最后面的那一对括号就是在执行这个域，就像其它函数一样调用它。</p>
<p>但是如果，这个域通过使用 <code>Function.apply</code> 来执行而不是全局调用，这可以让它在一个可被外界引用的<em>特定命名</em>的域中执行。</p>
<p>因此通过结合二者——创建一个命名函数，然后在这个命名函数的域内执行一个函数直接量——我们就得到了一个一次性的可以构成任何脚本的基础的对象，它模拟了类似面向对象类的继承性质。</p>
<h2 id="内在之美"><a href="#内在之美" class="headerlink" title="内在之美"></a>内在之美</h2><p>看看第一个代码示例，你就能看到封闭域结构提供了什么样的灵活性。当然，这些你都可以在任何方法中做到，但是通过用这种方式包装起来，我们就有了一个可以和任何命名域联系起来的结构体。</p>
<p>我们可以创建多个这样的结构体，然后将它们和同一个域联系起来，这样它们之间全部可以共享它们的公开数据。</p>
<p>不过在共享公开数据的同事，每一个（结构体）也可以定义它自己的私有数据。下面是一个例子，在脚本的最上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var THIS = this;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个叫做 <code>THIS</code> 的私有变量，它指向这个函数域，并且可以在私有方法中使用——和用 <code>self = this</code> 来创建内部域是一样的招数。</p>
<p>通过同样方式声明的其他私有变量，如果他们定义常量数据的话，可以使用大写传统（不过用 <code>const</code> 而不是 <code>var</code> 来做声明的方式应该被避免，因为对它的支持不是很好）。</p>
<p>私有方法可以用来提供内部功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function defined(x)</span><br><span class="line">&#123;</span><br><span class="line">  return typeof x != &apos;undefined&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以创建其他实例或者外界可以访问的公开方法和属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.ready = false;</span><br><span class="line"></span><br><span class="line">this.init = function()</span><br><span class="line">&#123;</span><br><span class="line">  this.ready = true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.doSomething = function()</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以创建特殊的值——私有但是可以公开定义，在这个例子中是通过公开的 <code>define</code> 方法；它的参数可以根据数据需要再进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">  x : 123,</span><br><span class="line">  y : &apos;abc&apos;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">this.define = function(key, value)</span><br><span class="line">&#123;</span><br><span class="line">  if(defined(options[key]))</span><br><span class="line">  &#123;</span><br><span class="line">    options[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="封装起来！"><a href="#封装起来！" class="headerlink" title="封装起来！"></a>封装起来！</h2><p>所有的这些特点让这个结构体对我非常有用。并且它封装在一个整洁、自我执行的单例中——一个容易引用、整合和使用的一次性对象。</p>
<p>所以你怎么想？这个模式眼熟吗，或者你有什么其他喜欢用的？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.sitepoint.com/my-favorite-javascript-design-pattern/&quot;&gt;My Favorite JavaScript Design Pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;我最喜欢的-JavaScript-设计模式&quot;&gt;&lt;a href=&quot;#我最喜欢的-JavaScript-设计模式&quot; class=&quot;headerlink&quot; title=&quot;我最喜欢的 JavaScript 设计模式&quot;&gt;&lt;/a&gt;我最喜欢的 JavaScript 设计模式&lt;/h1&gt;&lt;p&gt;我觉得聊一下我爱用的 JavaScript 设计模式应该很有意思。我是一步一步才定下来的，经过一段时间从各种来源吸收和适应直到达到一个能提供我所需的灵活性的模式。&lt;/p&gt;
&lt;p&gt;让我给你看看概览，然后再来看它是怎么形成的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function MyScript()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var THIS = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function defined(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return typeof x != &amp;apos;undefined&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.ready = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.init = function(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.ready = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.doSomething = function()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      x : 123,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      y : &amp;apos;abc&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.define = function(key, value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(defined(options[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      options[key] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).apply(MyScript);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Design Pattern" scheme="http://chengkang.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript 命名空间</title>
    <link href="http://chengkang.me/2016/06/28/javascript-namespace-by-michaux/"/>
    <id>http://chengkang.me/2016/06/28/javascript-namespace-by-michaux/</id>
    <published>2016-06-28T15:07:58.000Z</published>
    <updated>2016-06-28T08:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://peter.michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">《JavaScript Namespacing》</a></p>
</blockquote>
<h1 id="JavaScript-命名空间"><a href="#JavaScript-命名空间" class="headerlink" title="JavaScript 命名空间"></a>JavaScript 命名空间</h1><p>JavaScript 中有很多可以给你的对象安全分配命名空间的方法。这篇文章讨论我见过的普遍的实践。</p>
<h2 id="前缀命名空间"><a href="#前缀命名空间" class="headerlink" title="前缀命名空间"></a>前缀命名空间</h2><p>如果命名空间的目的是避免冲突的话。下面这个系统，只要我们知道全局变量名前缀 <em>myApp_</em> 是唯一的，可以像其他系统一样避免命名空间冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// add uniquely named global properties</span><br><span class="line">var myApp_sayHello = function() &#123;</span><br><span class="line">  alert(&apos;hello&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var myApp_sayGoodbye = function() &#123;</span><br><span class="line">  alert(&apos;goodbye&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// use the namespace properties</span><br><span class="line">myApp_sayHello();</span><br></pre></td></tr></table></figure>
<p>C 语言程序经常使用前缀命名空间。在 JavaScript 的世界中，你可能会碰见 Macromedia 的 MM_ 方法，例如 MM_showHideLayers。</p>
<p>我认为前缀命名空间是 JavaScript 中最清楚明白的命名空间系统。（下面的对象命名空间策略在加入了 <code>this</code> 关键字后会导致困惑。）</p>
<p>前缀命名空间的确创建了很多全局对象。这对于前缀用来避免的命名空间冲突并不是什么问题。前缀命名空间的问题是，有些网页浏览器（例如 IE6）在有很多全局对象时表现很糟糕，就我所听说。我做了一些测试并且发现有一个 comp.lang.javascript 的小线程，不过我没有就这个话题研究彻底。</p>
<a id="more"></a>
<h2 id="单对象命名空间"><a href="#单对象命名空间" class="headerlink" title="单对象命名空间"></a>单对象命名空间</h2><p>当下，最流行的 JavaScript 命名空间实践是使用一个全局变量来引用一个对象。这个被引用的对象引用你的『真正的业务』，并且因为你的全局对象的命名独一无二，你的代码和其他人的代码就可以一起嗨皮地运行。</p>
<p>如果你确定这个世界上没有任何人用了这个全局变量名 <em>myApp</em>，那么你可以有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// define the namespace object</span><br><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// add properties to the namespace object</span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(&apos;hello&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">myApp.sayGoodbye = function() &#123;</span><br><span class="line">  alert(&apos;goodbye&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// use the namespace properties</span><br><span class="line">myApp.sayHello();</span><br></pre></td></tr></table></figure>
<p>当上面代码的最后一行执行时，JavaScript 解释器首先找到 <em>myApp</em> 对象，然后找到并调用这个对象的 <em>syaHello</em> 属性。</p>
<p>对象命名空间的一个问题是它会导致与面向对象消息传递混淆。这两者之间并没有明显的句法差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">namespace.prop();</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">receiver.message();</span><br></pre></td></tr></table></figure>
<p>更仔细地研究这个混淆，我们得出下面的命名空间想法。假设我们有以下库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.message = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(myApp.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个库的代码可以随意进行写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.sayHello(); // works</span><br><span class="line">  </span><br><span class="line">var importedfn = myApp.sayHello;</span><br><span class="line"></span><br><span class="line">importedfn(); // works</span><br></pre></td></tr></table></figure>
<p>将这个和那个令人混淆的使用 <code>this</code> 的消息传递版本比较一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.message = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(this.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个库的代码可以随意进行写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.sayHello() // works because &quot;this&quot; refers to myApp object.</span><br><span class="line"></span><br><span class="line">var importedfn = myApp.sayHello;</span><br><span class="line"></span><br><span class="line">importedfn(); // error because &quot;this&quot; refers to global object.</span><br></pre></td></tr></table></figure>
<p>这里面的要上的一课是，<code>this</code> 永远不能引用一个被作为命名空间的对象因为它肯能导致关于从命名空间引入标识符的混淆。这个问题是 <code>this</code> 在我的 <a href="http://peter.michaux.ca/article/7933" target="_blank" rel="external">JavaScript Warning Words</a> 列表中的原因之一。</p>
<p>（这也表明了库的 API 属性应该指向用一个方法，这样这些方法可以被导入其他命名空间。这个问题是在我的文章 <a href="http://peter.michaux.ca/article/3556" target="_blank" rel="external">Lazy Function Definition Pattern</a> 的评论中被指出的。懒惰方法定义可以在被隐藏在库中并且不是 API 的部分时安全使用。）</p>
<h2 id="嵌套对象命名空间"><a href="#嵌套对象命名空间" class="headerlink" title="嵌套对象命名空间"></a>嵌套对象命名空间</h2><p>嵌套对象命名空间是另一个普遍的实践，它扩展了对象命名空间的想法。你可能见过类似如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO.util.Event.addListener(/*...*/)</span><br></pre></td></tr></table></figure>
<p>解决上面的代码需要解释器首先找到全聚德 <em>YAHOO</em> 对象，然后它的 <em>util</em> 对象，然后它的 <em>Event</em> 对象，然后找到并调用它的 <em>addListener</em> 属性。这样的话每次事件处理器绑定到一个 DOM 元素上花的功夫太多了，因此导入的概念开始被采用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var yue = YAHOO.util.Event;</span><br><span class="line">  yue.addListener(/*...*/);</span><br><span class="line">  yue.addListener(/*...*/);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果你清楚 <em>YAHOO.util.Event.addListener</em> 方法不会用 <code>this</code> 关键字并且永远引用同一个方法，那么导入可以变得更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var yuea = YAHOO.util.Event.addEventListener;</span><br><span class="line">  yuea(/*...*/);</span><br><span class="line">  yuea(/*...*/);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我觉得当目的只是避免标识符冲突时，嵌套对象命名空间的复杂是不必要的。难道 Yahoo! 还觉得这些全局标识符 YAHOO_util_Event 和 YAHOO_util_Event_addEventListener 不够独特吗？</p>
<p>我认为使用嵌套对象命名空间的动机是要看起来和 Java 包命名传统一样，这在 Java 中开销不大。例如，在 Java 中你可能看到如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package mytools.text;</span><br><span class="line"></span><br><span class="line">class TextComponent &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个这个类的完全合格的引用应该是 <code>mytools.text.TextComponent</code>。</p>
<p>下面是 Niemeyer 和 Knudsen （写）的 <em>Learning Java</em> 中包命名的描述：</p>
<blockquote>
<p>包名是按层级构成的，使用点分隔的命名传统。包名组成成分给编译器和运行系统构成了独一无二的定位文件的路径。然而，它们并没在包之间创建其他的关系。并没有什么『subpackage』的说法，事实上，包命名空间是直接的，而非层级的。在包层级关系特定部分的包仅仅是因为习惯而有关联。比如，如果我们穿件了另一个叫做 <em>mytools.text.poetry</em> 的包（假设是为了跟诗有关的一些文字类），这些类并不是 <em>mytools.text</em> 包的一部分；它们没有包成员的访问权限。</p>
</blockquote>
<p>嵌套命名空间的幻觉在 Perl 中也存在。在 Perl 中，嵌套包名由双冒号分隔开。你可以看到如下 Perl 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package Red::Blue;</span><br><span class="line">our $var = &apos;foo&apos;;</span><br></pre></td></tr></table></figure>
<p>一个完全合格的上述变量引用应该是 <em>$Red::Blue::var</em>。</p>
<p>在 Perl 中，就像 Java，命名空间层级的主意只是方便程序员，而不是语言本身要求。Wall，Christiansen 和 Orwant 的 <em>Programming Perl</em> 解释道：</p>
<blockquote>
<p>双冒号可被用于链接在包名 <em>$Red::Blue::var</em> 中标识符。这意味着 <em>$var</em> 属于包 <em>Red::Blue</em>。包 <em>Red::Blue</em> 跟可能存在的 <em>Red</em> 包或 <em>Blue</em> 包一点关系都没有。只是说，<em>Red::Blue</em> 和 <em>Red</em> 或者 <em>Blue</em> 之间的关系可能对于写代码或者使用这个程序的人有什么意义，但跟 Perl 没关系。（好吧，除了在现在的实现中，符号表 <em>Red::Blue</em> 刚好存在符号表 <em>Red</em> 中。但是 Perl 语言并没有直接利用过它。）</p>
</blockquote>
<p>上述引用中最后备注暗示了 Perl 可能有和在 JavaScript 中使用嵌套命名空间对象一样的标识符冲突开销。如果 Perl 的实现改变了，这个开销就会消失。在 JavaScript 中，我肯定嵌套对象命名空间的开销永远不会消失因为 JavaScript 使用延迟绑定。</p>
<p>我并不认为 JavaScript 中的嵌套对象命名空间提供了任何大好处，不过如果不使用导入的话在运行时可能会开销非常大。</p>
<h2 id="一个折中方案"><a href="#一个折中方案" class="headerlink" title="一个折中方案"></a>一个折中方案</h2><p>如果单纯地前缀命名空间在某些浏览器中真的很慢，而嵌套命名空间的概念帮助在开发者脑中保持各事务的有序，那我认为上述 Yahoo! 的例子也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO.util_Event_addListener</span><br></pre></td></tr></table></figure>
<p>或者用更多的全局名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO_util_Event.addListener</span><br></pre></td></tr></table></figure>
<h2 id="哪个维度的命名空间？"><a href="#哪个维度的命名空间？" class="headerlink" title="哪个维度的命名空间？"></a>哪个维度的命名空间？</h2><p>Perl 的 CPAN 模块是基于他们所做的事情进行命名空间管理的。例如，我写了一个这个命名空间里的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript::Minifier</span><br></pre></td></tr></table></figure>
<p>如果别人用同样的名字写他自己的模块，并且他不自知地通过某些模块依赖通过同一个名字使用 CPAN 模块，那么就会有冲突。</p>
<p>Java 程序员采用最冗长但当然也是最安全的方法。（Java 程序员似乎都想着在大型系统上运行的代码。）在 Java 中，包经常是基于<strong>谁写的</strong>和<strong>做什么的</strong>来命名。（<em>myFunc</em>风格的规范化。）『谁写的』部分甚至使用开发者自己的相对可以保证唯一性的名字。如果我写一个 Java 的 minifier，因为我有 michaux.ca 的域名，我可能用以下命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca.michaux.javascript.minifier</span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，经过这次讨论，可能这样写效率更高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca_michaux_javascript_minifier</span><br></pre></td></tr></table></figure>
<p>因为 JavaScript 是以文本的形式服务的，这样的命名空间可能开销太大，因为增加了下载时间。Gzip 压缩会找到公共的字符串并用短字符串替换它们。如果 gzip 不可用的话那么就可以考虑使用导入了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ca_michaux_javascript_minifier = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(function() &#123;</span><br><span class="line">  var cmjm = ca_michaux_javascript_minifier;</span><br><span class="line">  </span><br><span class="line">  // refer to cmjm inside this module pattern</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我并不是说这些长的命名空间是绝对必须的，不过他们一定是避免命名空间冲突的最安全方法。</p>
<h2 id="其他命名空间问题"><a href="#其他命名空间问题" class="headerlink" title="其他命名空间问题"></a>其他命名空间问题</h2><p>标识符不仅在 JavaScript 资源中创建。一个表单的 name 属性也被加在 <em>document.forms</em> 对象上。像 <em><form name="myCompany_login"></form></em> 这样命名是有意义的。</p>
<p>命名空间类名属性，比如 <em>&lt;div class=”myCompany_story”&gt;</em>，可以在减少 CSS 命名空间冲突以及当 JavaScript 代码在通过类名搜索 DOM 元素时很有价值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人认为，任何像 <em>YAHOO.util.Event.addListener</em> 这样有点或者下划线的东西都是被冲突吓傻了的。它可以就是 <em>YUI.on</em>。Dojo 通过同样功能的 dojo.connect 提供了足够的保护，因为它有效地涵盖了命名空间『谁』和『做什么』的维度。没有人会在他们的右脑中会这样想并在 dojo 命名空间下写一个 JavaScript 库。Dojo 的开发人员也不会忘记他们已经有了一个 connect 方法并写另外一个。</p>
<p>如果我们能有一个网站来让程序员们保存他们的 JavaScript 全局标识符和下划线前缀，并且当 ECMAScipt4 发布了的时候也包括他们的包名，就好了：『JavaScript 命名空间登记处』。</p>
<p>JavaScript 是一个最小概念集的强大语言。即使 JavaScript 并没有专门为避免命名空间冲突设计的语言级支持，还是有很多解决问题的方法。并没有一个『正确』的答案。选一个你最喜欢的。</p>
<p>不过，无论你做什么，请记住别弄一个另外的全局 $ 标识符。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="http://groups.google.com/group/comp.lang.javascript/browse_frm/thread/494e1757fa51fe3f" target="_blank" rel="external">comp.lang.javascript discussion on namespacing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://peter.michaux.ca/articles/javascript-namespacing&quot;&gt;《JavaScript Namespacing》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 命名空间&quot;&gt;&lt;/a&gt;JavaScript 命名空间&lt;/h1&gt;&lt;p&gt;JavaScript 中有很多可以给你的对象安全分配命名空间的方法。这篇文章讨论我见过的普遍的实践。&lt;/p&gt;
&lt;h2 id=&quot;前缀命名空间&quot;&gt;&lt;a href=&quot;#前缀命名空间&quot; class=&quot;headerlink&quot; title=&quot;前缀命名空间&quot;&gt;&lt;/a&gt;前缀命名空间&lt;/h2&gt;&lt;p&gt;如果命名空间的目的是避免冲突的话。下面这个系统，只要我们知道全局变量名前缀 &lt;em&gt;myApp_&lt;/em&gt; 是唯一的，可以像其他系统一样避免命名空间冲突。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// add uniquely named global properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myApp_sayHello = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(&amp;apos;hello&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myApp_sayGoodbye = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(&amp;apos;goodbye&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// use the namespace properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp_sayHello();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;C 语言程序经常使用前缀命名空间。在 JavaScript 的世界中，你可能会碰见 Macromedia 的 MM_ 方法，例如 MM_showHideLayers。&lt;/p&gt;
&lt;p&gt;我认为前缀命名空间是 JavaScript 中最清楚明白的命名空间系统。（下面的对象命名空间策略在加入了 &lt;code&gt;this&lt;/code&gt; 关键字后会导致困惑。）&lt;/p&gt;
&lt;p&gt;前缀命名空间的确创建了很多全局对象。这对于前缀用来避免的命名空间冲突并不是什么问题。前缀命名空间的问题是，有些网页浏览器（例如 IE6）在有很多全局对象时表现很糟糕，就我所听说。我做了一些测试并且发现有一个 comp.lang.javascript 的小线程，不过我没有就这个话题研究彻底。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://chengkang.me/tags/Namespacing/"/>
    
      <category term="Namespace" scheme="http://chengkang.me/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript 中的命名空间</title>
    <link href="http://chengkang.me/2016/06/21/Namespacing%20in%20JavaScript/"/>
    <id>http://chengkang.me/2016/06/21/Namespacing in JavaScript/</id>
    <published>2016-06-21T20:59:30.000Z</published>
    <updated>2016-06-28T08:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接： <a href="https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/" target="_blank" rel="external">Namespacing in JavaScript</a></p>
</blockquote>
<h1 id="JavaScript-中的命名空间"><a href="#JavaScript-中的命名空间" class="headerlink" title="JavaScript 中的命名空间"></a>JavaScript 中的命名空间</h1><p>全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。</p>
<p>不过，恩，这些你早都知道了……</p>
<p>所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 <a href="http://www.brothercake.com/" target="_blank" rel="external">James Edwards</a> 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。<br><a id="more"></a></p>
<h2 id="静态命名空间"><a href="#静态命名空间" class="headerlink" title="静态命名空间"></a>静态命名空间</h2><p>我用<code>静态命名空间</code>作为那些命名空间标签实际上硬编码的解决方案的涵盖性术语。是的，你可以将一个命名空间重新分配给另一个，不过新的命名空间将会引用和旧的那一个同样的对象。</p>
<h3 id="1-通过直接分配"><a href="#1-通过直接分配" class="headerlink" title="1.通过直接分配"></a>1.通过直接分配</h3><p>最基础的方法。这样非常冗长，并且如果你还想重命名这些命名空间，你就有得活儿干了。不过它是安全和清楚明白的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;</span><br><span class="line">myApp.id = 0;</span><br><span class="line">myApp.next = function() &#123;</span><br><span class="line">    return myApp.id++;  </span><br><span class="line">&#125;</span><br><span class="line">myApp.reset = function() &#123;</span><br><span class="line">    myApp.id = 0;   </span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>你也可以通过使用<code>this</code>引用兄弟属性来使将来的维护更轻松一些，不过这有一点冒险因为没有什么能阻止你的那些命名空间里的方法被重新分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;</span><br><span class="line">myApp.id = 0;</span><br><span class="line">myApp.next = function() &#123;</span><br><span class="line">    return this.id++;   </span><br><span class="line">&#125;</span><br><span class="line">myApp.reset = function() &#123;</span><br><span class="line">    this.id = 0;    </span><br><span class="line">&#125;</span><br><span class="line">myApp.next(); //0</span><br><span class="line">myApp.next(); //1</span><br><span class="line">var getNextId = myApp.next;</span><br><span class="line">getNextId(); //NaN whoops!</span><br></pre></td></tr></table></figure>
<h3 id="2-使用对象字面量"><a href="#2-使用对象字面量" class="headerlink" title="2.使用对象字面量"></a>2.使用对象字面量</h3><p>现在我们只需要引用命名空间名一次，因此之后改变名字更简单了一些（假设你还没反复引用这个命名空间）。仍有一个危险是<code>this</code>的值可能会抛出一个『惊喜』 - 不过假设在一个对象字面结构里定义的对象不会被重新分配相对安全一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;</span><br><span class="line">    id: 0,</span><br><span class="line">    next: function() &#123;</span><br><span class="line">        return this.id++;   </span><br><span class="line">    &#125;,</span><br><span class="line">    reset: function() &#123;</span><br><span class="line">        this.id = 0;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<h3 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h3><p>我发现自己最近用<code>模块模式</code>更多。逻辑被一个方法包装从全局域隔离开了（通常是自调用的），它返回一个代表这个模块公开接口的对象。通过立即调用这个方法并分配结果给一个命名空间变量，我们就锁住了这个命名变量中模块的 API。此外，任何没有包括在返回值中的变量将永远保持私有，只对引用他们的公开方法可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myApp = (function() &#123;</span><br><span class="line">    var id= 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return id++;    </span><br><span class="line">        &#125;,</span><br><span class="line">        reset: function() &#123;</span><br><span class="line">            id = 0;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;)();   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>如上对象字面量例子，命名空间名字可以轻易更换，不过还有额外优势：对象字面量是四班的 - 它全是关于属性分配，没有支持逻辑的空间。此外，所有属性必须被初始化，并且属性值无法轻易跨对象引用（因此，比如，内部闭包就不可能使用了）。模块模式没有任何上述约束，并且给我们额外的隐私福利。</p>
<h2 id="动态命名空间"><a href="#动态命名空间" class="headerlink" title="动态命名空间"></a>动态命名空间</h2><p>我们也可以将这一节称为<code>命名空间注入</code>。命名空间由一个直接引用方法包装<code>内部</code>的代理代表 - 这意味着我们不再需要打包分配给命名空间的返回值。这让命名空间定义变得更灵活并且让拥有多个存在于独立命名空间中（或者甚至在全局上下文中）的模块的独立实例。动态命名空间支持模块模式的全部特征并附加直观和可读性强的优势。</p>
<h3 id="4-提供命名空间参数"><a href="#4-提供命名空间参数" class="headerlink" title="4.提供命名空间参数"></a>4.提供命名空间参数</h3><p>在这里我们只是将命名空间作为参数传给自调用方法。变量<code>id</code>是私有的，因为他并没有被分配给<code>context</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id = 0;</span><br><span class="line">    context.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    context.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(myApp);  </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>我们甚至可以把<code>context</code>设置给全局对象（通过一个字的改变！）。这是库主们的巨大财富 - 他们可以将他们的特性包装在一个自调用函数中，然后让用户来决定它们是不是全局的（John Resig 在他写 JQuery 时就是一个这个理论的早期采用者）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id = 0;</span><br><span class="line">    context.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    context.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this);   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<h3 id="5-用this作为命名空间代理"><a href="#5-用this作为命名空间代理" class="headerlink" title="5.用this作为命名空间代理"></a>5.用<code>this</code>作为命名空间代理</h3><p><a href="http://www.brothercake.com/" target="_blank" rel="external">James Edwads</a> 最近发布的一篇文章激起了我的兴趣。<a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/" target="_blank" rel="external">《My Favorite JavaScript Design Patter》</a> 显然被很多评论者误解了，他们认为他可能也是借助于模块模式。这篇文章宣传了多种技术（可能导致了读者的迷惑），但是在它的核心部分是一点我已经修改并呈现为一个命名空间工具的很天才的东西。</p>
<p>这个模式的美就在于它仅仅是按照这个语言被设计的方式使用 - 不多不少、不投机也不取巧。此外因为命名空间是通过<code>this</code>关键字（它在给定的执行上下文中是不变的）注入的，它不可能被意外修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var id = 0;</span><br><span class="line"> </span><br><span class="line">    this.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).apply(myApp);    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>更棒的是，<code>apply</code>（以及<code>call</code>） API 提供了与上下文和参数天然的隔离 - 因此给模块创建者传递附加参数非常干净。下面的例子表明了这一点，并且展示了如何独立于多个命名空间来运行模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var subsys1 = &#123;&#125;, subsys2 = &#123;&#125;;</span><br><span class="line">var nextIdMod = function(startId) &#123;</span><br><span class="line">    var id = startId || 0;</span><br><span class="line">    this.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">nextIdMod.call(subsys1);    </span><br><span class="line">nextIdMod.call(subsys2,1000);   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.reset(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.next()</span><br><span class="line">) //0, 1, 1000, undefined, 1001, 0</span><br></pre></td></tr></table></figure>
<p>当然如果我们如果我们需要一个全局 id 生成器，非常简单……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nextIdMod();    </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>这个我们作为例子使用的 id 生成器工具并没有表现出这个模式的全部潜力。通过包裹一整个库和使用<code>this</code>关键字作为命名空间的替身，我们使得用户在任何他们选择的上下文中运行这个库很轻松（包括全局上下文）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//library code</span><br><span class="line">var protoQueryMooJo = function() &#123;  </span><br><span class="line">    //everything</span><br><span class="line">&#125;</span><br><span class="line">//user code</span><br><span class="line">var thirdParty = &#123;&#125;;</span><br><span class="line">protoQueryMooJo.apply(thirdParty);</span><br></pre></td></tr></table></figure>
<h2 id="其他的考虑"><a href="#其他的考虑" class="headerlink" title="其他的考虑"></a>其他的考虑</h2><p>我希望避免命名空间嵌套。它们很难追踪（对人和电脑都是）并且它们会让你的代码因为一些乱七八糟的东西变得很多。如 <a href="http://michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">Peter Michaux</a> 指出的，深度嵌套的命名空间可能是那些视图重新创建他们熟悉和热爱的长包链的老派 Java 开发者的遗产。</p>
<p>通过 .js 文件来固定一个单独的命名空间也是可以的（虽然只能通过命名空间注入或者直接分配每一个变量），不过你应该对依赖谨慎些。此外将命名空间绑定到文件上可以帮助读者更轻易弄清整个代码。</p>
<p>因为 JavaScript 并没有正式的命名空间结构，所以有很多自然形成的方法。这个调查只详细说明了其中的一部分，可能有更好的技术我没有发现。我很乐意知道它们。</p>
<h2 id="更多文章"><a href="#更多文章" class="headerlink" title="更多文章"></a>更多文章</h2><p>James Edwards： <a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/" target="_blank" rel="external">My Favorite JavaScript Design Pattern</a><br>Peter Michaux: <a href="http://michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">JavaScript Namespacing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/&quot;&gt;Namespacing in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-中的命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-中的命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的命名空间&quot;&gt;&lt;/a&gt;JavaScript 中的命名空间&lt;/h1&gt;&lt;p&gt;全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。&lt;/p&gt;
&lt;p&gt;不过，恩，这些你早都知道了……&lt;/p&gt;
&lt;p&gt;所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 &lt;a href=&quot;http://www.brothercake.com/&quot;&gt;James Edwards&lt;/a&gt; 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://chengkang.me/tags/Namespacing/"/>
    
      <category term="Namespace" scheme="http://chengkang.me/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>【译】Swift2 中的错误处理：try，catch，do 以及 throw</title>
    <link href="http://chengkang.me/2016/05/15/Swift2%20%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9Atry%EF%BC%8Ccatch%EF%BC%8Cdo%20%E4%BB%A5%E5%8F%8A%20throw/"/>
    <id>http://chengkang.me/2016/05/15/Swift2 中的错误处理：try，catch，do 以及 throw/</id>
    <published>2016-05-15T22:14:40.000Z</published>
    <updated>2016-05-15T15:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch" target="_blank" rel="external">《Error handling in Swift 2: try, catch, do and throw》</a></p>
</blockquote>
<p>如果你已经看了我那篇讨论 Swift2 中所有新东西的文章并且想了解更多关于新的错误处理系统的东西，这篇文章非常合适。简单来说，它已经被完全重写得现代化，快速和安全，并且除非你只使用 iOS API 的一小部分的话，你需要花些时间来学习一下。</p>
<p>如果你喜欢这篇文章，你可能也会想读读这些：</p>
<ul>
<li><a href="https://www.hackingwithswift.com/swift2-2" target="_blank" rel="external">What’s new in Swift 2.2?</a></li>
<li><a href="https://www.hackingwithswift.com/ios9" target="_blank" rel="external">What’s new in iOS 9?</a></li>
<li><a href="https://www.hackingwithswift.com/" target="_blank" rel="external">My free Swift tutorial series</a></li>
<li><a href="https://gum.co/proswift" target="_blank" rel="external">Pre-order Pro Swift for just $20!</a></li>
</ul>
<h3 id="过去是怎样：NSError-和-NSErrorPointer"><a href="#过去是怎样：NSError-和-NSErrorPointer" class="headerlink" title="过去是怎样：NSError 和 NSErrorPointer"></a>过去是怎样：NSError 和 NSErrorPointer</h3><p>用于处理错误的历史方法是通过使用一个作为指针传递的 NSError 对象。在 Objective-C 中，它是 NSError*，但在 Swift 中你会看到 NSError？ 和 NSErrorPointer。</p>
<a id="more"></a>
<p>当你调用一个可能失败的方法，你要传递一个空 NSError 作为参数，如果有问题的话这个参数就会被赋值。这让方法的返回值是你真正关心的那个数据。例如，在 Swift1.2 中，从硬盘加载一个 NSString 看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var err: NSError?</span><br><span class="line">let contents = NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding, error: &amp;err)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // uh-oh!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种编程风格在 Cocoa 中非常广泛，或者说至少：Swift2 完全不这么干，所以上面的代码要么要重写要么就移除掉。</p>
<p>至于为什么，有很多原因。例如，用上面的调用方法，很容易就忽略了错误，要么是没有检查 err 的值，要么是根本就没用 NSError 而是直接传递了一个 nil。</p>
<p>虽然 Swift2 中的新错误处理需要多费点功夫，但是它让程序员阅读起来清楚明白得多，它抛弃了那些复杂的东西例如用 &amp; 来传递 NSError，并且它通过保证你捕获所有错误来给你更高的安全性。</p>
<h3 id="Swift2-中的方法：try，catch，do-以及-throw"><a href="#Swift2-中的方法：try，catch，do-以及-throw" class="headerlink" title="Swift2 中的方法：try，catch，do 以及 throw"></a>Swift2 中的方法：try，catch，do 以及 throw</h3><p>当你导入一个 Swift1.2 项目到 Xcode7 时，你会被问道是否想要将它转换成最新的 Swift 语法。它并不能生成和你手写的一模一样的代码，但是它能帮你解决很大一部分工作，这样你就差不多确定要去使用它了。</p>
<p>在上面那个从文件中加载字符串的例子中，它会将其转化为 Swift2 版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let contents: NSString?</span><br><span class="line">do &#123;</span><br><span class="line">    contents = try NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding)</span><br><span class="line">&#125; catch _ &#123;</span><br><span class="line">    contents = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里展示了五个你需要学习的新关键字其中三个。当然，严格来说有一个不新，不过它的用法是新的：do 之前使用在 do … while 循环中，不过为了避免混淆，在 Swift2 中，它已经被重命名为 repeat … while。</p>
<p>第四和第五个关键字是 throw 和 throws，我们现在来更深入地看看。</p>
<p>请创建一个新的 Xcode 项目，用单视图应用模板。随便命个名，随便选个目标设备 - 都没关系，因为我们这次不做任何跟视图有关的东西。</p>
<p>选择 ViewController.swift 并且添加这个新方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func encryptString(str: String, withPassword password: String) -&gt; String &#123;</span><br><span class="line">    // complicated encryption goes here</span><br><span class="line">    let encrypted = password + str + password</span><br><span class="line">    return String(encrypted.characters.reverse())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法会用传递进来的密码加密一个字符串。当然，它不会自动就这样做 - 这篇文章不是关于加密的，所以我的『加密』算法很悲剧：它将密码添加在输入的字符串前后，然后翻转这个字符串。你之后可以随意加上复杂的加密算法。</p>
<p>修改 viewDidLoad() 来调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let encrypted = encryptString(&quot;secret information!&quot;, withPassword: &quot;12345&quot;)</span><br><span class="line">print(encrypted)</span><br></pre></td></tr></table></figure></p>
<p>你现在运行你的应用，你将看到在 Xcode 终端上打印出了『54321！noitamrofni terces54321』。很简单对吧。</p>
<p>但是有一个问题：假设你实际上设定了一个有意义的加密算法，你没办法阻止用户输入一个空字符串作为密码，或者输入明显的密码类似『password』，或者甚至尝试在没有任何可加密数据的情况下调用加密算法。</p>
<p>Swift2 来帮忙了：你可以告诉 Swift 当这个方法发现它自己处于一个不可接受的状态时，它可以抛出一个错误，例如如果密码是六位或者更少位。这些错误是由你定义的，然后 Swift 用某种办法来保证你捕获所有的错误。</p>
<p>首先，我们需要关键字 throws，你需要在定义你的方法时把它加在返回值前面，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func encryptString(str: String, withPassword password: String) throws -&gt; String &#123;</span><br><span class="line">    // complicated encryption goes here</span><br><span class="line">    let encrypted = password + str + password</span><br><span class="line">    return String(encrypted.characters.reverse())</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">一旦你这样做了，你的代码就会停止工作：添加 throws 命名让情况更糟了！不过它变糟了是因为一个好原因：Swift 中的 try/catch 系统被设计为对开发者清晰明了，这意味着你需要用关键字 try 标记所有可以抛出错误的方法，就像这样：</span><br></pre></td></tr></table></figure></p>
<p>let encrypted = try encryptString(“secret information!”, withPassword: “12345”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">…不过即使现在你的代码还是不能编译成功，因为你还没有告诉 Swift 当错误被抛出时要做什么。这就是关键字 do 和 catch 派上用场的地方：它们开始了一段可能运行失败的代码，并且处理那些失败。在我们的简单例子里，它可能看起来是这样：</span><br></pre></td></tr></table></figure></p>
<p>do {<br>    let encrypted = try encryptString(“secret information!”, withPassword: “12345”)<br>    print(encrypted)<br>} catch {<br>    print(“Something went wrong!”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样所有的错误都没了，你的代码又可以运行了。不过目前为止它实际上还没有做任何有意思的事情，因为即使我们说 encryptString() 可能抛出一个错误，它从没有真正发生。</span><br><span class="line"></span><br><span class="line">### 如何在 Swift2 中抛出错误</span><br><span class="line"></span><br><span class="line">在你可以抛出一个错误之前，你需要制作一个你要抛出的可能错误的列表。在我们这个例子中，我们要组织人们提供空密码，短密码和明显密码，不过之后你可以扩展它。</span><br><span class="line"></span><br><span class="line">要做到这些，我们需要创建一个枚举类型变量来代表我们错误的类型。这需要建立在内建的 ErrorType 枚举类型上，不过不管怎样都很简单。把这个加载 ViewController 类的前面：</span><br></pre></td></tr></table></figure></p>
<p>enum EncryptionError: ErrorType {<br>    case Empty<br>    case Short<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它定义了两个错误类型，然后我们可以马上开始用它们。因为它们是运行这个方法的前提条件，我们要用这个新关键字 guard 来使我们的意图清晰。</span><br><span class="line"></span><br><span class="line">把这个放在 encryptString() 前面：</span><br></pre></td></tr></table></figure></p>
<p>guard password.characters.count &gt; 0 else { throw EncryptionError.Empty }<br>guard password.characters.count &gt;= 5 else { throw EncryptionError.Short }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你现在运行应用，没有什么变化，因为我们在提供『12345』这个密码。不过如果你把它设置为一个空字符串，你会看到『Something went wrong！』在 Xcode 控制台打印出来了。</span><br><span class="line"></span><br><span class="line">当然，有一个错误信息帮助不是很大 - 因为这个方法调用时有多种方式失败，并且我们希望给每一种情况提供一些有意义的信息。所以，把 viewDidLoad() 中的 try/catch 代码块改成这样：</span><br></pre></td></tr></table></figure></p>
<p>do {<br>    let encrypted = try encryptString(“secret information!”, withPassword: “”)<br>    print(encrypted)<br>} catch EncryptionError.Empty {<br>    print(“You must provide a password.”)<br>} catch EncryptionError.Short {<br>    print(“Passwords must be at least five characters, preferably eight or more.”)<br>} catch {<br>    print(“Something went wrong!”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">现在有了有意义的错误信息，我们的代码开始看起来更棒了。不过你可能注意到了，虽然我们已经捕获到了 .Empty 和 .Short 的情况，我们还需要第三个 catch 代码块。</span><br><span class="line"></span><br><span class="line">### Swift2 要求详尽无遗的 try/catch 错误处理</span><br><span class="line"></span><br><span class="line">如果你还记得的话，我说过『Swift 通过一些方式来保证你捕获到所有错误』，这里我们来说明清楚：我们已经能捕获所有我们定义的错误，但是 Swift 还希望我们定义一个一般的 catch all 来处理任何其他可能出现的错误。我们不用告诉 Swift 到底加密算法可能抛出哪种错误，只需要说明它会抛出某些错误，因此这个额外的 catch-all 代码块是必须的。</span><br><span class="line"></span><br><span class="line">有一个不好的地方：如果你新增任何值给枚举类型，它会直接进到默认的 catch 代码块 - 你不会被要求为它提供任何代码。</span><br><span class="line"></span><br><span class="line">我们将要给枚举类型加一个新的值来检测明显的密码。不过我们将要用 Swift 超强枚举类型这样我们可以返回一个带着错误类型的信息。因此，将 EncryptionError 枚举类型修改成这样：</span><br></pre></td></tr></table></figure></p>
<p>enum EncryptionError: ErrorType {<br>    case Empty<br>    case Short<br>    case Obvious(String)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在当你想要抛出一个 EncrytionError.Obvious 类型的错误是，你必须提供一个理由。</span><br></pre></td></tr></table></figure></p>
<p>guard password != “12345” else { throw EncryptionError.Obvious(“I’ve got the same passcode on my luggage!”) }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">显然你不想写无数个 guard 声明来过滤出明显的密码，不过如果你记得如何使用 UITextChecker 来做拼写检查的话，就很方便了。</span><br><span class="line"></span><br><span class="line">这就是完整的 Swift 基本 do/try/throw/catch 例子。你可能觉得 try 声明没什么用，不过他是作为一个信号告诉开发者『这个调用可能失败』。这很重要：当一个 try 调用失败了，执行立刻跳转到 catch 代码块，因此如果你看到一个调用之前的 try，它标志着底下的代码可能不会被执行。</span><br><span class="line"></span><br><span class="line">还有一个要说的事情就是，如果你知道一个调用就是不会失败你该怎么做。现在，很显然这是一个你需要根据情况来做的决定，不过如果你知道有一个方法绝对不可能调用失败或者如果它调用失败的你的代码就会完全崩溃，你可以使用 try! 来告诉 Swift。</span><br><span class="line"></span><br><span class="line">当你使用关键字 try!，你不需要用 do/catch 来包裹你的代码，因为你在保证它永远不会失败。你只需要这样写：</span><br></pre></td></tr></table></figure></p>
<p>let encrypted = try! encryptString(“secret information!”, withPassword: “12345”)<br>print(encrypted)<br>```<br>使用关键字 try! 清楚地表达了你的意图：你知道理论上这个调用可能失败，但是你确定它在你的用例中不会失败。例如，如果你从你的应用包中的文件中加载内容，任何失败意味着你的应用包被损坏了或者不可用，所以你需要终止应用。</p>
<p>这就是所有关于 Swift2 中错误处理的东西。如果你想学习 Swift 是怎样处理 try/finally，你应该读读我这篇<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer" target="_blank" rel="external">关于关键词 defer 的文章</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch&quot;&gt;《Error handling in Swift 2: try, catch, do and throw》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你已经看了我那篇讨论 Swift2 中所有新东西的文章并且想了解更多关于新的错误处理系统的东西，这篇文章非常合适。简单来说，它已经被完全重写得现代化，快速和安全，并且除非你只使用 iOS API 的一小部分的话，你需要花些时间来学习一下。&lt;/p&gt;
&lt;p&gt;如果你喜欢这篇文章，你可能也会想读读这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/swift2-2&quot;&gt;What’s new in Swift 2.2?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/ios9&quot;&gt;What’s new in iOS 9?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/&quot;&gt;My free Swift tutorial series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gum.co/proswift&quot;&gt;Pre-order Pro Swift for just $20!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;过去是怎样：NSError-和-NSErrorPointer&quot;&gt;&lt;a href=&quot;#过去是怎样：NSError-和-NSErrorPointer&quot; class=&quot;headerlink&quot; title=&quot;过去是怎样：NSError 和 NSErrorPointer&quot;&gt;&lt;/a&gt;过去是怎样：NSError 和 NSErrorPointer&lt;/h3&gt;&lt;p&gt;用于处理错误的历史方法是通过使用一个作为指针传递的 NSError 对象。在 Objective-C 中，它是 NSError*，但在 Swift 中你会看到 NSError？ 和 NSErrorPointer。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="error" scheme="http://chengkang.me/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView 总结</title>
    <link href="http://chengkang.me/2016/04/13/UICollectionView%20%E6%80%BB%E7%BB%93/"/>
    <id>http://chengkang.me/2016/04/13/UICollectionView 总结/</id>
    <published>2016-04-13T06:13:54.000Z</published>
    <updated>2016-04-13T06:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目源码：<a href="https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen" target="_blank" rel="external">模拟凤凰新闻 Github 仓库</a></p>
</blockquote>
<h3 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h3><p>昨天给自己布置这个作业之后，看完文档实践的过程中发现一片很棒的英文总结，于是翻译了一下。这篇总结会简单总结一下我翻译的那篇文章里的内容，以及基于模拟凤凰新闻客户端部分页面的一些 UICollectionView 使用总结。</p>
<p>文章主要是总结一些需要注意的内容，具体请看源码。实现的内容及对应文件包括：</p>
<ul>
<li>同一个 section 内拖动 cell<ul>
<li>直接使用 UICollectionViewController（<code>TestCollectionViewController.swift</code>）</li>
<li>在 UIViewController 中使用 UICollectionView（<code>EditTabsViewController.swift</code>）</li>
</ul>
</li>
<li>不同 section 间拖动 cell（<code>Test.swift</code>）</li>
<li>不同 section 间点击移动 cell（<code>TabsViewController.swift</code>）</li>
<li>点击移除 cell（<code>EditTabsViewController.swift</code>）</li>
</ul>
<p>主要内容如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-2.gif" alt=""></p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-3.gif" alt=""></p>
<a id="more"></a>
<h3 id="《【译】UICollectionView-轻松重排》"><a href="#《【译】UICollectionView-轻松重排》" class="headerlink" title="《【译】UICollectionView 轻松重排》"></a>《【译】UICollectionView 轻松重排》</h3><p>这篇文章主要介绍了在 iOS9 之后 UICollectionView 自带的重新排列方法。</p>
<ol>
<li>如果直接使用 UICollectionViewController，通过重写<code>func collectionView(collectionView: UICollectionView,
 moveItemAtIndexPath sourceIndexPath: NSIndexPath,
 toIndexPath destinationIndexPath: NSIndexPath)</code>即可以实现拖动重排。</li>
<li>如果是在 UIViewController 里面使用 UICollectionView，则需要自己添加一个 UILongPressGestureRecognizer，对应状态进行对应处理。</li>
</ol>
<p>比较重要的几个方法是：</p>
<ul>
<li>func collectionView(collectionView: UICollectionView,<br>  moveItemAtIndexPath sourceIndexPath: NSIndexPath,<br>  toIndexPath destinationIndexPath: NSIndexPath)</li>
<li>indexPathForItemAtPoint</li>
<li>beginInteractiveMovementForItemAtIndexPath</li>
<li>updateInteractiveMovementTargetPosition</li>
<li>endInteractiveMovement</li>
<li>cancelInteractiveMovement</li>
</ul>
<p><strong>特别注意</strong></p>
<p>这个方法<code>func collectionView(collectionView: UICollectionView,
    moveItemAtIndexPath sourceIndexPath: NSIndexPath,
    toIndexPath destinationIndexPath: NSIndexPath)</code>,</p>
<ul>
<li>重写这个方法之后，自带的拖动重排才能生效。</li>
<li>这个方法究竟有什么作用？这个方法是在 cell 位置变换之后触发的。它包含两个很有用的参数，被拖动的 cell 的初始 indexPath 和落点 indexPath。因为这个位置的变换只是视图的改变，这些 cell 背后的数据的 index 其实并没有受到影响。因此如果此时 reloadData() 会发现，格子位置又恢复了，但这不是我们想要的，在实际项目中我们希望移动后就一直保持那个位置，也就是说数据的 index 发生相应改变。这个方法就是方便我们处理数据的。具体请看之后内容中的例子。</li>
<li>另外这个方法只与通过交互移动 cell 事件有关。如果是直接调用移动 cell 的方法并不会触发这个方法。所以在类似凤凰新闻编辑订阅频道页面，”点击下面 section 中的频道，移动到上面的 section 中”，实现时需要在 didSelect 方法中添加对应修改数据源的代码。具体参看源码中<code>TabsViewController.swift</code>。</li>
</ul>
<h3 id="使用-UICollectionView-必做的事情"><a href="#使用-UICollectionView-必做的事情" class="headerlink" title="使用 UICollectionView 必做的事情"></a>使用 UICollectionView 必做的事情</h3><p>首先你的 UIViewController 要继承 UICollectionViewDataSource，UICollectionViewDelegate，UICollectionViewDelegateFlowLayout。</p>
<p>其次，记得绑定 delegate 和 datasource。</p>
<p>然后是：</p>
<ul>
<li>func numberOfSectionsInCollectionView(collectionView: UICollectionView) -&gt; Int</li>
<li>collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int</li>
<li>collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell</li>
</ul>
<p>有需要的话用上：</p>
<ul>
<li>func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&gt; CGSize</li>
<li>func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -&gt; UICollectionReusableView </li>
</ul>
<p><strong>特别注意</strong></p>
<p>当你在 storyboard 设置了使用 header 或者 footer 或者两者都用的时候，记得添加对应的内容在 viewForSupplementaryElementOfKind 里面。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -&gt; UICollectionReusableView &#123;</span><br><span class="line">    </span><br><span class="line">    if kind == UICollectionElementKindSectionHeader &#123;</span><br><span class="line">        let header = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: &quot;TabSectionHeader&quot;, forIndexPath: indexPath) as! TabSectionHeader</span><br><span class="line">        return header</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let footer = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: &quot;TabSectionFooter&quot;, forIndexPath: indexPath)</span><br><span class="line">        return footer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>个人对这个方法的设计持怀疑态度，觉得像 UITableView 那样分离开会更好。（又或许是我理解不够深刻吧。）</p>
<p>记得设置 reuseIdentifier。</p>
<h3 id="插入、移动、删除-cell-以及-cell-总数的问题"><a href="#插入、移动、删除-cell-以及-cell-总数的问题" class="headerlink" title="插入、移动、删除 cell 以及 cell 总数的问题"></a>插入、移动、删除 cell 以及 cell 总数的问题</h3><p>UICollectionView 是在生成 cell 的时候，先通过 numberOfItemsInSection 获得 cell 数量，然后一个一个生成添加在视图中。</p>
<p>你可通过这些方法来插入、移动、删除 cell：</p>
<ul>
<li>insertItemAtIndexPaths</li>
<li>moveItemAtIndexPath</li>
<li>deleteItemsAtIndexPaths</li>
</ul>
<p>比如，当来自服务器的数据更新了，新增或者减少了一个数据，我们可以想到有两种情况：</p>
<ol>
<li>通过 reloadData() 将整个 UICollectionView 更新。</li>
<li>只在对应的位置插入或删除对应的那一个 cell。</li>
</ol>
<p>用第一种方法是没有任何问题的。问题在第二种方法。</p>
<p>当我们直接通过 insertItemAtIndexPaths 或者 deleteItemsAtIndexPaths 添加或删除 cell 时，UICollectionView 中的 cell 数量发生变化了。貌似没问题？如果你尝试滑动一下屏幕，你会发现程序崩溃了。你会看到类似下面的报错：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-13%20at%206.20.09%20AM.png" alt=""></p>
<p>原因在于，当 UICollectionView 进行任何的更新时，包括局部更新，都会检查 numberOfItemInSection 方法返回的值和当前 UICollectionView 中实际包含的 cell 数量。如果二者不一致就会报错。</p>
<p><strong>特别注意</strong></p>
<p>UICollectionView 中实际包含的 cell 数量在下一次更新前 collection view 视图前一定要和 numberOfItemInSection 的返回值一直。</p>
<p>所以我们在新增或者删除 cell 之后，记得要修改对应的数据源。（当然在实际项目中应该不会忘记。）</p>
<p><strong>插入、移动、删除 section 类似</strong></p>
<h3 id="不同-section-间拖动-cell"><a href="#不同-section-间拖动-cell" class="headerlink" title="不同 section 间拖动 cell"></a>不同 section 间拖动 cell</h3><p>项目中的 Test.swift 是关于不同 section 间拖动 cell 的例子。</p>
<p>基本原理和在一个 section 内拖动 cell 一样，都是调用那几个方法。</p>
<p><strong>第一点</strong></p>
<p>需要注意的还是上面提到的记得修改对应数据源，否则第二次拖动就会报错。因为此时两个 section 内 cell 数量和 numberOfItemInSection 返回值不一样了。</p>
<p><strong>第二点</strong></p>
<p>请看一下两个实现方法：</p>
<p>一，『原始』方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func longPressGestureRecognizerAction(sender: UILongPressGestureRecognizer) &#123;</span><br><span class="line">    switch sender.state &#123;</span><br><span class="line">    case .Began:</span><br><span class="line">        let location = sender.locationInView(self.collectionView)</span><br><span class="line">        let indexPath = self.collectionView.indexPathForItemAtPoint(location)</span><br><span class="line">        self.originalSectionIndex = (indexPath?.section)!</span><br><span class="line">        self.interactiveItem = self.collectionView.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">        self.collectionView.beginInteractiveMovementForItemAtIndexPath(indexPath!)</span><br><span class="line">        break</span><br><span class="line">    case .Changed:</span><br><span class="line">        let location = sender.locationInView(self.collectionView)</span><br><span class="line">        print(location)</span><br><span class="line">        let indexPath = self.collectionView.indexPathForItemAtPoint(location)</span><br><span class="line">        print(indexPath)</span><br><span class="line">        self.collectionView.updateInteractiveMovementTargetPosition(location)</span><br><span class="line">    case .Ended:</span><br><span class="line">        self.collectionView.endInteractiveMovement()</span><br><span class="line">        let currentSectionIndex = (self.collectionView.indexPathForCell(self.interactiveItem)?.section)!</span><br><span class="line">        self.sections[currentSectionIndex]++</span><br><span class="line">        self.sections[self.originalSectionIndex]--</span><br><span class="line">    default:</span><br><span class="line">        self.collectionView.cancelInteractiveMovement()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二，借助自带方法的简便方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func collectionView(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) &#123;</span><br><span class="line">    self.sections[destinationIndexPath.section]++</span><br><span class="line">    self.sections[sourceIndexPath.section]--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func longPressGestureRecognizerAction(sender: UILongPressGestureRecognizer) &#123;</span><br><span class="line">    switch sender.state &#123;</span><br><span class="line">    case .Began:</span><br><span class="line">        guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(sender.locationInView(self.collectionView)) else &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        self.collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)</span><br><span class="line">        break</span><br><span class="line">    case .Changed:</span><br><span class="line">        self.collectionView.updateInteractiveMovementTargetPosition(sender.locationInView(self.collectionView))</span><br><span class="line">        break</span><br><span class="line">    case .Ended:</span><br><span class="line">        self.collectionView.endInteractiveMovement()</span><br><span class="line">    default:</span><br><span class="line">        self.collectionView.cancelInteractiveMovement()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个方法定义了两个全局变量<code>var originalSectionIndex = 0</code>和<code>var interactiveItem:UICollectionViewCell!</code>来记录初始位置和正在进行移动的 cell。</p>
<p>而第二个方法，通过使用<code>func collectionView(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath)</code>，直接就可以使用开始和结束位置 indexPath。非常方便。</p>
<p>所以当然一定要用第二种方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot;&gt;模拟凤凰新闻 Github 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;昨天给自己布置这个作业之后，看完文档实践的过程中发现一片很棒的英文总结，于是翻译了一下。这篇总结会简单总结一下我翻译的那篇文章里的内容，以及基于模拟凤凰新闻客户端部分页面的一些 UICollectionView 使用总结。&lt;/p&gt;
&lt;p&gt;文章主要是总结一些需要注意的内容，具体请看源码。实现的内容及对应文件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个 section 内拖动 cell&lt;ul&gt;
&lt;li&gt;直接使用 UICollectionViewController（&lt;code&gt;TestCollectionViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在 UIViewController 中使用 UICollectionView（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同 section 间拖动 cell（&lt;code&gt;Test.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;不同 section 间点击移动 cell（&lt;code&gt;TabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;点击移除 cell（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要内容如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://chengkang.me/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>【译】UICollectionView 轻松重排</title>
    <link href="http://chengkang.me/2016/04/12/%E3%80%90%E8%AF%91%E3%80%91UICollectionView%20%E8%BD%BB%E6%9D%BE%E9%87%8D%E6%8E%92/"/>
    <id>http://chengkang.me/2016/04/12/【译】UICollectionView 轻松重排/</id>
    <published>2016-04-12T22:38:28.000Z</published>
    <updated>2016-04-12T22:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/" target="_blank" rel="external">UICollectionViews Now Have Easy Reordering</a></p>
<p>原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。</p>
</blockquote>
<p>我超喜欢<code>UICollectionView</code>。相比<code>UITableView</code>，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 <a href="https://github.com/nshintio/uicollectionview-reordering" target="_blank" rel="external">Github</a> 上找到对应的 Xcode 项目。</p>
<p>最简单的实现重排是通过使用<code>UICollectionViewController</code>。它现在有一个新的属性叫做<code>installsStandardGestureForInteractiveMovement</code>，作用是添加手势（gestures）来重排 cells。这个属性默认值为<code>True</code>，这意味着要使用它我们只需要重写一个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func collectionView(collectionView: UICollectionView,</span><br><span class="line">    moveItemAtIndexPath sourceIndexPath: NSIndexPath,</span><br><span class="line">    toIndexPath destinationIndexPath: NSIndexPath) &#123;</span><br><span class="line">    // move your data order</span><br><span class="line">    // 可以留空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前的 collection view 判定 items 可以被移动，因为<code>moveItemAtIndexPath</code>被重写了。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/1.gif" alt=""></p>
<a id="more"></a>
<p>当我们希望在一个简单的<code>UIViewController</code>中使用 collection view 时，会麻烦一点。我们也要实现之前提到的<code>UICollectionViewDataSource</code>方法，不过我们需要重写<code>installsStandardGestureForInteractiveMovement</code>。不用担心，也很简单。<code>UILongPressGestureRecognizer</code>是一种持续性的手势识别器并且完全支持拖动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">            longPressGesture = UILongPressGestureRecognizer(target: self, action: &quot;handleLongGesture:&quot;)</span><br><span class="line">        self.collectionView.addGestureRecognizer(longPressGesture)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    func handleLongGesture(gesture: UILongPressGestureRecognizer) &#123;</span><br><span class="line"></span><br><span class="line">        switch(gesture.state) &#123;</span><br><span class="line"></span><br><span class="line">        case UIGestureRecognizerState.Began:</span><br><span class="line">            guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(gesture.locationInView(self.collectionView)) else &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)</span><br><span class="line">        case UIGestureRecognizerState.Changed:</span><br><span class="line">            collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view!))</span><br><span class="line">        case UIGestureRecognizerState.Ended:</span><br><span class="line">            collectionView.endInteractiveMovement()</span><br><span class="line">        default:</span><br><span class="line">            collectionView.cancelInteractiveMovement()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们保存了在 long press gesture 中不活的被选中的 index path 并且基于它是否有值决定允不允许拖动手势生效。然后，我们根据手势状态调用一些新的 collection view 方法。</p>
<ul>
<li><code>beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)</code>：开始指定位置 cell 的交互移动。</li>
<li><code>updateInteractiveMovementTargetPosition(targetPosition: CGPoint)</code>：更新交互移动对象的位置</li>
<li><code>endInteractiveMovement()</code>：在你结束拖动手势之后结束交互移动</li>
<li><code>cancelInteractiveMovement()</code>：取消交互移动</li>
</ul>
<p>这些让搞定拖动手势非常容易。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/2.gif" alt=""></p>
<p>效果和标准的<code>UICollectionViewController</code>一样。很酷对吧，不过更酷的是我们可以将我们自定义的 collection view layout 应用到重排中去。看看下面在简单的瀑布视图中的交互移动。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/3.gif" alt=""></p>
<p>嗯，看起来不错，不过如果我们不想在移动的时候改变 cell 大小呢？选中的 cell 大小应该在交互移动时保持一致。这是可以实现的。<code>UICollectionViewLayout</code>也有一些其他的方法来负责重排。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],</span><br><span class="line">    withTargetPosition targetPosition: CGPoint,</span><br><span class="line">    previousIndexPaths: [NSIndexPath],</span><br><span class="line">    previousPosition: CGPoint) -&gt; UICollectionViewLayoutInvalidationContext</span><br><span class="line"></span><br><span class="line">func invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths(indexPaths: [NSIndexPath],</span><br><span class="line">    previousIndexPaths: [NSIndexPath],</span><br><span class="line">    movementCancelled: Bool) -&gt; UICollectionViewLayoutInvalidationContext</span><br></pre></td></tr></table></figure></p>
<p>前一个在目标 indexPath 和之前的 indexPath 之间进行移动时调用。另一个类似，不过是在移动结束之后调用。有了这些我们就可以通过一些小手段达到我们的要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal override func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],</span><br><span class="line">    withTargetPosition targetPosition: CGPoint,</span><br><span class="line">    previousIndexPaths: [NSIndexPath],</span><br><span class="line">    previousPosition: CGPoint) -&gt; UICollectionViewLayoutInvalidationContext &#123;</span><br><span class="line"></span><br><span class="line">    var context = super.invalidationContextForInteractivelyMovingItems(targetIndexPaths,</span><br><span class="line">        withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,</span><br><span class="line">        previousPosition: previousPosition)</span><br><span class="line"></span><br><span class="line">    self.delegate?.collectionView!(self.collectionView!, moveItemAtIndexPath: previousIndexPaths[0],</span><br><span class="line">        toIndexPath: targetIndexPaths[0])</span><br><span class="line"></span><br><span class="line">    return context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方案非常清晰。获取正在移动的 cell 之前和目标 index path。然后调用<code>UICollectionViewDataSource</code>来移动这些 item。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/4.gif" alt=""></p>
<p>不用怀疑，collection view 重排是一个非常棒的更新。UIKit 工程师干得太棒了！：）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/&quot;&gt;UICollectionViews Now Have Easy Reordering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我超喜欢&lt;code&gt;UICollectionView&lt;/code&gt;。相比&lt;code&gt;UITableView&lt;/code&gt;，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 &lt;a href=&quot;https://github.com/nshintio/uicollectionview-reordering&quot;&gt;Github&lt;/a&gt; 上找到对应的 Xcode 项目。&lt;/p&gt;
&lt;p&gt;最简单的实现重排是通过使用&lt;code&gt;UICollectionViewController&lt;/code&gt;。它现在有一个新的属性叫做&lt;code&gt;installsStandardGestureForInteractiveMovement&lt;/code&gt;，作用是添加手势（gestures）来重排 cells。这个属性默认值为&lt;code&gt;True&lt;/code&gt;，这意味着要使用它我们只需要重写一个方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func collectionView(collectionView: UICollectionView,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    moveItemAtIndexPath sourceIndexPath: NSIndexPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toIndexPath destinationIndexPath: NSIndexPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // move your data order&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 可以留空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当前的 collection view 判定 items 可以被移动，因为&lt;code&gt;moveItemAtIndexPath&lt;/code&gt;被重写了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://chengkang.me/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>模拟凤凰新闻 | 更复杂的标签动画 - Swift 实现多个 TableView 的侧滑与切换</title>
    <link href="http://chengkang.me/2016/04/08/%E6%A8%A1%E6%8B%9F%E5%87%A4%E5%87%B0%E6%96%B0%E9%97%BB%20%7C%20%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A0%87%E7%AD%BE%E5%8A%A8%E7%94%BB%20-%20Swift%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%20TableView%20%E7%9A%84%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%88%87%E6%8D%A2/"/>
    <id>http://chengkang.me/2016/04/08/模拟凤凰新闻 | 更复杂的标签动画 - Swift 实现多个 TableView 的侧滑与切换/</id>
    <published>2016-04-08T19:59:13.000Z</published>
    <updated>2016-04-08T20:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目源码：<a href="https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen" target="_blank" rel="external">github 仓库：模拟凤凰新闻首页</a></p>
<p>下午逛 SegmentFault 时看到有人问如何实现凤凰新闻 app 首页效果，正好这两天在学习如何实现多个 TableView 的侧滑与切换，索性自己尝试一下。</p>
</blockquote>
<h3 id="目标和成果"><a href="#目标和成果" class="headerlink" title="目标和成果"></a>目标和成果</h3><p>如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-1.gif" alt=""></p>
<p>简单列一下关键点：</p>
<ol>
<li>跟随滑动</li>
<li>点击事件<a id="more"></a>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>凤凰新闻 app 里面下划线是在下面的 ScrollView 滚动动画结束之后才开始侧滑的，所以需要监听滚动是否结束。<ul>
<li>我刚开始想用 scrollViewDidEndScrollingAnimation，结果并不行。这个方法具体使用场景我还没搞清楚。</li>
<li>应该使用 scrollViewDidEndDecelerating，当 ScrollView 停止减速的时候即动画结束的时候。</li>
</ul>
</li>
<li>刚开始忘记了点击事件，所以标签用的 UILabel，其实可以换成 UIButton。这样就能省去寻找位置那一步。不过感觉 UIButton 的样式调整也很麻烦。幸运的是 UILabel 默认样式（字体、字号）非常符合这个项目要求。</li>
<li>不要忘记设置每个 ScrollView 的 delegate；不要忘记在 delegate 方法中判断当前是哪个 ScrollView</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.swift</span><br><span class="line">//  FenghuangXinwen</span><br><span class="line">//</span><br><span class="line">//  Created by Ant on 4/8/16.</span><br><span class="line">//  Copyright © 2016 Ant. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController, UIScrollViewDelegate &#123;</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var tabScrollView: UIScrollView!</span><br><span class="line">    @IBOutlet weak var contentScrollView: UIScrollView!</span><br><span class="line">    </span><br><span class="line">    let tabLine = UIView() //tab 标签下划线</span><br><span class="line">    let TAB_LINE_HEIGHT = CGFloat(2) //tab 标签下划线高度</span><br><span class="line">    let tabTitles = [</span><br><span class="line">        &quot;头条&quot;,</span><br><span class="line">        &quot;推荐&quot;,</span><br><span class="line">        &quot;娱乐&quot;,</span><br><span class="line">        &quot;财经&quot;,</span><br><span class="line">        &quot;自媒体&quot;,</span><br><span class="line">        &quot;凤凰卫视&quot;,</span><br><span class="line">        &quot;科技&quot;,</span><br><span class="line">        &quot;良品&quot;,</span><br><span class="line">        &quot;美女&quot;,</span><br><span class="line">        &quot;军事&quot;,</span><br><span class="line">        &quot;体育&quot;,</span><br><span class="line">        &quot;历史&quot;,</span><br><span class="line">        &quot;汽车&quot;,</span><br><span class="line">        &quot;时尚&quot;,</span><br><span class="line">        &quot;房产&quot;,</span><br><span class="line">        &quot;FUN来了&quot;,</span><br><span class="line">        &quot;段子&quot;,</span><br><span class="line">        &quot;萌物&quot;,</span><br><span class="line">    ] //tab 标签标题</span><br><span class="line">    </span><br><span class="line">    var tabLbls: [UILabel] = [] //tab 标签对应的 UILabl</span><br><span class="line">    </span><br><span class="line">    //定义要用到的颜色及 RGB 值差，用于颜色变化</span><br><span class="line">    let TEXT_COLOR_NORMAL = UIColor(red: 115/255, green: 120/255, blue: 134/255, alpha: 1)</span><br><span class="line">    let TEXT_COLOR_ACTIVE = UIColor(red: 245/255, green: 67/255, blue: 66/255, alpha: 1)</span><br><span class="line">    let TEXT_COLOR_NORMAL_RED = CGFloat(115)</span><br><span class="line">    let TEXT_COLOR_NORMAL_GREEN = CGFloat(120)</span><br><span class="line">    let TEXT_COLOR_NORMAL_BLUE = CGFloat(134)</span><br><span class="line">    let TEXT_COLOR_ACTIVE_RED = CGFloat(245)</span><br><span class="line">    let TEXT_COLOR_ACTIVE_GREEN = CGFloat(67)</span><br><span class="line">    let TEXT_COLOR_ACTIVE_BLUE = CGFloat(66)</span><br><span class="line">    let TEXT_COLOR_RED_DIF = CGFloat(130)</span><br><span class="line">    let TEXT_COLOR_GREEN_DIF = CGFloat(-53)</span><br><span class="line">    let TEXT_COLOR_BLUE_DIF = CGFloat(-68)</span><br><span class="line">    let TAB_LINE_COLOR = UIColor(red: 245/255, green: 67/255, blue: 66/255, alpha: 1)</span><br><span class="line">    </span><br><span class="line">    let MARGIN = CGFloat(20) //tab 标签左右间距</span><br><span class="line">    </span><br><span class="line">    var currentTabIndex = 0 //当前 tab 标签 index</span><br><span class="line">    var currentTabX = CGFloat(20) //当前 tab 标签 x 坐标，方便定位</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        //设置 scrollView delegate</span><br><span class="line">        tabScrollView.delegate = self</span><br><span class="line">        contentScrollView.delegate = self</span><br><span class="line">        </span><br><span class="line">        //初始化视图内容</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func initView() &#123;</span><br><span class="line">        //定义一些常量方便使用</span><br><span class="line">        let TABSCROLLVIEW_HEIGHT = self.tabScrollView.frame.height //tabScrollview 高度</span><br><span class="line">        let LABEL_Y = TABSCROLLVIEW_HEIGHT / 2 - 5 // 每个 tab 标签的 y 坐标</span><br><span class="line">        </span><br><span class="line">        //生成 tab 标签，添加到 tabScrollview 并设置大小位置</span><br><span class="line">        for var i = 0; i &lt; self.tabTitles.count; i++ &#123;</span><br><span class="line">            let tabLbl = UILabel()</span><br><span class="line">            tabLbl.text = tabTitles[i]</span><br><span class="line">            tabLbl.textColor = self.TEXT_COLOR_NORMAL</span><br><span class="line">            tabLbl.sizeToFit()</span><br><span class="line">            tabLbls.append(tabLbl)</span><br><span class="line">            </span><br><span class="line">            self.tabScrollView.addSubview(tabLbl)</span><br><span class="line">            </span><br><span class="line">            if i &gt; 0 &#123;</span><br><span class="line">                tabLbl.center = CGPointMake( self.MARGIN + self.tabLbls[i-1].center.x + self.tabLbls[i-1].frame.width / 2 + tabLbl.frame.width / 2 , LABEL_Y)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tabLbl.center = CGPointMake( self.MARGIN + tabLbl.frame.width / 2, LABEL_Y)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //顺便生成并添加每个 tab 页面对应的 view。用于测试。</span><br><span class="line">            let tabContentView = UIView()</span><br><span class="line">            self.contentScrollView.addSubview(tabContentView)</span><br><span class="line">            tabContentView.backgroundColor = UIColor.whiteColor()</span><br><span class="line">            tabContentView.frame = CGRectMake(self.view.frame.width * CGFloat(i), 0, self.view.frame.width, self.contentScrollView.frame.height)</span><br><span class="line">            let labelInContent = UILabel()</span><br><span class="line">            labelInContent.text = tabTitles[i]</span><br><span class="line">            labelInContent.sizeToFit()</span><br><span class="line">            tabContentView.addSubview(labelInContent)</span><br><span class="line">            labelInContent.center = CGPointMake(tabContentView.frame.width / 2, tabContentView.frame.height / 2 - 100)</span><br><span class="line">        &#125;</span><br><span class="line">        self.contentScrollView.contentSize = CGSizeMake(self.view.frame.width * CGFloat(self.tabLbls.count), self.contentScrollView.frame.height) //设置 contentScrollView 内容大小</span><br><span class="line">        </span><br><span class="line">        //计算并设置 tabScrollView 内容大小</span><br><span class="line">        var TABVIEW_WIDTH = CGFloat(0)</span><br><span class="line">        for tabLbl in self.tabLbls &#123;</span><br><span class="line">            TABVIEW_WIDTH += self.MARGIN + tabLbl.frame.width</span><br><span class="line">        &#125;</span><br><span class="line">        TABVIEW_WIDTH += self.MARGIN</span><br><span class="line">        self.tabScrollView.contentSize = CGSizeMake(TABVIEW_WIDTH, 40)</span><br><span class="line">        </span><br><span class="line">        //默认选中第一个标签</span><br><span class="line">        self.tabLbls[0].textColor = self.TEXT_COLOR_ACTIVE</span><br><span class="line">        self.currentTabIndex = 0</span><br><span class="line">        self.currentTabX = self.tabLbls[0].frame.origin.x</span><br><span class="line">        </span><br><span class="line">        //添加 tab 标签下划线</span><br><span class="line">        //设置位置有一个没搞清楚的问题：不知为何 y 坐标设为 TABSCROLLVIEW_HEIGHT - self.TAB_LINE_HEIGHT 时，下划线看不见</span><br><span class="line">        self.tabScrollView.addSubview(self.tabLine)</span><br><span class="line">        self.tabLine.backgroundColor = TAB_LINE_COLOR</span><br><span class="line">        self.tabLine.frame = CGRectMake(MARGIN, TABSCROLLVIEW_HEIGHT - 5, self.tabLbls[0].frame.width, self.TAB_LINE_HEIGHT)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        //当 contentScrollView 滚动时</span><br><span class="line">        if scrollView == self.contentScrollView &#123;</span><br><span class="line">            let index = scrollView.contentOffset.x / self.view.frame.width //获取当前页面 index</span><br><span class="line">            </span><br><span class="line">            if floor(index) == index &#123;</span><br><span class="line">                self.currentTabIndex = Int(index)</span><br><span class="line">                self.currentTabX = self.tabLbls[self.currentTabIndex].frame.origin.x</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //阻止第一页和最后一页越界滚动</span><br><span class="line">            let MIN_X = CGFloat(0)</span><br><span class="line">            let MAX_X = scrollView.contentSize.width - self.view.frame.width</span><br><span class="line">            let CONTENT_OFFSET_X = scrollView.contentOffset.x</span><br><span class="line">            </span><br><span class="line">            if CONTENT_OFFSET_X &lt; MIN_X &#123;</span><br><span class="line">                scrollView.contentOffset.x = MIN_X</span><br><span class="line">            &#125; else if CONTENT_OFFSET_X &gt; MAX_X &#123;</span><br><span class="line">                scrollView.contentOffset.x = MAX_X</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //当没有越界时，执行『动画』</span><br><span class="line">                </span><br><span class="line">                //初始化一些要用到的值</span><br><span class="line">                let isLeft = index &lt; CGFloat(self.currentTabIndex)</span><br><span class="line">                let nextTabIndex = isLeft ? self.currentTabIndex - 1 : index == CGFloat(self.currentTabIndex) ? self.currentTabIndex : self.currentTabIndex + 1 //下一个标签 index</span><br><span class="line">                let currentTabWidth = self.tabLbls[self.currentTabIndex].frame.width //当前标签宽度</span><br><span class="line">                let nextTabWidth = self.tabLbls[nextTabIndex].frame.width //下一个标签宽度</span><br><span class="line">                let widthDif = nextTabWidth - currentTabWidth //两个标签宽度差</span><br><span class="line">                let distance = self.MARGIN + (isLeft ? self.tabLbls[nextTabIndex].frame.width : currentTabWidth) //下划线需要滑动的距离</span><br><span class="line">                var offsetPercentage = index - CGFloat(self.currentTabIndex) //当前偏移百分比</span><br><span class="line">                //如果滑动超过一页，将偏移百分比设置为 ±1，避免多余动画</span><br><span class="line">                if offsetPercentage &lt; -1 &#123;</span><br><span class="line">                    offsetPercentage = -1</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if offsetPercentage &gt; 1 &#123;</span><br><span class="line">                    offsetPercentage = 1</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //改变标签底部横线位置和长度</span><br><span class="line">                self.tabLine.frame = CGRectMake(currentTabX + distance * offsetPercentage, self.tabLine.frame.origin.y, currentTabWidth + widthDif * abs(offsetPercentage), self.tabLine.frame.height)</span><br><span class="line">                </span><br><span class="line">                //改变颜色</span><br><span class="line">                self.tabLbls[nextTabIndex].textColor = UIColor(red: (TEXT_COLOR_NORMAL_RED + TEXT_COLOR_RED_DIF * abs(offsetPercentage)) / 255, green: (TEXT_COLOR_NORMAL_GREEN + TEXT_COLOR_GREEN_DIF * abs(offsetPercentage)) / 255, blue: (TEXT_COLOR_NORMAL_BLUE + TEXT_COLOR_BLUE_DIF * abs(offsetPercentage)) / 255, alpha: 1)</span><br><span class="line">                self.tabLbls[self.currentTabIndex].textColor = UIColor(red: (TEXT_COLOR_ACTIVE_RED - TEXT_COLOR_RED_DIF * abs(offsetPercentage)) / 255, green: (TEXT_COLOR_ACTIVE_GREEN - TEXT_COLOR_GREEN_DIF * abs(offsetPercentage)) / 255, blue: (TEXT_COLOR_ACTIVE_BLUE - TEXT_COLOR_BLUE_DIF * abs(offsetPercentage)) / 255, alpha: 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123;</span><br><span class="line">        if scrollView == self.contentScrollView &#123;</span><br><span class="line">            let TWO_WORD_WIDTH = CGFloat(34) //两个字标签的宽度。这个间距其实是根据自己需求随便设置的。</span><br><span class="line">            </span><br><span class="line">            //当标签左边被遮挡时，调整 tabScrollView x 轴偏移量</span><br><span class="line">            if self.tabLine.frame.origin.x &lt; self.tabScrollView.contentOffset.x &#123;</span><br><span class="line">                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">                    self.tabScrollView.contentOffset.x = self.tabLine.frame.origin.x - self.MARGIN</span><br><span class="line">                    &#125;, completion: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //当下划线 x 坐标在 tabScrollView 中部之后时，调整 tabScrollView x 轴偏移量</span><br><span class="line">            if self.tabLine.frame.origin.x &gt; self.tabScrollView.frame.width / 2 &amp;&amp; self.currentTabIndex + 1 &lt; self.tabLbls.count - 3 &#123;</span><br><span class="line">                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">                    self.tabScrollView.contentOffset.x = self.tabLine.frame.origin.x - self.MARGIN - TWO_WORD_WIDTH</span><br><span class="line">                    &#125;, completion: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //当标签右边被遮挡时，调整 tabScrollView x 轴偏移量</span><br><span class="line">            if self.tabLine.frame.origin.x + self.tabLine.frame.width + self.MARGIN &gt; self.tabScrollView.contentOffset.x + self.tabScrollView.frame.width&#123;</span><br><span class="line">                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">                    self.tabScrollView.contentOffset.x += (self.tabLine.frame.origin.x + self.tabLine.frame.width + self.MARGIN) - (self.tabScrollView.contentOffset.x + self.tabScrollView.frame.width) + self.MARGIN</span><br><span class="line">                    &#125;, completion: nil)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @IBAction func tabScrollViewTapped(sender: UITapGestureRecognizer) &#123;</span><br><span class="line">        let location = sender.locationInView(self.tabScrollView) //获取当前点击事件在 tabScrollView 里的坐标</span><br><span class="line">        </span><br><span class="line">        //循环找到点击的是哪一个标签，找到时执行方法</span><br><span class="line">        for var i = 0; i &lt; self.tabLbls.count; i++ &#123;</span><br><span class="line">            if CGRectContainsPoint(self.tabLbls[i].frame, location) &#123;</span><br><span class="line">                self.tabLbls[self.currentTabIndex].textColor = TEXT_COLOR_NORMAL</span><br><span class="line">                self.tabLbls[i].textColor = TEXT_COLOR_ACTIVE</span><br><span class="line">                self.currentTabIndex = i</span><br><span class="line">                self.currentTabX = self.tabLbls[self.currentTabIndex].frame.origin.x</span><br><span class="line">                </span><br><span class="line">                self.contentScrollView.contentOffset.x = self.view.frame.width * CGFloat(i)</span><br><span class="line">                </span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot;&gt;github 仓库：模拟凤凰新闻首页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下午逛 SegmentFault 时看到有人问如何实现凤凰新闻 app 首页效果，正好这两天在学习如何实现多个 TableView 的侧滑与切换，索性自己尝试一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单列一下关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟随滑动&lt;/li&gt;
&lt;li&gt;点击事件
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UITableView" scheme="http://chengkang.me/tags/UITableView/"/>
    
      <category term="UISrollView" scheme="http://chengkang.me/tags/UISrollView/"/>
    
  </entry>
  
  <entry>
    <title>AutoLayout 中需要注意的点</title>
    <link href="http://chengkang.me/2016/04/07/AutoLayout%20%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>http://chengkang.me/2016/04/07/AutoLayout 中需要注意的点/</id>
    <published>2016-04-06T23:41:14.000Z</published>
    <updated>2016-04-06T23:44:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文用于记录我在使用 AutoLayout 过程中遇到的一些需要注意的事情，一种是容易犯的错误，一种是我找不到原因的情况。<br><a id="more"></a></p>
</blockquote>
<h3 id="容易犯的错误"><a href="#容易犯的错误" class="headerlink" title="容易犯的错误"></a>容易犯的错误</h3><ol>
<li>如果预览的样式和你预想的不一样，检查一下是不是忘记给作为背景的 view 添加约束（上下左右），可能有一个约束缺失，导致整体样式出错。</li>
</ol>
<h3 id="找不到原因的情况"><a href="#找不到原因的情况" class="headerlink" title="找不到原因的情况"></a>找不到原因的情况</h3><ol>
<li><p>在 ScrollView 中通过 AutoLayout 设置 StackView 子视图不固定宽度时，需要设置和 superview Equal Widths，然后根据需要调整间距。否则子视图宽度约束设置不生效。如果出现其他 view 宽度不对劲的情况，也可以试着用 Equal Widths 解决。</p>
<p> 如图，分别为宽度不正常情况和使用 Eauql Widths 之后正常情况：</p>
<p> <img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-07%20at%2012.37.01%20AM.png" alt=""></p>
<p> <img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-07%20at%2012.37.31%20AM.png" alt=""></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文用于记录我在使用 AutoLayout 过程中遇到的一些需要注意的事情，一种是容易犯的错误，一种是我找不到原因的情况。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://chengkang.me/tags/AutoLayout/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
</feed>
