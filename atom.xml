<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENG KANG</title>
  <subtitle>Hello World Anyway</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chengkang.me/"/>
  <updated>2017-05-23T21:21:36.000Z</updated>
  <id>http://chengkang.me/</id>
  
  <author>
    <name>程康·CHENGKANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Core Graphics，第一部分：序章</title>
    <link href="http://chengkang.me/2017/05/23/core-graphics-part-1/"/>
    <id>http://chengkang.me/2017/05/23/core-graphics-part-1/</id>
    <published>2017-05-23T21:20:01.000Z</published>
    <updated>2017-05-23T21:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-1-in-the-beginning/" target="_blank" rel="external">Core Graphics, Part 1: In the Beginning - Mark Dalrymple</a></p>
</blockquote>
<p>Mac 和 iOS 开发者有许多不同的让东西显示在屏幕上的编程接口。UIKit 和 AppKit 有各种各样的 image、color 和 path 类。Core Animation 让你可以移动 layer。OpenGL 让你可以在三维空间渲染东西。SpriteKit 让你可以做动画。AVFoundation 让你可以播放视频。</p>
<p>Core Graphics，或者它在市场中被人熟知的名字“Quartz”，是这个平台上最老的图形相关 API 之一。Quartz 构建了大多数二维的东西的基础。想要画些图形，给它们填充上渐变并且加上阴影？用 Core Graphics。想要在屏幕上合成图片？Core Graphics 能解决。想要创建 PDF？还是 Core Graphics。</p>
<a id="more"></a>
<p>CG 是一个相当大的 API，包括了从基本的几何数据结构（例如：点、大小、向量和矩形）和用于操作它们的方法、用于将像素渲染进图片或者屏幕的东西，一直到事件处理。你可以用 CG 来创建“events taps”，它能帮你监听和操作应用中的事件流（鼠标点击、屏幕点击、任意键盘按键）。</p>
<p>好吧。最后一项是有点奇怪。为什么一个 graphics API 要处理用户事件呢？这啊和别的一样，还得从历史说起。而且了解一点历史也可以帮助理解为什么 CG 是那样工作的。</p>
<h2 id="历史中的-PostScript"><a href="#历史中的-PostScript" class="headerlink" title="历史中的 PostScript"></a>历史中的 PostScript</h2><p>从时间的迷雾往回看（二十世纪八十年代，Duran Duran 还在上升期时），graphic API 相比今天还非常初级。你能做的只有从有限的色盘中挑选颜色、绘制独立的像素点、连线和画一些基本的图形比如矩形和椭圆。你可以设置剪切范围来告诉别人，“嘿，这儿不能画，”而且有时候你会有一些不受控的特性比如调整线有多宽。经常会有一些“像素位块传输”的功能用于将像素块到处复制。Mac 上的 QuickDraw 有一个很酷的功能叫做 <code>regions</code>，它能让你创建任意形状的区域然后使用它们来绘制、剪切、绘制轮廓或者 hit -test。不过基本上，当时的 API 都是面向像素的。</p>
<p>1985 年，Apple 发布了 LaserWriter，一个是其链接的计算机价格两倍的打印机。它包含一个比其链接的计算机更强劲的微处理器，以及一个 12 倍的 RAM。归功于一个叫做 PostScript 的技术，这款打印机（在当时）制作出了魅力惊人的打印制品。</p>
<p>PostScript 是一个来自 Adobe 的基于栈的计算机语言，与 FORTH 类似。PostScript， 这种技术，是为了创建矢量图（艺术的数学描述）而非基于像素。在 LaserWriter 中内嵌了一个 PostScript 解释器，因此当 Mac 上的程序想要打印什么东西的时候，这个程序（或者某个打印机驱动）将会生成一段程序代码，将其载入打印机并执行。</p>
<p>下面是一个 PostScript 代码的例子以及结果图像：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/postscript-code.png" alt=""></p>
<p>你可以在 <a href="https://github.com/markd2/CGPS" target="_blank" rel="external">Github</a> 上找到这个项目。</p>
<p>将页面用代码形式来展现是一个非常重要的设计上的决策。这使得程序可以以算法的形式展现页面中的内容，因此用于执行这段程序的设备能够用其最大分辨率来绘制页面。对于当时大多数打印机，这个值是 300dpi。对于其他的，1200dpi。它们都是由同样的生成的程序绘制的。</p>
<p>除了渲染页面，PostScript 是图灵完备的，并且可以被当作通用编程语言。你甚至可以用它写 Web Server。</p>
<h2 id="Companion-CuBEs"><a href="#Companion-CuBEs" class="headerlink" title="Companion CuBEs"></a>Companion CuBEs</h2><p>NeXT 工程师在设计他们的系统时，他们选择了 PostScript 作为渲染模型。Display PostScript，简称 DPS，扩展了 PostScript 模型，使其能够在窗口化的计算机显示器工作。不过其核心仍是一个 PostScript 解释器。NeXT 的应用可以用 PostScript 代码实现其屏幕绘制，并且用同一段代码进行打印。你同样也可以用 C 函数来包裹 postScript （使用一个叫 pswrap 的程序）以从应用代码中调用。</p>
<p>Display PostScript 是用户交互的基础。事件（鼠标、键盘、更新等等）通过 DPS 系统然后被分发到应用中去。</p>
<p>NeXT 并非当时唯一使用 PostScript 的窗口化系统。Sun 的 NeWS（除了名字像之外，和 NeXT 没有一点关系）也有一个用于驱动系统中用户交互的内嵌 PostScript 解释器。</p>
<h2 id="说说-Quartz"><a href="#说说-Quartz" class="headerlink" title="说说 Quartz"></a>说说 Quartz</h2><p>为什么 OS X 和 iOS 不用 Display PostScript？基本上是钱的原因。Adobe 收取 Display PostScript 证书费用。同时，Apple 也是有名的想要尽可能有更多他们自有的技术栈。通过实现 PostScript 绘制模型，但并不真正使用 PostScript，他们既避免了付证书费也有了 Core Graphics 的代码。</p>
<p>有一种普遍的说法是 Quartz 是“基于” PDF 的，在某种意义上的确如此。PDF 就是没有任意编程功能的 PostScript 绘制模型。Quartz 被设计成其 API 的典型使用和 PDF 本身支持的非常接近，以至于在这个平台上创建 PDF 几乎不费吹灰之力。</p>
<p>哪怕 Display PostScript 被 Quartz 取代了，同样的基本原理被保留下来了，包括事件处理。看看 Cocoa 栈轨迹的 18 帧吧。DPS 仍在！</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/stack-trace.png" alt=""></p>
<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>我会在接下来的几周讲到更多 Quartz 细节的各个方面，但是有一个重点是用于“画东西”的那段代码被从实际图形渲染中抽象出来了。“渲染”可以是“让东西在 NSView 中显示”，或者“让东西显示在 UIImage 里面”，甚至是“让东西显示在 PDF 中”。</p>
<p>你所有的 CG 绘制都在一个“context（上下文）”中执行，它是数据结构和用于控制如何绘制的方法的指针的集合。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/output.png" alt=""></p>
<p>Context 有很多种，比如（在 Mac 上）有 NSWindowGraphicsContext。这一特定 context 获取你的代码安排的绘制指令，然后在你的应用的地址空间里中一块共享内存里绘制出像素。这一段内存也与窗口服务器共享。窗口服务器将所有正在运行的应用的窗口表面样子一起展示在屏幕上。</p>
<p>另一种 CG Context 是一种图片 context。任何你运行的绘制代码都会将像素布置在一个位图图片中。你可以使用这个图片来绘入其它 context 中或者作为 PNG 或 JPEG 保存在文件系统。同样也有一个 PDF context。运行的绘制代码不会变成像素，而是变成了 PDF 命令并被存进一个文件中。此后，PDF查看器可以使用那些 PDF 命令来渲染成某种可以查看的东西。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/different-results.png" alt=""></p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>下一次，更近距离来看看 context，以及一些 Core Graphics 中的便捷 API。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-1-in-the-beginning/&quot;&gt;Core Graphics, Part 1: In the Beginning - Mark Dalrymple&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mac 和 iOS 开发者有许多不同的让东西显示在屏幕上的编程接口。UIKit 和 AppKit 有各种各样的 image、color 和 path 类。Core Animation 让你可以移动 layer。OpenGL 让你可以在三维空间渲染东西。SpriteKit 让你可以做动画。AVFoundation 让你可以播放视频。&lt;/p&gt;
&lt;p&gt;Core Graphics，或者它在市场中被人熟知的名字“Quartz”，是这个平台上最老的图形相关 API 之一。Quartz 构建了大多数二维的东西的基础。想要画些图形，给它们填充上渐变并且加上阴影？用 Core Graphics。想要在屏幕上合成图片？Core Graphics 能解决。想要创建 PDF？还是 Core Graphics。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>react-native-lahk-marquee-label（跑马灯文字组件）</title>
    <link href="http://chengkang.me/2017/04/11/react-native-lahk-marquee-label/"/>
    <id>http://chengkang.me/2017/04/11/react-native-lahk-marquee-label/</id>
    <published>2017-04-11T17:33:17.000Z</published>
    <updated>2017-04-14T21:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>A react-native marquee label component.</p>
<p>一个 react-native 跑马灯文字组件。</p>
</blockquote>
<p>If you need a vertical marquee label, please use <a href="https://github.com/cheng-kang/react-native-lahk-marquee-label-vertical" target="_blank" rel="external">react-native-lahk-marquee-label-vertical</a>.</p>
<p><a href="https://badge.fury.io/js/react-native-lahk-marquee-label" target="_blank" rel="external"><img src="https://badge.fury.io/js/react-native-lahk-marquee-label.svg" alt="npm version"></a></p>
<h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ol>
<li><a href="#desc">Desc</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#props">Props</a></li>
<li><a href="#中文介绍">中文介绍</a></li>
</ol>
<h2 id="Desc"><a href="#Desc" class="headerlink" title="Desc"></a>Desc</h2><p><a href="#install">Skip this part, go to <strong>#Install</strong></a></p>
<p>I needed a marquee label in one of my recent project and I didn’t find a good one online, so I decided to create my own marquee label component.</p>
<p>I intended to make it work well on both iOS and Android, still there remains one thing in iOS which I cannot fix. I found that in <strong>iOS</strong>, when you use <code>View</code> component to wrap child components and don’t explicitly set the parent <code>View</code> component width (e.g. use <code>flex</code>), the parent <code>View</code> component will have the same width as it’s child. </p>
<p>It becomes a problem in this custom component because I use a child <code>View</code> component to wrap <code>Text</code> component in order to make the text expand and show in one line. I <strong>set the text containner <code>View</code> component size to be bigger than the <code>Text</code> so that it will not have multiple lines nor have the overflow text replaced by ellipsis.</strong> The default value of text container width is 1000, which is usually larger than the actual label width. This results in the problem mentioned above, the wrapper <code>View</code> width becomes 1000 also.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View <span class="class"><span class="keyword">class</span></span>=<span class="string">"marquee-label"</span>&gt;</span><br><span class="line">  &lt;View class="marquee-label-text-container"&gt;</span><br><span class="line">    &lt;Text class="marquee-label-text"&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>In Andorid, you can use both <code>width</code> or <code>flex</code> to layout the view.</li>
<li>In iOS, use <code>width</code> to layout the view. <code>flex</code> layout is not supported.</li>
</ul>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native-lahk-marquee-label</span><br></pre></td></tr></table></figure>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol>
<li>Import</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MarqueeLabel <span class="keyword">from</span> <span class="string">'react-native-lahk-marquee-label'</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>Use</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarqueeLabel</span><br><span class="line">  duration=&#123;<span class="number">8000</span>&#125;</span><br><span class="line">  text=&#123;<span class="string">'This is a Marquee Label.'</span>&#125;</span><br><span class="line">  textStyle=&#123;&#123; fontSize: <span class="number">13</span>, color: <span class="string">'white'</span> &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarqueeLabel</span><br><span class="line">  speed=&#123;<span class="number">250</span>&#125;</span><br><span class="line">  textStyle=&#123;&#123; fontSize: <span class="number">13</span>, color: <span class="string">'white'</span> &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  This is a Marquee Label.</span><br><span class="line">&lt;<span class="regexp">/MarqueeLabel&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ul>
<li><code>children</code>: string, the text to show in the marquee. Alternative to <code>text</code>.</li>
<li><code>text</code>: string, the text to show in the marquee. Alternative to <code>children</code>.</li>
<li><code>duration</code>: number(unit: millisecond), the duration for the marquee to run one round. e.g. 6000 (for 6 seconds a round). Alternative to <code>speed</code>.</li>
<li><code>speed</code>: number(unit: px/s, px per second), the speed of the marquee. Alternative to <code>duration</code>.</li>
<li><code>bgViewStyle</code>: stylesheet object, background view component custom styles.</li>
<li><code>textStyle</code>: stylesheet object, text component custom styles.</li>
<li><code>textContainerWidth</code>: number, text container component width. If the text is not shown in one line, increase this value.</li>
<li><code>textContainerHeight</code>: number, text container component height. If the text is not shown in one line, increase this value.</li>
<li><code>textContainerStyle</code>: stylesheet object, not recommended to use, text containner component custom style.</li>
</ul>
<h2 id="中文介绍"><a href="#中文介绍" class="headerlink" title="中文介绍"></a>中文介绍</h2><p><a href="#install">跳转到 <strong>#install</strong></a></p>
<p>我在一个项目中需要用到跑马灯，但是在网上没找到好用的。所以我就自己写了一个跑马灯的组件。</p>
<p>本来打算让它可以在 iOS 和 Android 平台上都好用的，不过还是在 iOS 平台上存在一个问题没法解决。</p>
<p>我发现在 iOS 平台上，当使用 <code>View</code> 组件来包裹子组件的时候，如果没有显示设置父级 <code>View</code> 组件的宽度（width 样式）（比如用 <code>flex</code> 布局），那么父级 <code>View</code> 组件的宽度会被自动设置成子组件的宽度。（至少当子组件比父组件宽度大时是这样的，另外一种情况我没有做试验。）</p>
<p>我的跑马灯组件中的问题在于，我用了一个子级 <code>View</code> 组件来包裹 <code>Text</code> 组件以保证文字是在一行全部显示。<strong>通过将 text container 的宽度设置得比 <code>Text</code> 组件宽度大，保证了文字不会换行，也不会用省略号替换溢出文字。</strong> text container 默认宽度为 1000，这比一般的跑马灯标签实际宽度要大。而这也就导致了上述的问题，最外层的 <code>View</code> 的宽度也变成了 1000。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View <span class="class"><span class="keyword">class</span></span>=<span class="string">"marquee-label"</span>&gt;</span><br><span class="line">  &lt;View class="marquee-label-text-container"&gt;</span><br><span class="line">    &lt;Text class="marquee-label-text"&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>因此要注意：</strong></p>
<ul>
<li>在 Android 平台上，通过 <code>width</code> 或者 <code>flex</code> 布局来设置最外层 <code>View</code> 的样式都没问题。</li>
<li>在 iOS 平台上，请使用并且只能使用 <code>width</code> 来设置样式。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A react-native marquee label component.&lt;/p&gt;
&lt;p&gt;一个 react-native 跑马灯文字组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you need a vertical marquee 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DoubanFMPlayer, A mimic of Douban.fm player</title>
    <link href="http://chengkang.me/2017/02/03/DoubanFMPlayer,%20A%20mimic%20of%20Douban.fm%20player/"/>
    <id>http://chengkang.me/2017/02/03/DoubanFMPlayer, A mimic of Douban.fm player/</id>
    <published>2017-02-03T22:31:30.000Z</published>
    <updated>2017-02-12T19:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Project Page: <a href="https://github.com/cheng-kang/DoubanFMPlayer" target="_blank" rel="external">https://github.com/cheng-kang/DoubanFMPlayer</a></p>
</blockquote>
<p>A mimic of Douban.fm player on <a href="https://douban.fm/" target="_blank" rel="external">Douban.fm</a>. <em>Also a Flex practice project.</em></p>
<p>You can use it on your website or <strong>embed it in your Hexo theme</strong>.</p>
<h2 id="Showcase"><a href="#Showcase" class="headerlink" title="Showcase"></a>Showcase</h2><p>Click <a href="http://chengkang.me/DoubanFMPlayer/">here</a> to check live demo.</p>
<h3 id="Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page"><a href="#Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page" class="headerlink" title="Dark Theme (the color of the player is dark, used in light color web page)"></a>Dark Theme (the color of the player is dark, used in light color web page)</h3><p><img src="https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-1.gif" alt=""></p>
<h3 id="Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page"><a href="#Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page" class="headerlink" title="Light Theme (the color of the player is light, used in dark color web page)"></a>Light Theme (the color of the player is light, used in dark color web page)</h3><p><img src="https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-2.gif" alt=""></p>
<a id="more"></a>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>Feel free to download source code from <code>/src</code> folder.</p>
<p>Alternatively, use the cdn I’ve set up:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbfmplayer.js: http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js</span><br><span class="line">dbfmplayer.css: http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.css</span><br></pre></td></tr></table></figure></p>
<h3 id="1-Use-it-on-your-website"><a href="#1-Use-it-on-your-website" class="headerlink" title="1. Use it on your website"></a>1. Use it on your website</h3><ol>
<li><p>Add any numbers of <code>dbfmplayer</code> tag to your HTML file.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dbfmplayer </span><br><span class="line">    title=&quot;茜さす 帰路照らされど…&quot; </span><br><span class="line">    singer=&quot;椎名林檎&quot;</span><br><span class="line">    album=&quot;https://img1.doubanio.com/lpic/s2722629.jpg&quot;</span><br><span class="line">    music=&quot;http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4&quot;</span><br><span class="line">&gt;&lt;/dbfmplayer&gt;</span><br></pre></td></tr></table></figure>
<p> You <strong>must</strong> set <code>title</code>, <code>singer</code>, <code>album</code> and <code>music</code> attributes of your <code>dbfmplayer</code> tags.</p>
<ul>
<li><code>title</code>: name of the music</li>
<li><code>singer</code>: name of the singer/musician</li>
<li><code>album</code>: URL of a picture related to this music (both absolute URL or relative URL)</li>
<li><p><code>music</code>: URL of the music (both absolute URL or relative URL)</p>
<p><strong>Optional</strong> attributes are <code>theme</code> and <code>loop</code>.</p>
</li>
<li><p><code>theme</code>: “dark” or “light”. Default theme is “dark”, which is suitable for light color background web pages; theme “light” is suitable for dark color background web pages.</p>
</li>
<li><code>loop</code>: “true” or “false”. Default value is “false”. If <code>loop</code> is set to “true”, the music will loop after it ends.</li>
<li><p><code>autoplay</code>: “true” or “false”. Default value is “false”. If <code>autoplay</code> is set to “true”, the music will automatically start when it’s loaded.</p>
<p>You can set <code>loop</code> and <code>autoplay</code> to “true” in a convenient way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dbfmplayer </span><br><span class="line">    title=&quot;茜さす 帰路照らされど…&quot; </span><br><span class="line">    singer=&quot;椎名林檎&quot;</span><br><span class="line">    album=&quot;https://img1.doubanio.com/lpic/s2722629.jpg&quot;</span><br><span class="line">    music=&quot;http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4&quot;</span><br><span class="line">    loop</span><br><span class="line">    autoplay</span><br><span class="line">&gt;&lt;/dbfmplayer&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Add the following script to your HTML file.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123; // DON&apos;T EDIT BELOW THIS LINE</span><br><span class="line">    var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = &apos;http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js&apos;;</span><br><span class="line">    (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-Embed-it-in-your-Hexo-theme"><a href="#2-Embed-it-in-your-Hexo-theme" class="headerlink" title="2. Embed it in your Hexo theme"></a>2. Embed it in your Hexo theme</h3><ol>
<li><p>Add the following script to your layout file for <strong>Post</strong> (or anywhere else you want):</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123; // DON&apos;T EDIT BELOW THIS LINE</span><br><span class="line">    var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = &apos;http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js&apos;;</span><br><span class="line">    (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now users can add music to their page by adding the <code>dbfmplayer</code> tag to their articles (markdown files) by following <a href="#1-use-it-on-your-website">1.1 Add any numbers of <code>dbfmplayer</code> tag to your HTML file.</a>. </p>
</li>
</ol>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Most SVG icons come from <a href="https://icomoon.io/" target="_blank" rel="external">Iconmoon.io</a>.</p>
<p>Designed by <a href="https://douban.fm" target="_blank" rel="external">Douban.fm</a>.</p>
<h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p><strong>All copyright of the design belongs to who creates it.</strong> </p>
<p>Any copyright issue, please contact <a href="mailto:hi@chengkang.me">hi@chengkang.me</a>.</p>
<dbfmplayer title="茜さす 帰路照らされど…" singer="椎名林檎" album="https://img1.doubanio.com/lpic/s2722629.jpg" music="http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4" theme="dark" loop autoplay></dbfmplayer>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Project Page: &lt;a href=&quot;https://github.com/cheng-kang/DoubanFMPlayer&quot;&gt;https://github.com/cheng-kang/DoubanFMPlayer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A mimic of Douban.fm player on &lt;a href=&quot;https://douban.fm/&quot;&gt;Douban.fm&lt;/a&gt;. &lt;em&gt;Also a Flex practice project.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You can use it on your website or &lt;strong&gt;embed it in your Hexo theme&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Showcase&quot;&gt;&lt;a href=&quot;#Showcase&quot; class=&quot;headerlink&quot; title=&quot;Showcase&quot;&gt;&lt;/a&gt;Showcase&lt;/h2&gt;&lt;p&gt;Click &lt;a href=&quot;http://chengkang.me/DoubanFMPlayer/&quot;&gt;here&lt;/a&gt; to check live demo.&lt;/p&gt;
&lt;h3 id=&quot;Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page&quot;&gt;&lt;a href=&quot;#Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page&quot; class=&quot;headerlink&quot; title=&quot;Dark Theme (the color of the player is dark, used in light color web page)&quot;&gt;&lt;/a&gt;Dark Theme (the color of the player is dark, used in light color web page)&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page&quot;&gt;&lt;a href=&quot;#Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page&quot; class=&quot;headerlink&quot; title=&quot;Light Theme (the color of the player is light, used in dark color web page)&quot;&gt;&lt;/a&gt;Light Theme (the color of the player is light, used in dark color web page)&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Examples to understand how to find Nash equilibrium by eliminating “dominated strategies”</title>
    <link href="http://chengkang.me/2017/01/18/Examples%20to%20understand%20how%20to%20find%20Nash%20equilibrium%20by%20eliminating%20%E2%80%9Cdominated%20strategies%E2%80%9D/"/>
    <id>http://chengkang.me/2017/01/18/Examples to understand how to find Nash equilibrium by eliminating “dominated strategies”/</id>
    <published>2017-01-18T17:14:22.000Z</published>
    <updated>2017-01-18T17:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is a summarization of contents from two different sources. It aims at helping people (at least myself) to understand what <code>dominated strategies</code> are and especially what <strong>weakly dominated strategy</strong> is.</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Suppose <em>si</em> and <em>s’i</em> are two strategies for player <em>i</em> in a normal form game.</p>
<p>We say <em>s’i</em> is <strong>strictly dominated</strong> by <em>si</em> if, for every choice of strategies of the other players, <em>i</em>’s payoff from choosing <em>si</em> is <code>strictly greater than</code> <em>i</em>’s payoff from choosing <em>s’i</em>.</p>
<p>We call <em>s’i</em> dominated strategy and <em>si</em> dominant strategy.</p>
<p>We say <em>s’i</em> is <strong>weakly dominated</strong> by <em>si</em> if, for every choice of strategies of the other players, <em>i</em>’s payoff from chossing <em>si</em> is <code>at least as great as</code> <em>i</em>’s payoff from choosing <em>s’i</em>.</p>
<a id="more"></a>
<h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h2><ol>
<li>If a unique strategy remains for the player, we call this the player’s dominant strategy.</li>
<li>If a unique strategy remains for all players, we call this strategy profile a dominant<br>strategy equilibrium.</li>
<li>A dominant strategy equilibrium is a Nash equilibrium. And we can eliminate<br>dominated strategies without losing any Nash equilibria.</li>
<li>If the iterated elimination of weakly dominated strategies leaves exactly one strategy<br>for each player, the resulting strategy profile is a Nash equilibrium. <strong>However some Nash equilibria can be discarded this way.</strong></li>
</ol>
<h2 id="Example-of-eliminating-strictly-dominated-strategies"><a href="#Example-of-eliminating-strictly-dominated-strategies" class="headerlink" title="Example of eliminating strictly dominated strategies"></a>Example of eliminating strictly dominated strategies</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">Agent2</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">L</td>
<td style="text-align:center">C</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center"><strong>Agent1</strong></td>
<td style="text-align:center">T</td>
<td style="text-align:center">73, 25</td>
<td style="text-align:center">57, 42</td>
<td style="text-align:center">66,32</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">80, 26</td>
<td style="text-align:center">35, 12</td>
<td style="text-align:center">32,54</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:center">28, 27</td>
<td style="text-align:center">63, 31</td>
<td style="text-align:center">54,29</td>
</tr>
</tbody>
</table>
<p>L can be eliminated since it is strictly dominated by R, and then M can be eliminated since it is strictly dominated by both T and B, and then R can be eliminated since it is strictly dominated by C. Now Agent1 will choose B, which will result in a payoff of <strong>63, 31</strong>.</p>
<h2 id="Example-of-eliminating-weakly-dominated-strategies"><a href="#Example-of-eliminating-weakly-dominated-strategies" class="headerlink" title="Example of eliminating weakly dominated strategies"></a>Example of eliminating weakly dominated strategies</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">Agent2</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">L</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center"><strong>Agent1</strong></td>
<td style="text-align:center">T</td>
<td style="text-align:center">1, 1</td>
<td style="text-align:center">0, 0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">1, 1</td>
<td style="text-align:center">2, 1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:center">0, 0</td>
<td style="text-align:center">2, 1</td>
</tr>
</tbody>
</table>
<p>This example illustrates the difficulties that may occur when eliminating weakly dominated strategies.</p>
<p>The actions that survive iterated elimination of weakly dominated strategiescan depend on the order in which the actions are eliminated.</p>
<ol>
<li><p>For example, T can be eliminated since it is weakly dominated by M,and then L can be eliminated since it is weakly dominated by R. Now, agent2 will choose action R, which will result in a payoff of <strong>(2, 1)</strong> for which ever action agent 1 selects.</p>
</li>
<li><p>On the other hand, action B could have been eliminated first since it is weakly dominated by M, and then R could have been eliminated since it is weakly dominated by L. Now, the payoff is <strong>(1, 1)</strong> for which ever action agent 1 selects.</p>
</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1]<a href="http://tuvalu.santafe.edu/~jkchoi/ch2_a.pdf" target="_blank" rel="external">Leading fromStrength: Eliminating Dominated Strategies</a></p>
<p>[2]<a href="https://cs.uwaterloo.ca/~klarson/teaching/F08-886/WeaklyDominatedStrats.pdf" target="_blank" rel="external">Weakly Dominated Strategies</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is a summarization of contents from two different sources. It aims at helping people (at least myself) to understand what &lt;code&gt;dominated strategies&lt;/code&gt; are and especially what &lt;strong&gt;weakly dominated strategy&lt;/strong&gt; is.&lt;/p&gt;
&lt;h2 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h2&gt;&lt;p&gt;Suppose &lt;em&gt;si&lt;/em&gt; and &lt;em&gt;s’i&lt;/em&gt; are two strategies for player &lt;em&gt;i&lt;/em&gt; in a normal form game.&lt;/p&gt;
&lt;p&gt;We say &lt;em&gt;s’i&lt;/em&gt; is &lt;strong&gt;strictly dominated&lt;/strong&gt; by &lt;em&gt;si&lt;/em&gt; if, for every choice of strategies of the other players, &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;si&lt;/em&gt; is &lt;code&gt;strictly greater than&lt;/code&gt; &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;s’i&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We call &lt;em&gt;s’i&lt;/em&gt; dominated strategy and &lt;em&gt;si&lt;/em&gt; dominant strategy.&lt;/p&gt;
&lt;p&gt;We say &lt;em&gt;s’i&lt;/em&gt; is &lt;strong&gt;weakly dominated&lt;/strong&gt; by &lt;em&gt;si&lt;/em&gt; if, for every choice of strategies of the other players, &lt;em&gt;i&lt;/em&gt;’s payoff from chossing &lt;em&gt;si&lt;/em&gt; is &lt;code&gt;at least as great as&lt;/code&gt; &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;s’i&lt;/em&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Theory" scheme="http://chengkang.me/tags/Game-Theory/"/>
    
      <category term="Dominated Strategies" scheme="http://chengkang.me/tags/Dominated-Strategies/"/>
    
  </entry>
  
  <entry>
    <title>QnA，一个 Hexo FAQ 主题</title>
    <link href="http://chengkang.me/2017/01/14/QnA%EF%BC%8C%E4%B8%80%E4%B8%AA%20Hexo%20FAQ%20%E4%B8%BB%E9%A2%98/"/>
    <id>http://chengkang.me/2017/01/14/QnA，一个 Hexo FAQ 主题/</id>
    <published>2017-01-14T11:47:03.000Z</published>
    <updated>2017-01-14T12:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前在 Gitbook 上创建了一个 FAQ 网站，但是 Gitbook 使用起来偏麻烦，而且主题不好看。预期创建一个 Gitbook 主题，不如创建一个 Hexo 主题，然后将网站部署到 Github 上。于是我便动手制作了这个主题。</p>
<p>这个主题的最初目的是为了服务这个网站 <a href="http://chengkang.me/Swift-Newbie/">Swift Newbie: 给 Swift 新手的知识库</a>，对 Swift 学习感兴趣的同学可以点开看看，有意贡献的同学可以联系我 <code>hi@chengkang.me</code>。</p>
<p>项目主页：<a href="https://github.com/cheng-kang/hexo-theme-qna" target="_blank" rel="external">《Theme QnA for Hexo》</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cheng-kang/hexo-theme-qna/master/QnA.png" alt=""></p>
<p>为 Hexo 设计的『知识库』类主题。</p>
<a id="more"></a>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="./Documentation.md">Documentation English Version</a></li>
</ul>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示:"></a>展示:</h2><ul>
<li><a href="http://chengkang.me/hexo-theme-qna/">预览</a></li>
<li><a href="http://chengkang.me/Swift-Newbie/">Swift Newbie: 给 Swift 新手的知识库</a></li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/cheng-kang/hexo-theme-qna.git themes/QnA</span><br></pre></td></tr></table></figure>
<h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>修改根目录中 <code>_config.yml</code> 的 <code>theme</code> 为 <code>QnA。</code></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/QnA</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="发布到-Github"><a href="#发布到-Github" class="headerlink" title="发布到 Github"></a>发布到 Github</h3><p>安装 Hexo 插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>编辑你 Hexo 博客根目录中的 <code>_config.yml</code> 文件。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> git</span><br><span class="line"><span class="attr">  repo:</span> &lt;repository url&gt; <span class="comment"># https://github.com/cheng-kang/hexo-theme-qna.git</span></span><br><span class="line"><span class="attr">  branch:</span> [branch] <span class="comment"># master</span></span><br></pre></td></tr></table></figure>
<h3 id="启用中文站内搜索"><a href="#启用中文站内搜索" class="headerlink" title="启用中文站内搜索"></a>启用中文站内搜索</h3><blockquote>
<p>QnA 默认只支持英文站内搜索。</p>
</blockquote>
<p>安装 Hexo 插件 <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="external">hexo-generator-search</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<h3 id="添加新页面"><a href="#添加新页面" class="headerlink" title="添加新页面"></a>添加新页面</h3><ol>
<li><p>添加一个新页面，例如：about 页面。改变页面内容请修改根目录下 source/about/index.md 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 theme/QnA 中的 <code>_config.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> /</span><br><span class="line"><span class="attr">  Archive:</span> /archives</span><br><span class="line">  <span class="comment"># Add new page config here</span></span><br><span class="line">  <span class="comment"># Page Dispay Name: /pagename</span></span><br><span class="line">  <span class="comment"># e.g.</span></span><br><span class="line"><span class="attr">  About:</span> /about</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前在 Gitbook 上创建了一个 FAQ 网站，但是 Gitbook 使用起来偏麻烦，而且主题不好看。预期创建一个 Gitbook 主题，不如创建一个 Hexo 主题，然后将网站部署到 Github 上。于是我便动手制作了这个主题。&lt;/p&gt;
&lt;p&gt;这个主题的最初目的是为了服务这个网站 &lt;a href=&quot;http://chengkang.me/Swift-Newbie/&quot;&gt;Swift Newbie: 给 Swift 新手的知识库&lt;/a&gt;，对 Swift 学习感兴趣的同学可以点开看看，有意贡献的同学可以联系我 &lt;code&gt;hi@chengkang.me&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/cheng-kang/hexo-theme-qna&quot;&gt;《Theme QnA for Hexo》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/hexo-theme-qna/master/QnA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为 Hexo 设计的『知识库』类主题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DanmuManager 一个简单的弹幕工具</title>
    <link href="http://chengkang.me/2017/01/05/DanmuManager%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%B9%E5%B9%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://chengkang.me/2017/01/05/DanmuManager 一个简单的弹幕工具/</id>
    <published>2017-01-05T18:14:32.000Z</published>
    <updated>2017-01-05T13:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目首页： <a href="https://github.com/cheng-kang/DanmuManager" target="_blank" rel="external">DanmuManager Github Repository</a></p>
</blockquote>
<h2 id="使用方法-Usage"><a href="#使用方法-Usage" class="headerlink" title="使用方法 Usage"></a>使用方法 Usage</h2><p><code>DanmuManager</code> 和 <code>VideoDanmuManager</code> 有不同的应用场景，后者用于视频弹幕。</p>
<p>你可以运行项目中的测试，来了解二者的使用方法。<br><a id="more"></a></p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-1.gif" width="200"><br><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-2.gif" width="200"><br><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-3.gif" width="200"></p>
<h3 id="DanmuManager"><a href="#DanmuManager" class="headerlink" title="DanmuManager"></a>DanmuManager</h3><ol>
<li><p>创建 DanmuManager</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dm = DanmuManager(with: self.view)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>初始化 `init` 方法允许自定义： 

- `top`、`bottom`弹幕显示在 `view` 中的上下位置范围;
- `speed` 弹幕的速度;
- `customFont` 弹幕字体（`UIFont`, 包括字体家族和大小，默认为系统字体，字号 20）。
</code></pre><ol>
<li><p>添加一条弹幕 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dm.add(with: “Wow so cool!!!”, at: 4)</span><br></pre></td></tr></table></figure>
<p> 添加弹幕 <code>add</code> 方法有两个必传参数，<code>text</code>（弹幕文字） 和 <code>line</code>（弹幕所在行）;可选参数 <code>hasBorder</code> 用于设置该条弹幕是否有边框（默认 borderColor = UIColor.black.cgColor，borderWidth = 1）,默认值为 false;可选参数 <code>isAdvance</code> 用于设置该条弹幕是否开启高级功能（目前支持修改 文字颜色 和 背景颜色），默认值为 false。</p>
<p> 如果需要弹幕出现在随机行，可以使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func addRandom(with text: String = &quot;This is a test Danmu.&quot;, at line: Int = 0, hasBorder: Bool = false, isAdvanced: Bool = false)`。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>暂停/继续 弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dm.pause()</span><br><span class="line">dm.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以使用 `dm.toggle()` 来快捷切换 暂停/继续。
</code></pre><h3 id="VideoDanmuManager"><a href="#VideoDanmuManager" class="headerlink" title="VideoDanmuManager"></a>VideoDanmuManager</h3><ol>
<li><p>创建 VideoDanmuManager</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let vdm = VideoDanmuManager(view: self.view,</span><br><span class="line">                               videoLength: 10,</span><br><span class="line">                               danmuData: [</span><br><span class="line">                                   (3.4, &quot;3.4 Wowowowowowow!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 SOOOO COOOOOOOOOOL!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 Amazing!!!!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 I love you~&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 MY BABY!!!!&quot;),</span><br><span class="line">                                   (1.1, &quot;1.1 This is a test Danmu!!!&quot;),</span><br><span class="line">                                   (2.0, &quot;2.0 Another test Danmu.&quot;),</span><br><span class="line">                                   (4.1, &quot;4.1 Amazing!!!!&quot;),</span><br><span class="line">                                   (6.1, &quot;6.1 Test!!!!&quot;),</span><br><span class="line">                                   (8.1, &quot;8.1 Test!!!!&quot;),</span><br><span class="line">                                   (9.1, &quot;9.1 Test!!!!&quot;),</span><br><span class="line">                                   (10, &quot;10 Test!!!!&quot;),</span><br><span class="line">           ],</span><br><span class="line">                               isSorted: false</span><br><span class="line">       )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>`VideoDanmuManager` 的创建有三个必选参数，`view`（显示弹幕的视图），`videoLength`（视频时长，精确到 0.1 秒）和 `danmuData`（已经存在的弹幕列表）。

可选参数 `videoCurrent` 默认为 0，即开始时刻；你可以通过传入不同的时间值来设置显示弹幕的初始时间（比如在视频从 1 分 15 秒开始播放，则应设置 `videoCurrent` 为 75）。
可选参数 `isSorted` 默认为 true，即默认数据集已经按照弹幕显示时间从先到后排序；如传入 false，则将自动调用 `func sort()` 对数据进行排序。

可选参数 `top` 和 `bottom` 同 `DanmuManager`。
</code></pre><ol>
<li><p>开启弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.start()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你需要在视频开始播放的同时，手动开启弹幕。
</code></pre><ol>
<li><p>暂停/继续 弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vdm.pause()</span><br><span class="line">vdm.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以使用 `vdm.toggle()` 来快捷切换 暂停/继续。
</code></pre><ol>
<li><p>中止弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.stop()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>重新开始弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.restart()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以在指定时间点重新开始弹幕：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.restart(at: 75)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p><code>DanmuManager</code> 通过设置的字体大小计算文本显示高度 <code>lineHeight</code>，通过 <code>numberOfLines = Int(floor((bottom - top) / lineHeight))</code> 得到可以显示的弹幕行数；使用 <code>inUsingLines</code>，<code>enteringTimers</code> 和 <code>waitingQueues</code> 来分别记录 正在使用的行（有尾部还没有完全进入视图的弹幕的行），正在进入视图的弹幕的计时器 和 正在等待进入的弹幕队列。</p>
<p>为了防止弹幕重叠，只有当 当前行中前一条弹幕尾部进入视图 时（之后），下一条弹幕才可以发射。</p>
<p><code>enteringTimers</code> 中每一个 Timer 都对应一条正在进入视图的弹幕，当计时器结束时，通过 NotificationCenter 发通知将该弹幕所在的行的状态更改为 false。</p>
<p>因为弹幕存在暂停状态，如果弹幕对应的 Timer 不同时暂停，将导致 弹幕所在行状态 提前更改为 false。为了解决这个问题，我参考他人的想法并改进后创建了 PauseableTimer，并在本项目中使用上了。我的另外一篇博客更详细地介绍了 <a href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/">《PauseableTimer》</a>。</p>
<p>为了避免手动发射弹幕和自动发射队列中的弹幕出现冲突（弹幕重叠），所有弹幕通过 <code>taskTimer</code> 定时任务统一调度。</p>
<h2 id="下一步-Next-Step"><a href="#下一步-Next-Step" class="headerlink" title="下一步 Next Step"></a>下一步 Next Step</h2><p>现在流行的弹幕功能越来越复杂、高级，DanmuManager 只是完成了最基础的滚动文字弹幕功能。未来可能会学习常见的弹幕，添加一些更高级的功能，比如 对滚动弹幕的操作，居中弹幕 等。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目首页： &lt;a href=&quot;https://github.com/cheng-kang/DanmuManager&quot;&gt;DanmuManager Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方法-Usage&quot;&gt;&lt;a href=&quot;#使用方法-Usage&quot; class=&quot;headerlink&quot; title=&quot;使用方法 Usage&quot;&gt;&lt;/a&gt;使用方法 Usage&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DanmuManager&lt;/code&gt; 和 &lt;code&gt;VideoDanmuManager&lt;/code&gt; 有不同的应用场景，后者用于视频弹幕。&lt;/p&gt;
&lt;p&gt;你可以运行项目中的测试，来了解二者的使用方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Pauseable Timer 一个可暂停的计时器</title>
    <link href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    <id>http://chengkang.me/2017/01/05/PauseableTimer 一个可暂停的计时器/</id>
    <published>2017-01-05T15:31:35.000Z</published>
    <updated>2017-01-05T13:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目主页: <a href="https://github.com/cheng-kang/PauseableTimer" target="_blank" rel="external">PauseableTimer Github Repository</a><br>英文介绍： <a href="http://chengkang.me/2017/01/04/Pauseable%20Timer/">Pauseable Timer</a></p>
</blockquote>
<p>PauseableTimer 是一个用 Swift 写的可暂停的计时器。</p>
<p>有时候我们需要暂停计时器，但是这个功能在 Timer(Swift3) 中并没有被实现。因此，经过一些失败的尝试，我创建了这个可以暂停的计时器，希望对你也有用。</p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif" alt=""></p>
<a id="more"></a>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol>
<li><p>创建一个计时器 Timer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let timer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: aSelector, userInfo: nil, repeats: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个可暂停的计时器 PauseableTimer，并将之前创建的 Timer 作为参数传入 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let pauseableTimer = PauseableTimer(timer: timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停 然后 重新开始！</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">pauseableTimer.pause()</span><br><span class="line">pauseableTimer.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>如果用于初始化 PauseableTimer 的 Timer 不是通过 scheduledTimer 方法初始化的或没有被加入到 RunLoop 中，那么你需要手动将它加入到 RunLoop 中。你可以这样做，<code>RunLoop.current.add(timer, forMode: .commonModes)</code>。</li>
<li>如果你需要操作用于初始化 PauseableTimer 的 Timer 或者需要获取它的属性，请使用 PauseableTimer 的 <code>timer</code> 属性。就像这样，<code>pauseableTimer.timer.firedate = Date()</code>。</li>
<li><code>invalidate()</code> 方法是为便于手动让 timer 失效而创建的。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PauseableTimer 并没有重新实现 Swift 中的 Timer，而是将 Timer 作为一个属性然后在它的帮助下实现了 暂停 的功能。</p>
<p>这个功能的原理受到 <a href="http://www.jianshu.com/p/e554a164d0da" target="_blank" rel="external">NSTimer 总结1(包括计时器不准的解决)</a> 的启发。 </p>
<p>主要思想是 <code>当你需要暂停的时候，将 Timer 的 firedate 设置为一个无法达到的日期（这样计时器会一直等待，感觉起来就像是暂停了 :D）；当你需要重新开始的时候，将 firedate 设置回原来的时间（这样计时器就可以『照常』触发）</code>。 </p>
<p>简单聪明！</p>
<p>你可能注意到了加了引号的『照常』。事实上，这个方法可能无法达到你的期望，因为</p>
<ol>
<li><p>Firedate 过期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">现在的时间是 2017.01.04 10:25。</span><br><span class="line">原本的 firedate 是 2017.01.04 10:30。</span><br><span class="line">你现在暂停了这个计时器，并且在十分钟后（2017.01.04 10:35）重新开始。这时，计时器已经错过了它预计的 firedate（2017.01.04 10:30）。</span><br><span class="line">然而，如果这个计时器已经在 RunLoop 当中的话，当你在 2017.01.04 10:35 将 firedate 设置回 2017.01.04 10:30 时，计时器会立即触发一次。</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们希望计时器继续等待剩下的等待时间。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">现在的时间是 2017.01.04 10:25:00。</span><br><span class="line">计时器的 timeInterval 是 60 秒。现在计时器被加入到 RunLoop，它应该在 60 秒后触发，也就是在 2017.01.04 10:26:00。</span><br><span class="line">然后你因为某种原因在 10 秒后暂停了它，也就是在 2017.01.04 10:25:10。你在 2017.01.04 10:25:50 的时候重新开始了计时器。</span><br><span class="line">不过，你仍然希望它是在设置好后，等待 60 秒再触发，不管暂停的那段时间。所以它应该再等待 50 秒，然后在 2017.01.04 10:26:40 触发。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完美的解决方案应该是满足以上所述三种情况的（另一种情况是我们不在乎原始 firedate 是否过期）。不过，这个项目目前只解决了第二个情况，因为这是我在其他项目中所遇到的需要解决的问题。</p>
<p>未来我可能会继续这个小项目，然后将每一种情况的解决方案都完善起来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/cheng-kang/PauseableTimer&quot;&gt;PauseableTimer Github Repository&lt;/a&gt;&lt;br&gt;英文介绍： &lt;a href=&quot;http://chengkang.me/2017/01/04/Pauseable%20Timer/&quot;&gt;Pauseable Timer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PauseableTimer 是一个用 Swift 写的可暂停的计时器。&lt;/p&gt;
&lt;p&gt;有时候我们需要暂停计时器，但是这个功能在 Timer(Swift3) 中并没有被实现。因此，经过一些失败的尝试，我创建了这个可以暂停的计时器，希望对你也有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Pauseable Timer</title>
    <link href="http://chengkang.me/2017/01/04/Pauseable%20Timer/"/>
    <id>http://chengkang.me/2017/01/04/Pauseable Timer/</id>
    <published>2017-01-04T22:58:48.000Z</published>
    <updated>2017-01-05T13:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Project Page: <a href="https://github.com/cheng-kang/PauseableTimer" target="_blank" rel="external">PauseableTimer Github Repository</a></p>
<p>Chinese Version: <a href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/">《Pauseable Timer 一个可暂停的计时器》</a></p>
</blockquote>
<p>Pauseable Timer is a pause-able timer written in Swift.</p>
<p>There are occassions when we need timers to pause, however, this feature is not implemented in Timer(Swift3). Thus, after some failed attempts, I create this pause-able timer which hopefully could be useful to you.</p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif" alt=""></p>
<a id="more"></a>
<h2 id="How-to-Use"><a href="#How-to-Use" class="headerlink" title="How to Use"></a>How to Use</h2><ol>
<li><p>Create a Timer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let timer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: aSelector, userInfo: nil, repeats: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a Pauseable Timer and pass the timer as an argument.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let pauseableTimer = PauseableTimer(timer: timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pause and Resume!</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">pauseableTimer.pause()</span><br><span class="line">pauseableTimer.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>Notice</strong></p>
<ul>
<li>If the timer you use to initialize a PauseableTimer is not scheduled (or added to RunLoop) already, you need to manually schedule it (ro add it to RunLoop). You can do it by <code>RunLoop.current.add(timer, forMode: .commonModes)</code>. </li>
<li>Use <code>timer</code> property of PauseableTimer if you need to manipulate the timer or get it’s properties. Like this <code>pauseableTimer.timer.firedate = Date()</code>.</li>
<li>A convinient method <code>invalidate()</code> is created to invalidate the timer.</li>
</ul>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Pauseable Timer does not re-implement Timer in Swift, but takes a Timer as a property and implement ‘Pause’ feature with the help of it.</p>
<p>The concept of this feature is inspired by <a href="http://www.jianshu.com/p/e554a164d0da" target="_blank" rel="external">NSTimer 总结1(包括计时器不准的解决)</a>. </p>
<p>The main idea is <code>set the firedate of Timer to a un-reachable date when you want it pause (the timer will wait until forever and you can take it as pausing :D), and set it back to its original firedate when you want it resume (and the timer will fire &quot;as expected&quot;).</code></p>
<p>Simple and Excellent!</p>
<p>You might have noticed the double qouted “as expected”. Acctually, this might fail your expectation because</p>
<ol>
<li><p>The firedate is expried.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">The current time is 2017.01.04 10:25.</span><br><span class="line">The original firedate is 2017.01.04 10:30.</span><br><span class="line">You pause the timer at this moment and resume it 10 mins after which is 2017.01.04 10:35. So the timer has missed it&apos;s expected firedate. </span><br><span class="line">However it will fire once you set the firedate back to 2017.01.04 10:30 at 2017.01.04 10:35, if the timer is already added to RunLoop.</span><br></pre></td></tr></table></figure>
</li>
<li><p>The timer is expected to wait for the remaining waiting time.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">The current time is 2017.01.04 10:25:00.</span><br><span class="line">The timeInterval of the timer is 60 seconds. It&apos;s scheduled at this moment, and should fire 60 seconds later at 2017.01.04 10:26:00.</span><br><span class="line">And for some reason you pause it 10 seconds after, which is 2017.01.04 10:25:10. And you resume the timer at 2017.01.04 10:25:50.</span><br><span class="line">However, you still want it to fire 60 seconds after it&apos;s scheduled, regardless the pausing part. So it should wait for 50 seconds more and fire at 2017.01.04 10:26:40.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>An ideal solution should be one that fits all 3 conditions (another one is the condition that someone doesn’t care if the original firedate is expired or not) discussed above. However, this project only deals with condition 2 because that is the problem I encountered with.</p>
<p>Hopefully, I will continue this small project in the future and complete it with solutions to every condition.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Project Page: &lt;a href=&quot;https://github.com/cheng-kang/PauseableTimer&quot;&gt;PauseableTimer Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Chinese Version: &lt;a href=&quot;http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/&quot;&gt;《Pauseable Timer 一个可暂停的计时器》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pauseable Timer is a pause-able timer written in Swift.&lt;/p&gt;
&lt;p&gt;There are occassions when we need timers to pause, however, this feature is not implemented in Timer(Swift3). Thus, after some failed attempts, I create this pause-able timer which hopefully could be useful to you.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】我最喜欢的 JavaScript 设计模式</title>
    <link href="http://chengkang.me/2016/07/02/my-favorite-javascript-pattern/"/>
    <id>http://chengkang.me/2016/07/02/my-favorite-javascript-pattern/</id>
    <published>2016-07-02T09:50:25.000Z</published>
    <updated>2016-07-02T02:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.sitepoint.com/my-favorite-javascript-design-pattern/" target="_blank" rel="external">My Favorite JavaScript Design Pattern</a></p>
</blockquote>
<h1 id="我最喜欢的-JavaScript-设计模式"><a href="#我最喜欢的-JavaScript-设计模式" class="headerlink" title="我最喜欢的 JavaScript 设计模式"></a>我最喜欢的 JavaScript 设计模式</h1><p>我觉得聊一下我爱用的 JavaScript 设计模式应该很有意思。我是一步一步才定下来的，经过一段时间从各种来源吸收和适应直到达到一个能提供我所需的灵活性的模式。</p>
<p>让我给你看看概览，然后再来看它是怎么形成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function MyScript()&#123;&#125;</span><br><span class="line">(function()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  var THIS = this;</span><br><span class="line"></span><br><span class="line">  function defined(x)</span><br><span class="line">  &#123;</span><br><span class="line">    return typeof x != &apos;undefined&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.ready = false;</span><br><span class="line"></span><br><span class="line">  this.init = function(</span><br><span class="line">  &#123;</span><br><span class="line">    this.ready = true;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.doSomething = function()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;;   </span><br><span class="line"></span><br><span class="line">  var options = &#123;</span><br><span class="line">      x : 123,</span><br><span class="line">      y : &apos;abc&apos;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  this.define = function(key, value)</span><br><span class="line">  &#123;</span><br><span class="line">    if(defined(options[key]))</span><br><span class="line">    &#123;</span><br><span class="line">      options[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;).apply(MyScript);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如你在实例代码中看到的，整体框架是一个函数直接量（function literal）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>函数直接量基本上就是一个自执行域，相当于定义一个有名的函数然后立即调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p>我最初开始使用函数直接量是为了<code>封装</code>——任何格式的任何脚本都可以被封装在那个闭包里，并且它有效地将它<code>密封</code>在私有域中，从而保护它不会与同一个域里的其它脚本或者数据冲突。在最后面的那一对括号就是在执行这个域，就像其它函数一样调用它。</p>
<p>但是如果，这个域通过使用 <code>Function.apply</code> 来执行而不是全局调用，这可以让它在一个可被外界引用的<em>特定命名</em>的域中执行。</p>
<p>因此通过结合二者——创建一个命名函数，然后在这个命名函数的域内执行一个函数直接量——我们就得到了一个一次性的可以构成任何脚本的基础的对象，它模拟了类似面向对象类的继承性质。</p>
<h2 id="内在之美"><a href="#内在之美" class="headerlink" title="内在之美"></a>内在之美</h2><p>看看第一个代码示例，你就能看到封闭域结构提供了什么样的灵活性。当然，这些你都可以在任何方法中做到，但是通过用这种方式包装起来，我们就有了一个可以和任何命名域联系起来的结构体。</p>
<p>我们可以创建多个这样的结构体，然后将它们和同一个域联系起来，这样它们之间全部可以共享它们的公开数据。</p>
<p>不过在共享公开数据的同事，每一个（结构体）也可以定义它自己的私有数据。下面是一个例子，在脚本的最上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var THIS = this;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个叫做 <code>THIS</code> 的私有变量，它指向这个函数域，并且可以在私有方法中使用——和用 <code>self = this</code> 来创建内部域是一样的招数。</p>
<p>通过同样方式声明的其他私有变量，如果他们定义常量数据的话，可以使用大写传统（不过用 <code>const</code> 而不是 <code>var</code> 来做声明的方式应该被避免，因为对它的支持不是很好）。</p>
<p>私有方法可以用来提供内部功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function defined(x)</span><br><span class="line">&#123;</span><br><span class="line">  return typeof x != &apos;undefined&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以创建其他实例或者外界可以访问的公开方法和属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.ready = false;</span><br><span class="line"></span><br><span class="line">this.init = function()</span><br><span class="line">&#123;</span><br><span class="line">  this.ready = true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.doSomething = function()</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以创建特殊的值——私有但是可以公开定义，在这个例子中是通过公开的 <code>define</code> 方法；它的参数可以根据数据需要再进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">  x : 123,</span><br><span class="line">  y : &apos;abc&apos;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">this.define = function(key, value)</span><br><span class="line">&#123;</span><br><span class="line">  if(defined(options[key]))</span><br><span class="line">  &#123;</span><br><span class="line">    options[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="封装起来！"><a href="#封装起来！" class="headerlink" title="封装起来！"></a>封装起来！</h2><p>所有的这些特点让这个结构体对我非常有用。并且它封装在一个整洁、自我执行的单例中——一个容易引用、整合和使用的一次性对象。</p>
<p>所以你怎么想？这个模式眼熟吗，或者你有什么其他喜欢用的？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.sitepoint.com/my-favorite-javascript-design-pattern/&quot;&gt;My Favorite JavaScript Design Pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;我最喜欢的-JavaScript-设计模式&quot;&gt;&lt;a href=&quot;#我最喜欢的-JavaScript-设计模式&quot; class=&quot;headerlink&quot; title=&quot;我最喜欢的 JavaScript 设计模式&quot;&gt;&lt;/a&gt;我最喜欢的 JavaScript 设计模式&lt;/h1&gt;&lt;p&gt;我觉得聊一下我爱用的 JavaScript 设计模式应该很有意思。我是一步一步才定下来的，经过一段时间从各种来源吸收和适应直到达到一个能提供我所需的灵活性的模式。&lt;/p&gt;
&lt;p&gt;让我给你看看概览，然后再来看它是怎么形成的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function MyScript()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var THIS = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function defined(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return typeof x != &amp;apos;undefined&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.ready = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.init = function(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.ready = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.doSomething = function()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      x : 123,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      y : &amp;apos;abc&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.define = function(key, value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(defined(options[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      options[key] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).apply(MyScript);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Design Pattern" scheme="http://chengkang.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript 命名空间</title>
    <link href="http://chengkang.me/2016/06/28/javascript-namespace-by-michaux/"/>
    <id>http://chengkang.me/2016/06/28/javascript-namespace-by-michaux/</id>
    <published>2016-06-28T15:07:58.000Z</published>
    <updated>2016-06-28T08:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://peter.michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">《JavaScript Namespacing》</a></p>
</blockquote>
<h1 id="JavaScript-命名空间"><a href="#JavaScript-命名空间" class="headerlink" title="JavaScript 命名空间"></a>JavaScript 命名空间</h1><p>JavaScript 中有很多可以给你的对象安全分配命名空间的方法。这篇文章讨论我见过的普遍的实践。</p>
<h2 id="前缀命名空间"><a href="#前缀命名空间" class="headerlink" title="前缀命名空间"></a>前缀命名空间</h2><p>如果命名空间的目的是避免冲突的话。下面这个系统，只要我们知道全局变量名前缀 <em>myApp_</em> 是唯一的，可以像其他系统一样避免命名空间冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// add uniquely named global properties</span><br><span class="line">var myApp_sayHello = function() &#123;</span><br><span class="line">  alert(&apos;hello&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var myApp_sayGoodbye = function() &#123;</span><br><span class="line">  alert(&apos;goodbye&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// use the namespace properties</span><br><span class="line">myApp_sayHello();</span><br></pre></td></tr></table></figure>
<p>C 语言程序经常使用前缀命名空间。在 JavaScript 的世界中，你可能会碰见 Macromedia 的 MM_ 方法，例如 MM_showHideLayers。</p>
<p>我认为前缀命名空间是 JavaScript 中最清楚明白的命名空间系统。（下面的对象命名空间策略在加入了 <code>this</code> 关键字后会导致困惑。）</p>
<p>前缀命名空间的确创建了很多全局对象。这对于前缀用来避免的命名空间冲突并不是什么问题。前缀命名空间的问题是，有些网页浏览器（例如 IE6）在有很多全局对象时表现很糟糕，就我所听说。我做了一些测试并且发现有一个 comp.lang.javascript 的小线程，不过我没有就这个话题研究彻底。</p>
<a id="more"></a>
<h2 id="单对象命名空间"><a href="#单对象命名空间" class="headerlink" title="单对象命名空间"></a>单对象命名空间</h2><p>当下，最流行的 JavaScript 命名空间实践是使用一个全局变量来引用一个对象。这个被引用的对象引用你的『真正的业务』，并且因为你的全局对象的命名独一无二，你的代码和其他人的代码就可以一起嗨皮地运行。</p>
<p>如果你确定这个世界上没有任何人用了这个全局变量名 <em>myApp</em>，那么你可以有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// define the namespace object</span><br><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// add properties to the namespace object</span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(&apos;hello&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">myApp.sayGoodbye = function() &#123;</span><br><span class="line">  alert(&apos;goodbye&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// use the namespace properties</span><br><span class="line">myApp.sayHello();</span><br></pre></td></tr></table></figure>
<p>当上面代码的最后一行执行时，JavaScript 解释器首先找到 <em>myApp</em> 对象，然后找到并调用这个对象的 <em>syaHello</em> 属性。</p>
<p>对象命名空间的一个问题是它会导致与面向对象消息传递混淆。这两者之间并没有明显的句法差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">namespace.prop();</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">receiver.message();</span><br></pre></td></tr></table></figure>
<p>更仔细地研究这个混淆，我们得出下面的命名空间想法。假设我们有以下库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.message = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(myApp.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个库的代码可以随意进行写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.sayHello(); // works</span><br><span class="line">  </span><br><span class="line">var importedfn = myApp.sayHello;</span><br><span class="line"></span><br><span class="line">importedfn(); // works</span><br></pre></td></tr></table></figure>
<p>将这个和那个令人混淆的使用 <code>this</code> 的消息传递版本比较一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.message = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(this.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个库的代码可以随意进行写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.sayHello() // works because &quot;this&quot; refers to myApp object.</span><br><span class="line"></span><br><span class="line">var importedfn = myApp.sayHello;</span><br><span class="line"></span><br><span class="line">importedfn(); // error because &quot;this&quot; refers to global object.</span><br></pre></td></tr></table></figure>
<p>这里面的要上的一课是，<code>this</code> 永远不能引用一个被作为命名空间的对象因为它肯能导致关于从命名空间引入标识符的混淆。这个问题是 <code>this</code> 在我的 <a href="http://peter.michaux.ca/article/7933" target="_blank" rel="external">JavaScript Warning Words</a> 列表中的原因之一。</p>
<p>（这也表明了库的 API 属性应该指向用一个方法，这样这些方法可以被导入其他命名空间。这个问题是在我的文章 <a href="http://peter.michaux.ca/article/3556" target="_blank" rel="external">Lazy Function Definition Pattern</a> 的评论中被指出的。懒惰方法定义可以在被隐藏在库中并且不是 API 的部分时安全使用。）</p>
<h2 id="嵌套对象命名空间"><a href="#嵌套对象命名空间" class="headerlink" title="嵌套对象命名空间"></a>嵌套对象命名空间</h2><p>嵌套对象命名空间是另一个普遍的实践，它扩展了对象命名空间的想法。你可能见过类似如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO.util.Event.addListener(/*...*/)</span><br></pre></td></tr></table></figure>
<p>解决上面的代码需要解释器首先找到全聚德 <em>YAHOO</em> 对象，然后它的 <em>util</em> 对象，然后它的 <em>Event</em> 对象，然后找到并调用它的 <em>addListener</em> 属性。这样的话每次事件处理器绑定到一个 DOM 元素上花的功夫太多了，因此导入的概念开始被采用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var yue = YAHOO.util.Event;</span><br><span class="line">  yue.addListener(/*...*/);</span><br><span class="line">  yue.addListener(/*...*/);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果你清楚 <em>YAHOO.util.Event.addListener</em> 方法不会用 <code>this</code> 关键字并且永远引用同一个方法，那么导入可以变得更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var yuea = YAHOO.util.Event.addEventListener;</span><br><span class="line">  yuea(/*...*/);</span><br><span class="line">  yuea(/*...*/);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我觉得当目的只是避免标识符冲突时，嵌套对象命名空间的复杂是不必要的。难道 Yahoo! 还觉得这些全局标识符 YAHOO_util_Event 和 YAHOO_util_Event_addEventListener 不够独特吗？</p>
<p>我认为使用嵌套对象命名空间的动机是要看起来和 Java 包命名传统一样，这在 Java 中开销不大。例如，在 Java 中你可能看到如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package mytools.text;</span><br><span class="line"></span><br><span class="line">class TextComponent &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个这个类的完全合格的引用应该是 <code>mytools.text.TextComponent</code>。</p>
<p>下面是 Niemeyer 和 Knudsen （写）的 <em>Learning Java</em> 中包命名的描述：</p>
<blockquote>
<p>包名是按层级构成的，使用点分隔的命名传统。包名组成成分给编译器和运行系统构成了独一无二的定位文件的路径。然而，它们并没在包之间创建其他的关系。并没有什么『subpackage』的说法，事实上，包命名空间是直接的，而非层级的。在包层级关系特定部分的包仅仅是因为习惯而有关联。比如，如果我们穿件了另一个叫做 <em>mytools.text.poetry</em> 的包（假设是为了跟诗有关的一些文字类），这些类并不是 <em>mytools.text</em> 包的一部分；它们没有包成员的访问权限。</p>
</blockquote>
<p>嵌套命名空间的幻觉在 Perl 中也存在。在 Perl 中，嵌套包名由双冒号分隔开。你可以看到如下 Perl 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package Red::Blue;</span><br><span class="line">our $var = &apos;foo&apos;;</span><br></pre></td></tr></table></figure>
<p>一个完全合格的上述变量引用应该是 <em>$Red::Blue::var</em>。</p>
<p>在 Perl 中，就像 Java，命名空间层级的主意只是方便程序员，而不是语言本身要求。Wall，Christiansen 和 Orwant 的 <em>Programming Perl</em> 解释道：</p>
<blockquote>
<p>双冒号可被用于链接在包名 <em>$Red::Blue::var</em> 中标识符。这意味着 <em>$var</em> 属于包 <em>Red::Blue</em>。包 <em>Red::Blue</em> 跟可能存在的 <em>Red</em> 包或 <em>Blue</em> 包一点关系都没有。只是说，<em>Red::Blue</em> 和 <em>Red</em> 或者 <em>Blue</em> 之间的关系可能对于写代码或者使用这个程序的人有什么意义，但跟 Perl 没关系。（好吧，除了在现在的实现中，符号表 <em>Red::Blue</em> 刚好存在符号表 <em>Red</em> 中。但是 Perl 语言并没有直接利用过它。）</p>
</blockquote>
<p>上述引用中最后备注暗示了 Perl 可能有和在 JavaScript 中使用嵌套命名空间对象一样的标识符冲突开销。如果 Perl 的实现改变了，这个开销就会消失。在 JavaScript 中，我肯定嵌套对象命名空间的开销永远不会消失因为 JavaScript 使用延迟绑定。</p>
<p>我并不认为 JavaScript 中的嵌套对象命名空间提供了任何大好处，不过如果不使用导入的话在运行时可能会开销非常大。</p>
<h2 id="一个折中方案"><a href="#一个折中方案" class="headerlink" title="一个折中方案"></a>一个折中方案</h2><p>如果单纯地前缀命名空间在某些浏览器中真的很慢，而嵌套命名空间的概念帮助在开发者脑中保持各事务的有序，那我认为上述 Yahoo! 的例子也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO.util_Event_addListener</span><br></pre></td></tr></table></figure>
<p>或者用更多的全局名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO_util_Event.addListener</span><br></pre></td></tr></table></figure>
<h2 id="哪个维度的命名空间？"><a href="#哪个维度的命名空间？" class="headerlink" title="哪个维度的命名空间？"></a>哪个维度的命名空间？</h2><p>Perl 的 CPAN 模块是基于他们所做的事情进行命名空间管理的。例如，我写了一个这个命名空间里的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript::Minifier</span><br></pre></td></tr></table></figure>
<p>如果别人用同样的名字写他自己的模块，并且他不自知地通过某些模块依赖通过同一个名字使用 CPAN 模块，那么就会有冲突。</p>
<p>Java 程序员采用最冗长但当然也是最安全的方法。（Java 程序员似乎都想着在大型系统上运行的代码。）在 Java 中，包经常是基于<strong>谁写的</strong>和<strong>做什么的</strong>来命名。（<em>myFunc</em>风格的规范化。）『谁写的』部分甚至使用开发者自己的相对可以保证唯一性的名字。如果我写一个 Java 的 minifier，因为我有 michaux.ca 的域名，我可能用以下命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca.michaux.javascript.minifier</span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，经过这次讨论，可能这样写效率更高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca_michaux_javascript_minifier</span><br></pre></td></tr></table></figure>
<p>因为 JavaScript 是以文本的形式服务的，这样的命名空间可能开销太大，因为增加了下载时间。Gzip 压缩会找到公共的字符串并用短字符串替换它们。如果 gzip 不可用的话那么就可以考虑使用导入了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ca_michaux_javascript_minifier = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(function() &#123;</span><br><span class="line">  var cmjm = ca_michaux_javascript_minifier;</span><br><span class="line">  </span><br><span class="line">  // refer to cmjm inside this module pattern</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我并不是说这些长的命名空间是绝对必须的，不过他们一定是避免命名空间冲突的最安全方法。</p>
<h2 id="其他命名空间问题"><a href="#其他命名空间问题" class="headerlink" title="其他命名空间问题"></a>其他命名空间问题</h2><p>标识符不仅在 JavaScript 资源中创建。一个表单的 name 属性也被加在 <em>document.forms</em> 对象上。像 <em><form name="myCompany_login"></form></em> 这样命名是有意义的。</p>
<p>命名空间类名属性，比如 <em>&lt;div class=”myCompany_story”&gt;</em>，可以在减少 CSS 命名空间冲突以及当 JavaScript 代码在通过类名搜索 DOM 元素时很有价值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人认为，任何像 <em>YAHOO.util.Event.addListener</em> 这样有点或者下划线的东西都是被冲突吓傻了的。它可以就是 <em>YUI.on</em>。Dojo 通过同样功能的 dojo.connect 提供了足够的保护，因为它有效地涵盖了命名空间『谁』和『做什么』的维度。没有人会在他们的右脑中会这样想并在 dojo 命名空间下写一个 JavaScript 库。Dojo 的开发人员也不会忘记他们已经有了一个 connect 方法并写另外一个。</p>
<p>如果我们能有一个网站来让程序员们保存他们的 JavaScript 全局标识符和下划线前缀，并且当 ECMAScipt4 发布了的时候也包括他们的包名，就好了：『JavaScript 命名空间登记处』。</p>
<p>JavaScript 是一个最小概念集的强大语言。即使 JavaScript 并没有专门为避免命名空间冲突设计的语言级支持，还是有很多解决问题的方法。并没有一个『正确』的答案。选一个你最喜欢的。</p>
<p>不过，无论你做什么，请记住别弄一个另外的全局 $ 标识符。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="http://groups.google.com/group/comp.lang.javascript/browse_frm/thread/494e1757fa51fe3f" target="_blank" rel="external">comp.lang.javascript discussion on namespacing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://peter.michaux.ca/articles/javascript-namespacing&quot;&gt;《JavaScript Namespacing》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 命名空间&quot;&gt;&lt;/a&gt;JavaScript 命名空间&lt;/h1&gt;&lt;p&gt;JavaScript 中有很多可以给你的对象安全分配命名空间的方法。这篇文章讨论我见过的普遍的实践。&lt;/p&gt;
&lt;h2 id=&quot;前缀命名空间&quot;&gt;&lt;a href=&quot;#前缀命名空间&quot; class=&quot;headerlink&quot; title=&quot;前缀命名空间&quot;&gt;&lt;/a&gt;前缀命名空间&lt;/h2&gt;&lt;p&gt;如果命名空间的目的是避免冲突的话。下面这个系统，只要我们知道全局变量名前缀 &lt;em&gt;myApp_&lt;/em&gt; 是唯一的，可以像其他系统一样避免命名空间冲突。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// add uniquely named global properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myApp_sayHello = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(&amp;apos;hello&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myApp_sayGoodbye = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(&amp;apos;goodbye&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// use the namespace properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp_sayHello();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;C 语言程序经常使用前缀命名空间。在 JavaScript 的世界中，你可能会碰见 Macromedia 的 MM_ 方法，例如 MM_showHideLayers。&lt;/p&gt;
&lt;p&gt;我认为前缀命名空间是 JavaScript 中最清楚明白的命名空间系统。（下面的对象命名空间策略在加入了 &lt;code&gt;this&lt;/code&gt; 关键字后会导致困惑。）&lt;/p&gt;
&lt;p&gt;前缀命名空间的确创建了很多全局对象。这对于前缀用来避免的命名空间冲突并不是什么问题。前缀命名空间的问题是，有些网页浏览器（例如 IE6）在有很多全局对象时表现很糟糕，就我所听说。我做了一些测试并且发现有一个 comp.lang.javascript 的小线程，不过我没有就这个话题研究彻底。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://chengkang.me/tags/Namespacing/"/>
    
      <category term="Namespace" scheme="http://chengkang.me/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript 中的命名空间</title>
    <link href="http://chengkang.me/2016/06/21/Namespacing%20in%20JavaScript/"/>
    <id>http://chengkang.me/2016/06/21/Namespacing in JavaScript/</id>
    <published>2016-06-21T20:59:30.000Z</published>
    <updated>2016-06-28T08:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接： <a href="https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/" target="_blank" rel="external">Namespacing in JavaScript</a></p>
</blockquote>
<h1 id="JavaScript-中的命名空间"><a href="#JavaScript-中的命名空间" class="headerlink" title="JavaScript 中的命名空间"></a>JavaScript 中的命名空间</h1><p>全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。</p>
<p>不过，恩，这些你早都知道了……</p>
<p>所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 <a href="http://www.brothercake.com/" target="_blank" rel="external">James Edwards</a> 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。<br><a id="more"></a></p>
<h2 id="静态命名空间"><a href="#静态命名空间" class="headerlink" title="静态命名空间"></a>静态命名空间</h2><p>我用<code>静态命名空间</code>作为那些命名空间标签实际上硬编码的解决方案的涵盖性术语。是的，你可以将一个命名空间重新分配给另一个，不过新的命名空间将会引用和旧的那一个同样的对象。</p>
<h3 id="1-通过直接分配"><a href="#1-通过直接分配" class="headerlink" title="1.通过直接分配"></a>1.通过直接分配</h3><p>最基础的方法。这样非常冗长，并且如果你还想重命名这些命名空间，你就有得活儿干了。不过它是安全和清楚明白的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;</span><br><span class="line">myApp.id = 0;</span><br><span class="line">myApp.next = function() &#123;</span><br><span class="line">    return myApp.id++;  </span><br><span class="line">&#125;</span><br><span class="line">myApp.reset = function() &#123;</span><br><span class="line">    myApp.id = 0;   </span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>你也可以通过使用<code>this</code>引用兄弟属性来使将来的维护更轻松一些，不过这有一点冒险因为没有什么能阻止你的那些命名空间里的方法被重新分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;</span><br><span class="line">myApp.id = 0;</span><br><span class="line">myApp.next = function() &#123;</span><br><span class="line">    return this.id++;   </span><br><span class="line">&#125;</span><br><span class="line">myApp.reset = function() &#123;</span><br><span class="line">    this.id = 0;    </span><br><span class="line">&#125;</span><br><span class="line">myApp.next(); //0</span><br><span class="line">myApp.next(); //1</span><br><span class="line">var getNextId = myApp.next;</span><br><span class="line">getNextId(); //NaN whoops!</span><br></pre></td></tr></table></figure>
<h3 id="2-使用对象字面量"><a href="#2-使用对象字面量" class="headerlink" title="2.使用对象字面量"></a>2.使用对象字面量</h3><p>现在我们只需要引用命名空间名一次，因此之后改变名字更简单了一些（假设你还没反复引用这个命名空间）。仍有一个危险是<code>this</code>的值可能会抛出一个『惊喜』 - 不过假设在一个对象字面结构里定义的对象不会被重新分配相对安全一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;</span><br><span class="line">    id: 0,</span><br><span class="line">    next: function() &#123;</span><br><span class="line">        return this.id++;   </span><br><span class="line">    &#125;,</span><br><span class="line">    reset: function() &#123;</span><br><span class="line">        this.id = 0;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<h3 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h3><p>我发现自己最近用<code>模块模式</code>更多。逻辑被一个方法包装从全局域隔离开了（通常是自调用的），它返回一个代表这个模块公开接口的对象。通过立即调用这个方法并分配结果给一个命名空间变量，我们就锁住了这个命名变量中模块的 API。此外，任何没有包括在返回值中的变量将永远保持私有，只对引用他们的公开方法可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myApp = (function() &#123;</span><br><span class="line">    var id= 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return id++;    </span><br><span class="line">        &#125;,</span><br><span class="line">        reset: function() &#123;</span><br><span class="line">            id = 0;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;)();   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>如上对象字面量例子，命名空间名字可以轻易更换，不过还有额外优势：对象字面量是四班的 - 它全是关于属性分配，没有支持逻辑的空间。此外，所有属性必须被初始化，并且属性值无法轻易跨对象引用（因此，比如，内部闭包就不可能使用了）。模块模式没有任何上述约束，并且给我们额外的隐私福利。</p>
<h2 id="动态命名空间"><a href="#动态命名空间" class="headerlink" title="动态命名空间"></a>动态命名空间</h2><p>我们也可以将这一节称为<code>命名空间注入</code>。命名空间由一个直接引用方法包装<code>内部</code>的代理代表 - 这意味着我们不再需要打包分配给命名空间的返回值。这让命名空间定义变得更灵活并且让拥有多个存在于独立命名空间中（或者甚至在全局上下文中）的模块的独立实例。动态命名空间支持模块模式的全部特征并附加直观和可读性强的优势。</p>
<h3 id="4-提供命名空间参数"><a href="#4-提供命名空间参数" class="headerlink" title="4.提供命名空间参数"></a>4.提供命名空间参数</h3><p>在这里我们只是将命名空间作为参数传给自调用方法。变量<code>id</code>是私有的，因为他并没有被分配给<code>context</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id = 0;</span><br><span class="line">    context.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    context.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(myApp);  </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>我们甚至可以把<code>context</code>设置给全局对象（通过一个字的改变！）。这是库主们的巨大财富 - 他们可以将他们的特性包装在一个自调用函数中，然后让用户来决定它们是不是全局的（John Resig 在他写 JQuery 时就是一个这个理论的早期采用者）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id = 0;</span><br><span class="line">    context.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    context.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this);   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<h3 id="5-用this作为命名空间代理"><a href="#5-用this作为命名空间代理" class="headerlink" title="5.用this作为命名空间代理"></a>5.用<code>this</code>作为命名空间代理</h3><p><a href="http://www.brothercake.com/" target="_blank" rel="external">James Edwads</a> 最近发布的一篇文章激起了我的兴趣。<a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/" target="_blank" rel="external">《My Favorite JavaScript Design Patter》</a> 显然被很多评论者误解了，他们认为他可能也是借助于模块模式。这篇文章宣传了多种技术（可能导致了读者的迷惑），但是在它的核心部分是一点我已经修改并呈现为一个命名空间工具的很天才的东西。</p>
<p>这个模式的美就在于它仅仅是按照这个语言被设计的方式使用 - 不多不少、不投机也不取巧。此外因为命名空间是通过<code>this</code>关键字（它在给定的执行上下文中是不变的）注入的，它不可能被意外修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var id = 0;</span><br><span class="line"> </span><br><span class="line">    this.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).apply(myApp);    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>更棒的是，<code>apply</code>（以及<code>call</code>） API 提供了与上下文和参数天然的隔离 - 因此给模块创建者传递附加参数非常干净。下面的例子表明了这一点，并且展示了如何独立于多个命名空间来运行模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var subsys1 = &#123;&#125;, subsys2 = &#123;&#125;;</span><br><span class="line">var nextIdMod = function(startId) &#123;</span><br><span class="line">    var id = startId || 0;</span><br><span class="line">    this.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">nextIdMod.call(subsys1);    </span><br><span class="line">nextIdMod.call(subsys2,1000);   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.reset(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.next()</span><br><span class="line">) //0, 1, 1000, undefined, 1001, 0</span><br></pre></td></tr></table></figure>
<p>当然如果我们如果我们需要一个全局 id 生成器，非常简单……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nextIdMod();    </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>这个我们作为例子使用的 id 生成器工具并没有表现出这个模式的全部潜力。通过包裹一整个库和使用<code>this</code>关键字作为命名空间的替身，我们使得用户在任何他们选择的上下文中运行这个库很轻松（包括全局上下文）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//library code</span><br><span class="line">var protoQueryMooJo = function() &#123;  </span><br><span class="line">    //everything</span><br><span class="line">&#125;</span><br><span class="line">//user code</span><br><span class="line">var thirdParty = &#123;&#125;;</span><br><span class="line">protoQueryMooJo.apply(thirdParty);</span><br></pre></td></tr></table></figure>
<h2 id="其他的考虑"><a href="#其他的考虑" class="headerlink" title="其他的考虑"></a>其他的考虑</h2><p>我希望避免命名空间嵌套。它们很难追踪（对人和电脑都是）并且它们会让你的代码因为一些乱七八糟的东西变得很多。如 <a href="http://michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">Peter Michaux</a> 指出的，深度嵌套的命名空间可能是那些视图重新创建他们熟悉和热爱的长包链的老派 Java 开发者的遗产。</p>
<p>通过 .js 文件来固定一个单独的命名空间也是可以的（虽然只能通过命名空间注入或者直接分配每一个变量），不过你应该对依赖谨慎些。此外将命名空间绑定到文件上可以帮助读者更轻易弄清整个代码。</p>
<p>因为 JavaScript 并没有正式的命名空间结构，所以有很多自然形成的方法。这个调查只详细说明了其中的一部分，可能有更好的技术我没有发现。我很乐意知道它们。</p>
<h2 id="更多文章"><a href="#更多文章" class="headerlink" title="更多文章"></a>更多文章</h2><p>James Edwards： <a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/" target="_blank" rel="external">My Favorite JavaScript Design Pattern</a><br>Peter Michaux: <a href="http://michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">JavaScript Namespacing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/&quot;&gt;Namespacing in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-中的命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-中的命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的命名空间&quot;&gt;&lt;/a&gt;JavaScript 中的命名空间&lt;/h1&gt;&lt;p&gt;全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。&lt;/p&gt;
&lt;p&gt;不过，恩，这些你早都知道了……&lt;/p&gt;
&lt;p&gt;所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 &lt;a href=&quot;http://www.brothercake.com/&quot;&gt;James Edwards&lt;/a&gt; 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://chengkang.me/tags/Namespacing/"/>
    
      <category term="Namespace" scheme="http://chengkang.me/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>【译】Swift2 中的错误处理：try，catch，do 以及 throw</title>
    <link href="http://chengkang.me/2016/05/15/Swift2%20%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9Atry%EF%BC%8Ccatch%EF%BC%8Cdo%20%E4%BB%A5%E5%8F%8A%20throw/"/>
    <id>http://chengkang.me/2016/05/15/Swift2 中的错误处理：try，catch，do 以及 throw/</id>
    <published>2016-05-15T22:14:40.000Z</published>
    <updated>2016-05-15T15:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch" target="_blank" rel="external">《Error handling in Swift 2: try, catch, do and throw》</a></p>
</blockquote>
<p>如果你已经看了我那篇讨论 Swift2 中所有新东西的文章并且想了解更多关于新的错误处理系统的东西，这篇文章非常合适。简单来说，它已经被完全重写得现代化，快速和安全，并且除非你只使用 iOS API 的一小部分的话，你需要花些时间来学习一下。</p>
<p>如果你喜欢这篇文章，你可能也会想读读这些：</p>
<ul>
<li><a href="https://www.hackingwithswift.com/swift2-2" target="_blank" rel="external">What’s new in Swift 2.2?</a></li>
<li><a href="https://www.hackingwithswift.com/ios9" target="_blank" rel="external">What’s new in iOS 9?</a></li>
<li><a href="https://www.hackingwithswift.com/" target="_blank" rel="external">My free Swift tutorial series</a></li>
<li><a href="https://gum.co/proswift" target="_blank" rel="external">Pre-order Pro Swift for just $20!</a></li>
</ul>
<h3 id="过去是怎样：NSError-和-NSErrorPointer"><a href="#过去是怎样：NSError-和-NSErrorPointer" class="headerlink" title="过去是怎样：NSError 和 NSErrorPointer"></a>过去是怎样：NSError 和 NSErrorPointer</h3><p>用于处理错误的历史方法是通过使用一个作为指针传递的 NSError 对象。在 Objective-C 中，它是 NSError*，但在 Swift 中你会看到 NSError？ 和 NSErrorPointer。</p>
<a id="more"></a>
<p>当你调用一个可能失败的方法，你要传递一个空 NSError 作为参数，如果有问题的话这个参数就会被赋值。这让方法的返回值是你真正关心的那个数据。例如，在 Swift1.2 中，从硬盘加载一个 NSString 看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var err: NSError?</span><br><span class="line">let contents = NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding, error: &amp;err)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // uh-oh!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种编程风格在 Cocoa 中非常广泛，或者说至少：Swift2 完全不这么干，所以上面的代码要么要重写要么就移除掉。</p>
<p>至于为什么，有很多原因。例如，用上面的调用方法，很容易就忽略了错误，要么是没有检查 err 的值，要么是根本就没用 NSError 而是直接传递了一个 nil。</p>
<p>虽然 Swift2 中的新错误处理需要多费点功夫，但是它让程序员阅读起来清楚明白得多，它抛弃了那些复杂的东西例如用 &amp; 来传递 NSError，并且它通过保证你捕获所有错误来给你更高的安全性。</p>
<h3 id="Swift2-中的方法：try，catch，do-以及-throw"><a href="#Swift2-中的方法：try，catch，do-以及-throw" class="headerlink" title="Swift2 中的方法：try，catch，do 以及 throw"></a>Swift2 中的方法：try，catch，do 以及 throw</h3><p>当你导入一个 Swift1.2 项目到 Xcode7 时，你会被问道是否想要将它转换成最新的 Swift 语法。它并不能生成和你手写的一模一样的代码，但是它能帮你解决很大一部分工作，这样你就差不多确定要去使用它了。</p>
<p>在上面那个从文件中加载字符串的例子中，它会将其转化为 Swift2 版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let contents: NSString?</span><br><span class="line">do &#123;</span><br><span class="line">    contents = try NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding)</span><br><span class="line">&#125; catch _ &#123;</span><br><span class="line">    contents = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里展示了五个你需要学习的新关键字其中三个。当然，严格来说有一个不新，不过它的用法是新的：do 之前使用在 do … while 循环中，不过为了避免混淆，在 Swift2 中，它已经被重命名为 repeat … while。</p>
<p>第四和第五个关键字是 throw 和 throws，我们现在来更深入地看看。</p>
<p>请创建一个新的 Xcode 项目，用单视图应用模板。随便命个名，随便选个目标设备 - 都没关系，因为我们这次不做任何跟视图有关的东西。</p>
<p>选择 ViewController.swift 并且添加这个新方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func encryptString(str: String, withPassword password: String) -&gt; String &#123;</span><br><span class="line">    // complicated encryption goes here</span><br><span class="line">    let encrypted = password + str + password</span><br><span class="line">    return String(encrypted.characters.reverse())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法会用传递进来的密码加密一个字符串。当然，它不会自动就这样做 - 这篇文章不是关于加密的，所以我的『加密』算法很悲剧：它将密码添加在输入的字符串前后，然后翻转这个字符串。你之后可以随意加上复杂的加密算法。</p>
<p>修改 viewDidLoad() 来调用这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let encrypted = encryptString(&quot;secret information!&quot;, withPassword: &quot;12345&quot;)</span><br><span class="line">print(encrypted)</span><br></pre></td></tr></table></figure></p>
<p>你现在运行你的应用，你将看到在 Xcode 终端上打印出了『54321！noitamrofni terces54321』。很简单对吧。</p>
<p>但是有一个问题：假设你实际上设定了一个有意义的加密算法，你没办法阻止用户输入一个空字符串作为密码，或者输入明显的密码类似『password』，或者甚至尝试在没有任何可加密数据的情况下调用加密算法。</p>
<p>Swift2 来帮忙了：你可以告诉 Swift 当这个方法发现它自己处于一个不可接受的状态时，它可以抛出一个错误，例如如果密码是六位或者更少位。这些错误是由你定义的，然后 Swift 用某种办法来保证你捕获所有的错误。</p>
<p>首先，我们需要关键字 throws，你需要在定义你的方法时把它加在返回值前面，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func encryptString(str: String, withPassword password: String) throws -&gt; String &#123;</span><br><span class="line">    // complicated encryption goes here</span><br><span class="line">    let encrypted = password + str + password</span><br><span class="line">    return String(encrypted.characters.reverse())</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">一旦你这样做了，你的代码就会停止工作：添加 throws 命名让情况更糟了！不过它变糟了是因为一个好原因：Swift 中的 try/catch 系统被设计为对开发者清晰明了，这意味着你需要用关键字 try 标记所有可以抛出错误的方法，就像这样：</span><br></pre></td></tr></table></figure></p>
<p>let encrypted = try encryptString(“secret information!”, withPassword: “12345”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">…不过即使现在你的代码还是不能编译成功，因为你还没有告诉 Swift 当错误被抛出时要做什么。这就是关键字 do 和 catch 派上用场的地方：它们开始了一段可能运行失败的代码，并且处理那些失败。在我们的简单例子里，它可能看起来是这样：</span><br></pre></td></tr></table></figure></p>
<p>do {<br>    let encrypted = try encryptString(“secret information!”, withPassword: “12345”)<br>    print(encrypted)<br>} catch {<br>    print(“Something went wrong!”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样所有的错误都没了，你的代码又可以运行了。不过目前为止它实际上还没有做任何有意思的事情，因为即使我们说 encryptString() 可能抛出一个错误，它从没有真正发生。</span><br><span class="line"></span><br><span class="line">### 如何在 Swift2 中抛出错误</span><br><span class="line"></span><br><span class="line">在你可以抛出一个错误之前，你需要制作一个你要抛出的可能错误的列表。在我们这个例子中，我们要组织人们提供空密码，短密码和明显密码，不过之后你可以扩展它。</span><br><span class="line"></span><br><span class="line">要做到这些，我们需要创建一个枚举类型变量来代表我们错误的类型。这需要建立在内建的 ErrorType 枚举类型上，不过不管怎样都很简单。把这个加载 ViewController 类的前面：</span><br></pre></td></tr></table></figure></p>
<p>enum EncryptionError: ErrorType {<br>    case Empty<br>    case Short<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它定义了两个错误类型，然后我们可以马上开始用它们。因为它们是运行这个方法的前提条件，我们要用这个新关键字 guard 来使我们的意图清晰。</span><br><span class="line"></span><br><span class="line">把这个放在 encryptString() 前面：</span><br></pre></td></tr></table></figure></p>
<p>guard password.characters.count &gt; 0 else { throw EncryptionError.Empty }<br>guard password.characters.count &gt;= 5 else { throw EncryptionError.Short }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你现在运行应用，没有什么变化，因为我们在提供『12345』这个密码。不过如果你把它设置为一个空字符串，你会看到『Something went wrong！』在 Xcode 控制台打印出来了。</span><br><span class="line"></span><br><span class="line">当然，有一个错误信息帮助不是很大 - 因为这个方法调用时有多种方式失败，并且我们希望给每一种情况提供一些有意义的信息。所以，把 viewDidLoad() 中的 try/catch 代码块改成这样：</span><br></pre></td></tr></table></figure></p>
<p>do {<br>    let encrypted = try encryptString(“secret information!”, withPassword: “”)<br>    print(encrypted)<br>} catch EncryptionError.Empty {<br>    print(“You must provide a password.”)<br>} catch EncryptionError.Short {<br>    print(“Passwords must be at least five characters, preferably eight or more.”)<br>} catch {<br>    print(“Something went wrong!”)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">现在有了有意义的错误信息，我们的代码开始看起来更棒了。不过你可能注意到了，虽然我们已经捕获到了 .Empty 和 .Short 的情况，我们还需要第三个 catch 代码块。</span><br><span class="line"></span><br><span class="line">### Swift2 要求详尽无遗的 try/catch 错误处理</span><br><span class="line"></span><br><span class="line">如果你还记得的话，我说过『Swift 通过一些方式来保证你捕获到所有错误』，这里我们来说明清楚：我们已经能捕获所有我们定义的错误，但是 Swift 还希望我们定义一个一般的 catch all 来处理任何其他可能出现的错误。我们不用告诉 Swift 到底加密算法可能抛出哪种错误，只需要说明它会抛出某些错误，因此这个额外的 catch-all 代码块是必须的。</span><br><span class="line"></span><br><span class="line">有一个不好的地方：如果你新增任何值给枚举类型，它会直接进到默认的 catch 代码块 - 你不会被要求为它提供任何代码。</span><br><span class="line"></span><br><span class="line">我们将要给枚举类型加一个新的值来检测明显的密码。不过我们将要用 Swift 超强枚举类型这样我们可以返回一个带着错误类型的信息。因此，将 EncryptionError 枚举类型修改成这样：</span><br></pre></td></tr></table></figure></p>
<p>enum EncryptionError: ErrorType {<br>    case Empty<br>    case Short<br>    case Obvious(String)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在当你想要抛出一个 EncrytionError.Obvious 类型的错误是，你必须提供一个理由。</span><br></pre></td></tr></table></figure></p>
<p>guard password != “12345” else { throw EncryptionError.Obvious(“I’ve got the same passcode on my luggage!”) }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">显然你不想写无数个 guard 声明来过滤出明显的密码，不过如果你记得如何使用 UITextChecker 来做拼写检查的话，就很方便了。</span><br><span class="line"></span><br><span class="line">这就是完整的 Swift 基本 do/try/throw/catch 例子。你可能觉得 try 声明没什么用，不过他是作为一个信号告诉开发者『这个调用可能失败』。这很重要：当一个 try 调用失败了，执行立刻跳转到 catch 代码块，因此如果你看到一个调用之前的 try，它标志着底下的代码可能不会被执行。</span><br><span class="line"></span><br><span class="line">还有一个要说的事情就是，如果你知道一个调用就是不会失败你该怎么做。现在，很显然这是一个你需要根据情况来做的决定，不过如果你知道有一个方法绝对不可能调用失败或者如果它调用失败的你的代码就会完全崩溃，你可以使用 try! 来告诉 Swift。</span><br><span class="line"></span><br><span class="line">当你使用关键字 try!，你不需要用 do/catch 来包裹你的代码，因为你在保证它永远不会失败。你只需要这样写：</span><br></pre></td></tr></table></figure></p>
<p>let encrypted = try! encryptString(“secret information!”, withPassword: “12345”)<br>print(encrypted)<br>```<br>使用关键字 try! 清楚地表达了你的意图：你知道理论上这个调用可能失败，但是你确定它在你的用例中不会失败。例如，如果你从你的应用包中的文件中加载内容，任何失败意味着你的应用包被损坏了或者不可用，所以你需要终止应用。</p>
<p>这就是所有关于 Swift2 中错误处理的东西。如果你想学习 Swift 是怎样处理 try/finally，你应该读读我这篇<a href="https://www.hackingwithswift.com/new-syntax-swift-2-defer" target="_blank" rel="external">关于关键词 defer 的文章</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch&quot;&gt;《Error handling in Swift 2: try, catch, do and throw》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你已经看了我那篇讨论 Swift2 中所有新东西的文章并且想了解更多关于新的错误处理系统的东西，这篇文章非常合适。简单来说，它已经被完全重写得现代化，快速和安全，并且除非你只使用 iOS API 的一小部分的话，你需要花些时间来学习一下。&lt;/p&gt;
&lt;p&gt;如果你喜欢这篇文章，你可能也会想读读这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/swift2-2&quot;&gt;What’s new in Swift 2.2?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/ios9&quot;&gt;What’s new in iOS 9?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/&quot;&gt;My free Swift tutorial series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gum.co/proswift&quot;&gt;Pre-order Pro Swift for just $20!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;过去是怎样：NSError-和-NSErrorPointer&quot;&gt;&lt;a href=&quot;#过去是怎样：NSError-和-NSErrorPointer&quot; class=&quot;headerlink&quot; title=&quot;过去是怎样：NSError 和 NSErrorPointer&quot;&gt;&lt;/a&gt;过去是怎样：NSError 和 NSErrorPointer&lt;/h3&gt;&lt;p&gt;用于处理错误的历史方法是通过使用一个作为指针传递的 NSError 对象。在 Objective-C 中，它是 NSError*，但在 Swift 中你会看到 NSError？ 和 NSErrorPointer。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="error" scheme="http://chengkang.me/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView 总结</title>
    <link href="http://chengkang.me/2016/04/13/UICollectionView%20%E6%80%BB%E7%BB%93/"/>
    <id>http://chengkang.me/2016/04/13/UICollectionView 总结/</id>
    <published>2016-04-13T06:13:54.000Z</published>
    <updated>2016-04-13T06:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目源码：<a href="https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen" target="_blank" rel="external">模拟凤凰新闻 Github 仓库</a></p>
</blockquote>
<h3 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h3><p>昨天给自己布置这个作业之后，看完文档实践的过程中发现一片很棒的英文总结，于是翻译了一下。这篇总结会简单总结一下我翻译的那篇文章里的内容，以及基于模拟凤凰新闻客户端部分页面的一些 UICollectionView 使用总结。</p>
<p>文章主要是总结一些需要注意的内容，具体请看源码。实现的内容及对应文件包括：</p>
<ul>
<li>同一个 section 内拖动 cell<ul>
<li>直接使用 UICollectionViewController（<code>TestCollectionViewController.swift</code>）</li>
<li>在 UIViewController 中使用 UICollectionView（<code>EditTabsViewController.swift</code>）</li>
</ul>
</li>
<li>不同 section 间拖动 cell（<code>Test.swift</code>）</li>
<li>不同 section 间点击移动 cell（<code>TabsViewController.swift</code>）</li>
<li>点击移除 cell（<code>EditTabsViewController.swift</code>）</li>
</ul>
<p>主要内容如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-2.gif" alt=""></p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-3.gif" alt=""></p>
<a id="more"></a>
<h3 id="《【译】UICollectionView-轻松重排》"><a href="#《【译】UICollectionView-轻松重排》" class="headerlink" title="《【译】UICollectionView 轻松重排》"></a>《【译】UICollectionView 轻松重排》</h3><p>这篇文章主要介绍了在 iOS9 之后 UICollectionView 自带的重新排列方法。</p>
<ol>
<li>如果直接使用 UICollectionViewController，通过重写<code>func collectionView(collectionView: UICollectionView,
 moveItemAtIndexPath sourceIndexPath: NSIndexPath,
 toIndexPath destinationIndexPath: NSIndexPath)</code>即可以实现拖动重排。</li>
<li>如果是在 UIViewController 里面使用 UICollectionView，则需要自己添加一个 UILongPressGestureRecognizer，对应状态进行对应处理。</li>
</ol>
<p>比较重要的几个方法是：</p>
<ul>
<li>func collectionView(collectionView: UICollectionView,<br>  moveItemAtIndexPath sourceIndexPath: NSIndexPath,<br>  toIndexPath destinationIndexPath: NSIndexPath)</li>
<li>indexPathForItemAtPoint</li>
<li>beginInteractiveMovementForItemAtIndexPath</li>
<li>updateInteractiveMovementTargetPosition</li>
<li>endInteractiveMovement</li>
<li>cancelInteractiveMovement</li>
</ul>
<p><strong>特别注意</strong></p>
<p>这个方法<code>func collectionView(collectionView: UICollectionView,
    moveItemAtIndexPath sourceIndexPath: NSIndexPath,
    toIndexPath destinationIndexPath: NSIndexPath)</code>,</p>
<ul>
<li>重写这个方法之后，自带的拖动重排才能生效。</li>
<li>这个方法究竟有什么作用？这个方法是在 cell 位置变换之后触发的。它包含两个很有用的参数，被拖动的 cell 的初始 indexPath 和落点 indexPath。因为这个位置的变换只是视图的改变，这些 cell 背后的数据的 index 其实并没有受到影响。因此如果此时 reloadData() 会发现，格子位置又恢复了，但这不是我们想要的，在实际项目中我们希望移动后就一直保持那个位置，也就是说数据的 index 发生相应改变。这个方法就是方便我们处理数据的。具体请看之后内容中的例子。</li>
<li>另外这个方法只与通过交互移动 cell 事件有关。如果是直接调用移动 cell 的方法并不会触发这个方法。所以在类似凤凰新闻编辑订阅频道页面，”点击下面 section 中的频道，移动到上面的 section 中”，实现时需要在 didSelect 方法中添加对应修改数据源的代码。具体参看源码中<code>TabsViewController.swift</code>。</li>
</ul>
<h3 id="使用-UICollectionView-必做的事情"><a href="#使用-UICollectionView-必做的事情" class="headerlink" title="使用 UICollectionView 必做的事情"></a>使用 UICollectionView 必做的事情</h3><p>首先你的 UIViewController 要继承 UICollectionViewDataSource，UICollectionViewDelegate，UICollectionViewDelegateFlowLayout。</p>
<p>其次，记得绑定 delegate 和 datasource。</p>
<p>然后是：</p>
<ul>
<li>func numberOfSectionsInCollectionView(collectionView: UICollectionView) -&gt; Int</li>
<li>collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int</li>
<li>collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell</li>
</ul>
<p>有需要的话用上：</p>
<ul>
<li>func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&gt; CGSize</li>
<li>func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -&gt; UICollectionReusableView </li>
</ul>
<p><strong>特别注意</strong></p>
<p>当你在 storyboard 设置了使用 header 或者 footer 或者两者都用的时候，记得添加对应的内容在 viewForSupplementaryElementOfKind 里面。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -&gt; UICollectionReusableView &#123;</span><br><span class="line">    </span><br><span class="line">    if kind == UICollectionElementKindSectionHeader &#123;</span><br><span class="line">        let header = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: &quot;TabSectionHeader&quot;, forIndexPath: indexPath) as! TabSectionHeader</span><br><span class="line">        return header</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let footer = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: &quot;TabSectionFooter&quot;, forIndexPath: indexPath)</span><br><span class="line">        return footer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>个人对这个方法的设计持怀疑态度，觉得像 UITableView 那样分离开会更好。（又或许是我理解不够深刻吧。）</p>
<p>记得设置 reuseIdentifier。</p>
<h3 id="插入、移动、删除-cell-以及-cell-总数的问题"><a href="#插入、移动、删除-cell-以及-cell-总数的问题" class="headerlink" title="插入、移动、删除 cell 以及 cell 总数的问题"></a>插入、移动、删除 cell 以及 cell 总数的问题</h3><p>UICollectionView 是在生成 cell 的时候，先通过 numberOfItemsInSection 获得 cell 数量，然后一个一个生成添加在视图中。</p>
<p>你可通过这些方法来插入、移动、删除 cell：</p>
<ul>
<li>insertItemAtIndexPaths</li>
<li>moveItemAtIndexPath</li>
<li>deleteItemsAtIndexPaths</li>
</ul>
<p>比如，当来自服务器的数据更新了，新增或者减少了一个数据，我们可以想到有两种情况：</p>
<ol>
<li>通过 reloadData() 将整个 UICollectionView 更新。</li>
<li>只在对应的位置插入或删除对应的那一个 cell。</li>
</ol>
<p>用第一种方法是没有任何问题的。问题在第二种方法。</p>
<p>当我们直接通过 insertItemAtIndexPaths 或者 deleteItemsAtIndexPaths 添加或删除 cell 时，UICollectionView 中的 cell 数量发生变化了。貌似没问题？如果你尝试滑动一下屏幕，你会发现程序崩溃了。你会看到类似下面的报错：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-13%20at%206.20.09%20AM.png" alt=""></p>
<p>原因在于，当 UICollectionView 进行任何的更新时，包括局部更新，都会检查 numberOfItemInSection 方法返回的值和当前 UICollectionView 中实际包含的 cell 数量。如果二者不一致就会报错。</p>
<p><strong>特别注意</strong></p>
<p>UICollectionView 中实际包含的 cell 数量在下一次更新前 collection view 视图前一定要和 numberOfItemInSection 的返回值一直。</p>
<p>所以我们在新增或者删除 cell 之后，记得要修改对应的数据源。（当然在实际项目中应该不会忘记。）</p>
<p><strong>插入、移动、删除 section 类似</strong></p>
<h3 id="不同-section-间拖动-cell"><a href="#不同-section-间拖动-cell" class="headerlink" title="不同 section 间拖动 cell"></a>不同 section 间拖动 cell</h3><p>项目中的 Test.swift 是关于不同 section 间拖动 cell 的例子。</p>
<p>基本原理和在一个 section 内拖动 cell 一样，都是调用那几个方法。</p>
<p><strong>第一点</strong></p>
<p>需要注意的还是上面提到的记得修改对应数据源，否则第二次拖动就会报错。因为此时两个 section 内 cell 数量和 numberOfItemInSection 返回值不一样了。</p>
<p><strong>第二点</strong></p>
<p>请看一下两个实现方法：</p>
<p>一，『原始』方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func longPressGestureRecognizerAction(sender: UILongPressGestureRecognizer) &#123;</span><br><span class="line">    switch sender.state &#123;</span><br><span class="line">    case .Began:</span><br><span class="line">        let location = sender.locationInView(self.collectionView)</span><br><span class="line">        let indexPath = self.collectionView.indexPathForItemAtPoint(location)</span><br><span class="line">        self.originalSectionIndex = (indexPath?.section)!</span><br><span class="line">        self.interactiveItem = self.collectionView.cellForItemAtIndexPath(indexPath!)</span><br><span class="line">        self.collectionView.beginInteractiveMovementForItemAtIndexPath(indexPath!)</span><br><span class="line">        break</span><br><span class="line">    case .Changed:</span><br><span class="line">        let location = sender.locationInView(self.collectionView)</span><br><span class="line">        print(location)</span><br><span class="line">        let indexPath = self.collectionView.indexPathForItemAtPoint(location)</span><br><span class="line">        print(indexPath)</span><br><span class="line">        self.collectionView.updateInteractiveMovementTargetPosition(location)</span><br><span class="line">    case .Ended:</span><br><span class="line">        self.collectionView.endInteractiveMovement()</span><br><span class="line">        let currentSectionIndex = (self.collectionView.indexPathForCell(self.interactiveItem)?.section)!</span><br><span class="line">        self.sections[currentSectionIndex]++</span><br><span class="line">        self.sections[self.originalSectionIndex]--</span><br><span class="line">    default:</span><br><span class="line">        self.collectionView.cancelInteractiveMovement()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二，借助自带方法的简便方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func collectionView(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) &#123;</span><br><span class="line">    self.sections[destinationIndexPath.section]++</span><br><span class="line">    self.sections[sourceIndexPath.section]--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func longPressGestureRecognizerAction(sender: UILongPressGestureRecognizer) &#123;</span><br><span class="line">    switch sender.state &#123;</span><br><span class="line">    case .Began:</span><br><span class="line">        guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(sender.locationInView(self.collectionView)) else &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        self.collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)</span><br><span class="line">        break</span><br><span class="line">    case .Changed:</span><br><span class="line">        self.collectionView.updateInteractiveMovementTargetPosition(sender.locationInView(self.collectionView))</span><br><span class="line">        break</span><br><span class="line">    case .Ended:</span><br><span class="line">        self.collectionView.endInteractiveMovement()</span><br><span class="line">    default:</span><br><span class="line">        self.collectionView.cancelInteractiveMovement()</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个方法定义了两个全局变量<code>var originalSectionIndex = 0</code>和<code>var interactiveItem:UICollectionViewCell!</code>来记录初始位置和正在进行移动的 cell。</p>
<p>而第二个方法，通过使用<code>func collectionView(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath)</code>，直接就可以使用开始和结束位置 indexPath。非常方便。</p>
<p>所以当然一定要用第二种方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot;&gt;模拟凤凰新闻 Github 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;昨天给自己布置这个作业之后，看完文档实践的过程中发现一片很棒的英文总结，于是翻译了一下。这篇总结会简单总结一下我翻译的那篇文章里的内容，以及基于模拟凤凰新闻客户端部分页面的一些 UICollectionView 使用总结。&lt;/p&gt;
&lt;p&gt;文章主要是总结一些需要注意的内容，具体请看源码。实现的内容及对应文件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个 section 内拖动 cell&lt;ul&gt;
&lt;li&gt;直接使用 UICollectionViewController（&lt;code&gt;TestCollectionViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在 UIViewController 中使用 UICollectionView（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同 section 间拖动 cell（&lt;code&gt;Test.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;不同 section 间点击移动 cell（&lt;code&gt;TabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;点击移除 cell（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要内容如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://chengkang.me/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>【译】UICollectionView 轻松重排</title>
    <link href="http://chengkang.me/2016/04/12/%E3%80%90%E8%AF%91%E3%80%91UICollectionView%20%E8%BD%BB%E6%9D%BE%E9%87%8D%E6%8E%92/"/>
    <id>http://chengkang.me/2016/04/12/【译】UICollectionView 轻松重排/</id>
    <published>2016-04-12T22:38:28.000Z</published>
    <updated>2016-04-12T22:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/" target="_blank" rel="external">UICollectionViews Now Have Easy Reordering</a></p>
<p>原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。</p>
</blockquote>
<p>我超喜欢<code>UICollectionView</code>。相比<code>UITableView</code>，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 <a href="https://github.com/nshintio/uicollectionview-reordering" target="_blank" rel="external">Github</a> 上找到对应的 Xcode 项目。</p>
<p>最简单的实现重排是通过使用<code>UICollectionViewController</code>。它现在有一个新的属性叫做<code>installsStandardGestureForInteractiveMovement</code>，作用是添加手势（gestures）来重排 cells。这个属性默认值为<code>True</code>，这意味着要使用它我们只需要重写一个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func collectionView(collectionView: UICollectionView,</span><br><span class="line">    moveItemAtIndexPath sourceIndexPath: NSIndexPath,</span><br><span class="line">    toIndexPath destinationIndexPath: NSIndexPath) &#123;</span><br><span class="line">    // move your data order</span><br><span class="line">    // 可以留空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前的 collection view 判定 items 可以被移动，因为<code>moveItemAtIndexPath</code>被重写了。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/1.gif" alt=""></p>
<a id="more"></a>
<p>当我们希望在一个简单的<code>UIViewController</code>中使用 collection view 时，会麻烦一点。我们也要实现之前提到的<code>UICollectionViewDataSource</code>方法，不过我们需要重写<code>installsStandardGestureForInteractiveMovement</code>。不用担心，也很简单。<code>UILongPressGestureRecognizer</code>是一种持续性的手势识别器并且完全支持拖动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">            longPressGesture = UILongPressGestureRecognizer(target: self, action: &quot;handleLongGesture:&quot;)</span><br><span class="line">        self.collectionView.addGestureRecognizer(longPressGesture)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    func handleLongGesture(gesture: UILongPressGestureRecognizer) &#123;</span><br><span class="line"></span><br><span class="line">        switch(gesture.state) &#123;</span><br><span class="line"></span><br><span class="line">        case UIGestureRecognizerState.Began:</span><br><span class="line">            guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(gesture.locationInView(self.collectionView)) else &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)</span><br><span class="line">        case UIGestureRecognizerState.Changed:</span><br><span class="line">            collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view!))</span><br><span class="line">        case UIGestureRecognizerState.Ended:</span><br><span class="line">            collectionView.endInteractiveMovement()</span><br><span class="line">        default:</span><br><span class="line">            collectionView.cancelInteractiveMovement()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们保存了在 long press gesture 中不活的被选中的 index path 并且基于它是否有值决定允不允许拖动手势生效。然后，我们根据手势状态调用一些新的 collection view 方法。</p>
<ul>
<li><code>beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)</code>：开始指定位置 cell 的交互移动。</li>
<li><code>updateInteractiveMovementTargetPosition(targetPosition: CGPoint)</code>：更新交互移动对象的位置</li>
<li><code>endInteractiveMovement()</code>：在你结束拖动手势之后结束交互移动</li>
<li><code>cancelInteractiveMovement()</code>：取消交互移动</li>
</ul>
<p>这些让搞定拖动手势非常容易。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/2.gif" alt=""></p>
<p>效果和标准的<code>UICollectionViewController</code>一样。很酷对吧，不过更酷的是我们可以将我们自定义的 collection view layout 应用到重排中去。看看下面在简单的瀑布视图中的交互移动。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/3.gif" alt=""></p>
<p>嗯，看起来不错，不过如果我们不想在移动的时候改变 cell 大小呢？选中的 cell 大小应该在交互移动时保持一致。这是可以实现的。<code>UICollectionViewLayout</code>也有一些其他的方法来负责重排。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],</span><br><span class="line">    withTargetPosition targetPosition: CGPoint,</span><br><span class="line">    previousIndexPaths: [NSIndexPath],</span><br><span class="line">    previousPosition: CGPoint) -&gt; UICollectionViewLayoutInvalidationContext</span><br><span class="line"></span><br><span class="line">func invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths(indexPaths: [NSIndexPath],</span><br><span class="line">    previousIndexPaths: [NSIndexPath],</span><br><span class="line">    movementCancelled: Bool) -&gt; UICollectionViewLayoutInvalidationContext</span><br></pre></td></tr></table></figure></p>
<p>前一个在目标 indexPath 和之前的 indexPath 之间进行移动时调用。另一个类似，不过是在移动结束之后调用。有了这些我们就可以通过一些小手段达到我们的要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal override func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],</span><br><span class="line">    withTargetPosition targetPosition: CGPoint,</span><br><span class="line">    previousIndexPaths: [NSIndexPath],</span><br><span class="line">    previousPosition: CGPoint) -&gt; UICollectionViewLayoutInvalidationContext &#123;</span><br><span class="line"></span><br><span class="line">    var context = super.invalidationContextForInteractivelyMovingItems(targetIndexPaths,</span><br><span class="line">        withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,</span><br><span class="line">        previousPosition: previousPosition)</span><br><span class="line"></span><br><span class="line">    self.delegate?.collectionView!(self.collectionView!, moveItemAtIndexPath: previousIndexPaths[0],</span><br><span class="line">        toIndexPath: targetIndexPaths[0])</span><br><span class="line"></span><br><span class="line">    return context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决方案非常清晰。获取正在移动的 cell 之前和目标 index path。然后调用<code>UICollectionViewDataSource</code>来移动这些 item。</p>
<p><img src="http://nshint.io/images/uicollectionview-reordering/4.gif" alt=""></p>
<p>不用怀疑，collection view 重排是一个非常棒的更新。UIKit 工程师干得太棒了！：）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/&quot;&gt;UICollectionViews Now Have Easy Reordering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我超喜欢&lt;code&gt;UICollectionView&lt;/code&gt;。相比&lt;code&gt;UITableView&lt;/code&gt;，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 &lt;a href=&quot;https://github.com/nshintio/uicollectionview-reordering&quot;&gt;Github&lt;/a&gt; 上找到对应的 Xcode 项目。&lt;/p&gt;
&lt;p&gt;最简单的实现重排是通过使用&lt;code&gt;UICollectionViewController&lt;/code&gt;。它现在有一个新的属性叫做&lt;code&gt;installsStandardGestureForInteractiveMovement&lt;/code&gt;，作用是添加手势（gestures）来重排 cells。这个属性默认值为&lt;code&gt;True&lt;/code&gt;，这意味着要使用它我们只需要重写一个方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func collectionView(collectionView: UICollectionView,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    moveItemAtIndexPath sourceIndexPath: NSIndexPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toIndexPath destinationIndexPath: NSIndexPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // move your data order&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 可以留空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当前的 collection view 判定 items 可以被移动，因为&lt;code&gt;moveItemAtIndexPath&lt;/code&gt;被重写了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://chengkang.me/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>模拟凤凰新闻 | 更复杂的标签动画 - Swift 实现多个 TableView 的侧滑与切换</title>
    <link href="http://chengkang.me/2016/04/08/%E6%A8%A1%E6%8B%9F%E5%87%A4%E5%87%B0%E6%96%B0%E9%97%BB%20%7C%20%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A0%87%E7%AD%BE%E5%8A%A8%E7%94%BB%20-%20Swift%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%20TableView%20%E7%9A%84%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%88%87%E6%8D%A2/"/>
    <id>http://chengkang.me/2016/04/08/模拟凤凰新闻 | 更复杂的标签动画 - Swift 实现多个 TableView 的侧滑与切换/</id>
    <published>2016-04-08T19:59:13.000Z</published>
    <updated>2016-04-08T20:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目源码：<a href="https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen" target="_blank" rel="external">github 仓库：模拟凤凰新闻首页</a></p>
<p>下午逛 SegmentFault 时看到有人问如何实现凤凰新闻 app 首页效果，正好这两天在学习如何实现多个 TableView 的侧滑与切换，索性自己尝试一下。</p>
</blockquote>
<h3 id="目标和成果"><a href="#目标和成果" class="headerlink" title="目标和成果"></a>目标和成果</h3><p>如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-1.gif" alt=""></p>
<p>简单列一下关键点：</p>
<ol>
<li>跟随滑动</li>
<li>点击事件<a id="more"></a>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>凤凰新闻 app 里面下划线是在下面的 ScrollView 滚动动画结束之后才开始侧滑的，所以需要监听滚动是否结束。<ul>
<li>我刚开始想用 scrollViewDidEndScrollingAnimation，结果并不行。这个方法具体使用场景我还没搞清楚。</li>
<li>应该使用 scrollViewDidEndDecelerating，当 ScrollView 停止减速的时候即动画结束的时候。</li>
</ul>
</li>
<li>刚开始忘记了点击事件，所以标签用的 UILabel，其实可以换成 UIButton。这样就能省去寻找位置那一步。不过感觉 UIButton 的样式调整也很麻烦。幸运的是 UILabel 默认样式（字体、字号）非常符合这个项目要求。</li>
<li>不要忘记设置每个 ScrollView 的 delegate；不要忘记在 delegate 方法中判断当前是哪个 ScrollView</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.swift</span><br><span class="line">//  FenghuangXinwen</span><br><span class="line">//</span><br><span class="line">//  Created by Ant on 4/8/16.</span><br><span class="line">//  Copyright © 2016 Ant. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController, UIScrollViewDelegate &#123;</span><br><span class="line">    </span><br><span class="line">    @IBOutlet weak var tabScrollView: UIScrollView!</span><br><span class="line">    @IBOutlet weak var contentScrollView: UIScrollView!</span><br><span class="line">    </span><br><span class="line">    let tabLine = UIView() //tab 标签下划线</span><br><span class="line">    let TAB_LINE_HEIGHT = CGFloat(2) //tab 标签下划线高度</span><br><span class="line">    let tabTitles = [</span><br><span class="line">        &quot;头条&quot;,</span><br><span class="line">        &quot;推荐&quot;,</span><br><span class="line">        &quot;娱乐&quot;,</span><br><span class="line">        &quot;财经&quot;,</span><br><span class="line">        &quot;自媒体&quot;,</span><br><span class="line">        &quot;凤凰卫视&quot;,</span><br><span class="line">        &quot;科技&quot;,</span><br><span class="line">        &quot;良品&quot;,</span><br><span class="line">        &quot;美女&quot;,</span><br><span class="line">        &quot;军事&quot;,</span><br><span class="line">        &quot;体育&quot;,</span><br><span class="line">        &quot;历史&quot;,</span><br><span class="line">        &quot;汽车&quot;,</span><br><span class="line">        &quot;时尚&quot;,</span><br><span class="line">        &quot;房产&quot;,</span><br><span class="line">        &quot;FUN来了&quot;,</span><br><span class="line">        &quot;段子&quot;,</span><br><span class="line">        &quot;萌物&quot;,</span><br><span class="line">    ] //tab 标签标题</span><br><span class="line">    </span><br><span class="line">    var tabLbls: [UILabel] = [] //tab 标签对应的 UILabl</span><br><span class="line">    </span><br><span class="line">    //定义要用到的颜色及 RGB 值差，用于颜色变化</span><br><span class="line">    let TEXT_COLOR_NORMAL = UIColor(red: 115/255, green: 120/255, blue: 134/255, alpha: 1)</span><br><span class="line">    let TEXT_COLOR_ACTIVE = UIColor(red: 245/255, green: 67/255, blue: 66/255, alpha: 1)</span><br><span class="line">    let TEXT_COLOR_NORMAL_RED = CGFloat(115)</span><br><span class="line">    let TEXT_COLOR_NORMAL_GREEN = CGFloat(120)</span><br><span class="line">    let TEXT_COLOR_NORMAL_BLUE = CGFloat(134)</span><br><span class="line">    let TEXT_COLOR_ACTIVE_RED = CGFloat(245)</span><br><span class="line">    let TEXT_COLOR_ACTIVE_GREEN = CGFloat(67)</span><br><span class="line">    let TEXT_COLOR_ACTIVE_BLUE = CGFloat(66)</span><br><span class="line">    let TEXT_COLOR_RED_DIF = CGFloat(130)</span><br><span class="line">    let TEXT_COLOR_GREEN_DIF = CGFloat(-53)</span><br><span class="line">    let TEXT_COLOR_BLUE_DIF = CGFloat(-68)</span><br><span class="line">    let TAB_LINE_COLOR = UIColor(red: 245/255, green: 67/255, blue: 66/255, alpha: 1)</span><br><span class="line">    </span><br><span class="line">    let MARGIN = CGFloat(20) //tab 标签左右间距</span><br><span class="line">    </span><br><span class="line">    var currentTabIndex = 0 //当前 tab 标签 index</span><br><span class="line">    var currentTabX = CGFloat(20) //当前 tab 标签 x 坐标，方便定位</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        //设置 scrollView delegate</span><br><span class="line">        tabScrollView.delegate = self</span><br><span class="line">        contentScrollView.delegate = self</span><br><span class="line">        </span><br><span class="line">        //初始化视图内容</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func initView() &#123;</span><br><span class="line">        //定义一些常量方便使用</span><br><span class="line">        let TABSCROLLVIEW_HEIGHT = self.tabScrollView.frame.height //tabScrollview 高度</span><br><span class="line">        let LABEL_Y = TABSCROLLVIEW_HEIGHT / 2 - 5 // 每个 tab 标签的 y 坐标</span><br><span class="line">        </span><br><span class="line">        //生成 tab 标签，添加到 tabScrollview 并设置大小位置</span><br><span class="line">        for var i = 0; i &lt; self.tabTitles.count; i++ &#123;</span><br><span class="line">            let tabLbl = UILabel()</span><br><span class="line">            tabLbl.text = tabTitles[i]</span><br><span class="line">            tabLbl.textColor = self.TEXT_COLOR_NORMAL</span><br><span class="line">            tabLbl.sizeToFit()</span><br><span class="line">            tabLbls.append(tabLbl)</span><br><span class="line">            </span><br><span class="line">            self.tabScrollView.addSubview(tabLbl)</span><br><span class="line">            </span><br><span class="line">            if i &gt; 0 &#123;</span><br><span class="line">                tabLbl.center = CGPointMake( self.MARGIN + self.tabLbls[i-1].center.x + self.tabLbls[i-1].frame.width / 2 + tabLbl.frame.width / 2 , LABEL_Y)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tabLbl.center = CGPointMake( self.MARGIN + tabLbl.frame.width / 2, LABEL_Y)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //顺便生成并添加每个 tab 页面对应的 view。用于测试。</span><br><span class="line">            let tabContentView = UIView()</span><br><span class="line">            self.contentScrollView.addSubview(tabContentView)</span><br><span class="line">            tabContentView.backgroundColor = UIColor.whiteColor()</span><br><span class="line">            tabContentView.frame = CGRectMake(self.view.frame.width * CGFloat(i), 0, self.view.frame.width, self.contentScrollView.frame.height)</span><br><span class="line">            let labelInContent = UILabel()</span><br><span class="line">            labelInContent.text = tabTitles[i]</span><br><span class="line">            labelInContent.sizeToFit()</span><br><span class="line">            tabContentView.addSubview(labelInContent)</span><br><span class="line">            labelInContent.center = CGPointMake(tabContentView.frame.width / 2, tabContentView.frame.height / 2 - 100)</span><br><span class="line">        &#125;</span><br><span class="line">        self.contentScrollView.contentSize = CGSizeMake(self.view.frame.width * CGFloat(self.tabLbls.count), self.contentScrollView.frame.height) //设置 contentScrollView 内容大小</span><br><span class="line">        </span><br><span class="line">        //计算并设置 tabScrollView 内容大小</span><br><span class="line">        var TABVIEW_WIDTH = CGFloat(0)</span><br><span class="line">        for tabLbl in self.tabLbls &#123;</span><br><span class="line">            TABVIEW_WIDTH += self.MARGIN + tabLbl.frame.width</span><br><span class="line">        &#125;</span><br><span class="line">        TABVIEW_WIDTH += self.MARGIN</span><br><span class="line">        self.tabScrollView.contentSize = CGSizeMake(TABVIEW_WIDTH, 40)</span><br><span class="line">        </span><br><span class="line">        //默认选中第一个标签</span><br><span class="line">        self.tabLbls[0].textColor = self.TEXT_COLOR_ACTIVE</span><br><span class="line">        self.currentTabIndex = 0</span><br><span class="line">        self.currentTabX = self.tabLbls[0].frame.origin.x</span><br><span class="line">        </span><br><span class="line">        //添加 tab 标签下划线</span><br><span class="line">        //设置位置有一个没搞清楚的问题：不知为何 y 坐标设为 TABSCROLLVIEW_HEIGHT - self.TAB_LINE_HEIGHT 时，下划线看不见</span><br><span class="line">        self.tabScrollView.addSubview(self.tabLine)</span><br><span class="line">        self.tabLine.backgroundColor = TAB_LINE_COLOR</span><br><span class="line">        self.tabLine.frame = CGRectMake(MARGIN, TABSCROLLVIEW_HEIGHT - 5, self.tabLbls[0].frame.width, self.TAB_LINE_HEIGHT)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        //当 contentScrollView 滚动时</span><br><span class="line">        if scrollView == self.contentScrollView &#123;</span><br><span class="line">            let index = scrollView.contentOffset.x / self.view.frame.width //获取当前页面 index</span><br><span class="line">            </span><br><span class="line">            if floor(index) == index &#123;</span><br><span class="line">                self.currentTabIndex = Int(index)</span><br><span class="line">                self.currentTabX = self.tabLbls[self.currentTabIndex].frame.origin.x</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //阻止第一页和最后一页越界滚动</span><br><span class="line">            let MIN_X = CGFloat(0)</span><br><span class="line">            let MAX_X = scrollView.contentSize.width - self.view.frame.width</span><br><span class="line">            let CONTENT_OFFSET_X = scrollView.contentOffset.x</span><br><span class="line">            </span><br><span class="line">            if CONTENT_OFFSET_X &lt; MIN_X &#123;</span><br><span class="line">                scrollView.contentOffset.x = MIN_X</span><br><span class="line">            &#125; else if CONTENT_OFFSET_X &gt; MAX_X &#123;</span><br><span class="line">                scrollView.contentOffset.x = MAX_X</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //当没有越界时，执行『动画』</span><br><span class="line">                </span><br><span class="line">                //初始化一些要用到的值</span><br><span class="line">                let isLeft = index &lt; CGFloat(self.currentTabIndex)</span><br><span class="line">                let nextTabIndex = isLeft ? self.currentTabIndex - 1 : index == CGFloat(self.currentTabIndex) ? self.currentTabIndex : self.currentTabIndex + 1 //下一个标签 index</span><br><span class="line">                let currentTabWidth = self.tabLbls[self.currentTabIndex].frame.width //当前标签宽度</span><br><span class="line">                let nextTabWidth = self.tabLbls[nextTabIndex].frame.width //下一个标签宽度</span><br><span class="line">                let widthDif = nextTabWidth - currentTabWidth //两个标签宽度差</span><br><span class="line">                let distance = self.MARGIN + (isLeft ? self.tabLbls[nextTabIndex].frame.width : currentTabWidth) //下划线需要滑动的距离</span><br><span class="line">                var offsetPercentage = index - CGFloat(self.currentTabIndex) //当前偏移百分比</span><br><span class="line">                //如果滑动超过一页，将偏移百分比设置为 ±1，避免多余动画</span><br><span class="line">                if offsetPercentage &lt; -1 &#123;</span><br><span class="line">                    offsetPercentage = -1</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if offsetPercentage &gt; 1 &#123;</span><br><span class="line">                    offsetPercentage = 1</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //改变标签底部横线位置和长度</span><br><span class="line">                self.tabLine.frame = CGRectMake(currentTabX + distance * offsetPercentage, self.tabLine.frame.origin.y, currentTabWidth + widthDif * abs(offsetPercentage), self.tabLine.frame.height)</span><br><span class="line">                </span><br><span class="line">                //改变颜色</span><br><span class="line">                self.tabLbls[nextTabIndex].textColor = UIColor(red: (TEXT_COLOR_NORMAL_RED + TEXT_COLOR_RED_DIF * abs(offsetPercentage)) / 255, green: (TEXT_COLOR_NORMAL_GREEN + TEXT_COLOR_GREEN_DIF * abs(offsetPercentage)) / 255, blue: (TEXT_COLOR_NORMAL_BLUE + TEXT_COLOR_BLUE_DIF * abs(offsetPercentage)) / 255, alpha: 1)</span><br><span class="line">                self.tabLbls[self.currentTabIndex].textColor = UIColor(red: (TEXT_COLOR_ACTIVE_RED - TEXT_COLOR_RED_DIF * abs(offsetPercentage)) / 255, green: (TEXT_COLOR_ACTIVE_GREEN - TEXT_COLOR_GREEN_DIF * abs(offsetPercentage)) / 255, blue: (TEXT_COLOR_ACTIVE_BLUE - TEXT_COLOR_BLUE_DIF * abs(offsetPercentage)) / 255, alpha: 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123;</span><br><span class="line">        if scrollView == self.contentScrollView &#123;</span><br><span class="line">            let TWO_WORD_WIDTH = CGFloat(34) //两个字标签的宽度。这个间距其实是根据自己需求随便设置的。</span><br><span class="line">            </span><br><span class="line">            //当标签左边被遮挡时，调整 tabScrollView x 轴偏移量</span><br><span class="line">            if self.tabLine.frame.origin.x &lt; self.tabScrollView.contentOffset.x &#123;</span><br><span class="line">                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">                    self.tabScrollView.contentOffset.x = self.tabLine.frame.origin.x - self.MARGIN</span><br><span class="line">                    &#125;, completion: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //当下划线 x 坐标在 tabScrollView 中部之后时，调整 tabScrollView x 轴偏移量</span><br><span class="line">            if self.tabLine.frame.origin.x &gt; self.tabScrollView.frame.width / 2 &amp;&amp; self.currentTabIndex + 1 &lt; self.tabLbls.count - 3 &#123;</span><br><span class="line">                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">                    self.tabScrollView.contentOffset.x = self.tabLine.frame.origin.x - self.MARGIN - TWO_WORD_WIDTH</span><br><span class="line">                    &#125;, completion: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //当标签右边被遮挡时，调整 tabScrollView x 轴偏移量</span><br><span class="line">            if self.tabLine.frame.origin.x + self.tabLine.frame.width + self.MARGIN &gt; self.tabScrollView.contentOffset.x + self.tabScrollView.frame.width&#123;</span><br><span class="line">                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">                    self.tabScrollView.contentOffset.x += (self.tabLine.frame.origin.x + self.tabLine.frame.width + self.MARGIN) - (self.tabScrollView.contentOffset.x + self.tabScrollView.frame.width) + self.MARGIN</span><br><span class="line">                    &#125;, completion: nil)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @IBAction func tabScrollViewTapped(sender: UITapGestureRecognizer) &#123;</span><br><span class="line">        let location = sender.locationInView(self.tabScrollView) //获取当前点击事件在 tabScrollView 里的坐标</span><br><span class="line">        </span><br><span class="line">        //循环找到点击的是哪一个标签，找到时执行方法</span><br><span class="line">        for var i = 0; i &lt; self.tabLbls.count; i++ &#123;</span><br><span class="line">            if CGRectContainsPoint(self.tabLbls[i].frame, location) &#123;</span><br><span class="line">                self.tabLbls[self.currentTabIndex].textColor = TEXT_COLOR_NORMAL</span><br><span class="line">                self.tabLbls[i].textColor = TEXT_COLOR_ACTIVE</span><br><span class="line">                self.currentTabIndex = i</span><br><span class="line">                self.currentTabX = self.tabLbls[self.currentTabIndex].frame.origin.x</span><br><span class="line">                </span><br><span class="line">                self.contentScrollView.contentOffset.x = self.view.frame.width * CGFloat(i)</span><br><span class="line">                </span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot;&gt;github 仓库：模拟凤凰新闻首页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下午逛 SegmentFault 时看到有人问如何实现凤凰新闻 app 首页效果，正好这两天在学习如何实现多个 TableView 的侧滑与切换，索性自己尝试一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单列一下关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟随滑动&lt;/li&gt;
&lt;li&gt;点击事件
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UITableView" scheme="http://chengkang.me/tags/UITableView/"/>
    
      <category term="UISrollView" scheme="http://chengkang.me/tags/UISrollView/"/>
    
  </entry>
  
  <entry>
    <title>AutoLayout 中需要注意的点</title>
    <link href="http://chengkang.me/2016/04/07/AutoLayout%20%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>http://chengkang.me/2016/04/07/AutoLayout 中需要注意的点/</id>
    <published>2016-04-06T23:41:14.000Z</published>
    <updated>2016-04-06T23:44:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文用于记录我在使用 AutoLayout 过程中遇到的一些需要注意的事情，一种是容易犯的错误，一种是我找不到原因的情况。<br><a id="more"></a></p>
</blockquote>
<h3 id="容易犯的错误"><a href="#容易犯的错误" class="headerlink" title="容易犯的错误"></a>容易犯的错误</h3><ol>
<li>如果预览的样式和你预想的不一样，检查一下是不是忘记给作为背景的 view 添加约束（上下左右），可能有一个约束缺失，导致整体样式出错。</li>
</ol>
<h3 id="找不到原因的情况"><a href="#找不到原因的情况" class="headerlink" title="找不到原因的情况"></a>找不到原因的情况</h3><ol>
<li><p>在 ScrollView 中通过 AutoLayout 设置 StackView 子视图不固定宽度时，需要设置和 superview Equal Widths，然后根据需要调整间距。否则子视图宽度约束设置不生效。如果出现其他 view 宽度不对劲的情况，也可以试着用 Equal Widths 解决。</p>
<p> 如图，分别为宽度不正常情况和使用 Eauql Widths 之后正常情况：</p>
<p> <img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-07%20at%2012.37.01%20AM.png" alt=""></p>
<p> <img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-07%20at%2012.37.31%20AM.png" alt=""></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文用于记录我在使用 AutoLayout 过程中遇到的一些需要注意的事情，一种是容易犯的错误，一种是我找不到原因的情况。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="AutoLayout" scheme="http://chengkang.me/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>Swift 实现多个 TableView 的侧滑与切换（模拟 instagram 系列）</title>
    <link href="http://chengkang.me/2016/04/06/Swift%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%20TableView%20%E7%9A%84%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%88%87%E6%8D%A2%EF%BC%88%E6%A8%A1%E6%8B%9F%20instagram%20%E7%B3%BB%E5%88%97%EF%BC%89/"/>
    <id>http://chengkang.me/2016/04/06/Swift 实现多个 TableView 的侧滑与切换（模拟 instagram 系列）/</id>
    <published>2016-04-06T01:50:01.000Z</published>
    <updated>2016-04-08T19:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>关键词：Swift，实现多个 TableView 的侧滑与切换，在 ScrollView 中嵌套多个 TableView，一个页面显示两个 tableview…</p>
</blockquote>
<h3 id="目标与成果"><a href="#目标与成果" class="headerlink" title="目标与成果"></a>目标与成果</h3><p>如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-3.gif" alt=""></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将多个 TableView 放在 ScrollView 里面，将 ScrollView Paging 设置为 Enabled，实现多个 TableView 的侧滑与切换。</p>
<p>上方的 tab 标签跟随 ScrollView.offset.x 进行动画，蓝条为单独绘制的一个长方形 UIView。</p>
<p>通过 UIButton 的 IBAction 中的动画，实现点击 tab 标签滑动到对应 TableView。<br><a id="more"></a></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>storyboard</li>
</ol>
<p>添加一个 UIView，高度设置为 30px，上左右与 superview 间距为 0。在里面放置两个 UIButton。将两个 UIButton 组合成 StackView，设置 StackView 上下左右与 superview 间距为 0，设置 Distribution 为 Fill Equally。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%202.08.00%20AM.png" alt=""></p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%202.09.54%20AM.png" alt=""></p>
<p>在 storyboard 创建好 ScrollView 和两个 TableView。在 TableView 中创建好 TableViewCell 模板，并且将对应的类和 reuse identifier 设置好（当然你可以新建 xib 文件，然后在代码里设置 reuse identifier）。两个 TableView 应该是 ScrollView 的子视图。</p>
<p><strong>如果你是在 storyboard 里面给 TableView 添加 Prototype Cells，记得给每个 TableView 添加各自的 Prototype Cells。如果只给其中一个添加 Prototype Cells，那么另一个不会自动添加 reuse identifier。在 cellForRowAtIndexPath 方法中，对未添加 Prototype Cells 的 TableView 调用 dequeReusableCellWithIdentifier 时会报错，因为那个 TableView 本来就没有嘛。</strong></p>
<p>设置 ScrollView 的约束，本项目为下左右间距均为 0，上间距为 1（用于显示上边 tab 标签栏的阴影）。</p>
<p>TableView 的约束不用设置，因为我们要在代码中给他们重新定位。</p>
<p>设置好各个 Prototype Cell 的约束。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%202.08.21%20AM.png" alt=""></p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%201.53.58%20AM.png" alt=""></p>
<ol>
<li>FourthViewController.swift（对应的 viewController）</li>
</ol>
<p>全部代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  FourthViewController.swift</span><br><span class="line">//  Instagram</span><br><span class="line">//</span><br><span class="line">//  Created by Ant on 3/31/16.</span><br><span class="line">//  Copyright © 2016 Ant. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class FourthViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UIScrollViewDelegate &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var tableViewLeft: UITableView!</span><br><span class="line">    @IBOutlet weak var tableViewRight: UITableView!</span><br><span class="line">    @IBOutlet weak var tabPanel: UIView!</span><br><span class="line">    @IBOutlet weak var followBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var youBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var scrollView: UIScrollView!</span><br><span class="line">    </span><br><span class="line">    let scrollBar = UIView()</span><br><span class="line">    var notifications: [Notification] = []</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        //创建模拟数据</span><br><span class="line">        let notification1 = Notification(from: &quot;CHENGKANG&quot;, fromAvatar: UIImage(named: &quot;IMG_8040&quot;)!, to: &quot;Deer&quot;, toAvatar: UIImage(named: &quot;test&quot;)!, type: &quot;like&quot;, images: [UIImage(named: &quot;test&quot;)!, UIImage(named: &quot;test&quot;)!, UIImage(named: &quot;test&quot;)!, UIImage(named: &quot;test&quot;)!, UIImage(named: &quot;test&quot;)!, ], date: &quot;3天前&quot;)</span><br><span class="line">        let notification2 = Notification(from: &quot;CHENGKANG&quot;, fromAvatar: UIImage(named: &quot;IMG_8040&quot;)!, to: &quot;Deer&quot;, toAvatar: UIImage(named: &quot;test&quot;)!, type: &quot;like&quot;, images: [UIImage(named: &quot;test&quot;)!], date: &quot;3天前&quot;)</span><br><span class="line">        </span><br><span class="line">        //添加模拟数据</span><br><span class="line">        self.notifications.append(notification1)</span><br><span class="line">        self.notifications.append(notification2)</span><br><span class="line">        </span><br><span class="line">        //初始化要用到的参数</span><br><span class="line">        let WIDTH = self.view.frame.width</span><br><span class="line">        let HEIGHT = self.view.frame.height - 60 - 30 - 49</span><br><span class="line">        </span><br><span class="line">        //设置 tab 标签面板底部阴影</span><br><span class="line">        self.tabPanel.layer.shadowColor = COLOR_GREY.CGColor</span><br><span class="line">        self.tabPanel.layer.shadowRadius = 0.5</span><br><span class="line">        self.tabPanel.layer.shadowOffset = CGSizeMake(0, 0.5)</span><br><span class="line">        self.tabPanel.layer.shadowOpacity = 1</span><br><span class="line">        </span><br><span class="line">        //添加 tab 标签面板底部蓝条</span><br><span class="line">        self.view.addSubview(self.scrollBar)</span><br><span class="line">        self.scrollBar.backgroundColor = COLOR_LIGHT_BLUE</span><br><span class="line">        self.scrollBar.frame = CGRectMake(0, 87, WIDTH / 2, 3)</span><br><span class="line">        </span><br><span class="line">        //初始化按钮颜色</span><br><span class="line">        self.followBtn.setTitleColor(COLOR_LIGHT_BLUE, forState: .Normal)</span><br><span class="line">        </span><br><span class="line">        //设置 scrollView delegate</span><br><span class="line">        self.scrollView.delegate = self</span><br><span class="line">        </span><br><span class="line">        //设置 tableViewLeft delegate，并消除多余分割线</span><br><span class="line">        self.tableViewLeft.delegate = self</span><br><span class="line">        self.tableViewLeft.dataSource = self</span><br><span class="line">        self.tableViewLeft.tableFooterView = UIView()</span><br><span class="line">        </span><br><span class="line">        //设置 tableViewRight delegate，并消除多余分割线</span><br><span class="line">        self.tableViewRight.delegate = self</span><br><span class="line">        self.tableViewRight.dataSource = self</span><br><span class="line">        self.tableViewRight.tableFooterView = UIView()</span><br><span class="line"></span><br><span class="line">        //设置 scrollView contentSize</span><br><span class="line">        self.scrollView.contentSize = CGSizeMake(WIDTH * 2, HEIGHT)</span><br><span class="line">        //设置两个 tableView 大小位置</span><br><span class="line">        self.tableViewLeft.frame = CGRectMake(8, 0, WIDTH - 16, HEIGHT)</span><br><span class="line">        self.tableViewRight.frame = CGRectMake(WIDTH + 8, 0, WIDTH - 16, HEIGHT)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">        //可以通过判断当前 tableView 是否与某一个 TableView 相同来给定对应内容</span><br><span class="line">//        if tableView == self.tableViewRight &#123;</span><br><span class="line">//            if self.notifications[indexPath.row].images.count == 1 &#123;</span><br><span class="line">//                let cell = LikeWithPicCell()</span><br><span class="line">//                cell.initCell(self.notifications[indexPath.row])</span><br><span class="line">//                return cell</span><br><span class="line">//            &#125; else &#123;</span><br><span class="line">//                let cell = LikeWithPicsCell()</span><br><span class="line">//                cell.initCell(self.notifications[indexPath.row])</span><br><span class="line">//                return cell</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;</span><br><span class="line">        </span><br><span class="line">        if self.notifications[indexPath.row].images.count == 1 &#123;</span><br><span class="line">            let cell = tableView.dequeueReusableCellWithIdentifier(&quot;LikeWithPicCell&quot;) as! LikeWithPicCell</span><br><span class="line">            cell.initCell(self.notifications[indexPath.row])</span><br><span class="line">            return cell</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let cell = tableView.dequeueReusableCellWithIdentifier(&quot;LikeWithPicsCell&quot;) as! LikeWithPicsCell</span><br><span class="line">            cell.initCell(self.notifications[indexPath.row])</span><br><span class="line">            return cell</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">        </span><br><span class="line">        if tableView == self.tableViewRight &#123;</span><br><span class="line">            //此处 -1 是为了让展示内容有区分，因为用的相同数据</span><br><span class="line">            return self.notifications.count - 1</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return self.notifications.count</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</span><br><span class="line">        return UITableViewAutomaticDimension</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</span><br><span class="line">        return UITableViewAutomaticDimension</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func scrollViewDidScroll(scrollView: UIScrollView) &#123;</span><br><span class="line">        //判断当前 scrollView 是我们项目中的 ScrollView 而非那两个 tableView</span><br><span class="line">        if scrollView == self.scrollView &#123;</span><br><span class="line">            //改变 scrollBar x 坐标，达成同步滑动效果。</span><br><span class="line">            let offsetX = scrollView.contentOffset.x</span><br><span class="line">            self.scrollBar.frame = CGRectMake(offsetX / 2, 87, self.view.frame.width / 2, 3)</span><br><span class="line">            </span><br><span class="line">            //对应修改 btn 文字颜色</span><br><span class="line">            if offsetX &gt; self.view.frame.width / 2 &#123;</span><br><span class="line">                self.followBtn.setTitleColor(UIColor.blackColor(), forState: .Normal)</span><br><span class="line">                self.youBtn.setTitleColor(COLOR_LIGHT_BLUE, forState: .Normal)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self.followBtn.setTitleColor(COLOR_LIGHT_BLUE, forState: .Normal)</span><br><span class="line">                self.youBtn.setTitleColor(UIColor.blackColor(), forState: .Normal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @IBAction func followBtnPressed(sender: UIButton) &#123;</span><br><span class="line">        //点击按钮时，通过动画移动到对应 tableView</span><br><span class="line">        UIView.animateWithDuration(0.3, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">            self.scrollView.contentOffset.x = 0</span><br><span class="line">            &#125;, completion: nil)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @IBAction func youBtnPressed(sender: UIButton) &#123;</span><br><span class="line">        //点击按钮时，通过动画移动到对应 tableView</span><br><span class="line">        UIView.animateWithDuration(0.3, delay: 0, options: [.CurveEaseInOut], animations: &#123; () -&gt; Void in</span><br><span class="line">            self.scrollView.contentOffset.x = self.view.frame.width</span><br><span class="line">            &#125;, completion: nil)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个项目中，我懒所以两个 TableView 用的相同的 Prototype Cell 和同一组数据，然后在返回第二个 TableView cell 个数时 -1，好在显示时区分二者。</p>
<h3 id="需要注意的几点"><a href="#需要注意的几点" class="headerlink" title="需要注意的几点"></a>需要注意的几点</h3><ol>
<li><p>当在一个 ViewController 里面包含多个 TableView 的时候，使用 TableView Delegate 提供的方法时，可以通过判断参数 tableView 是否与项目中对应 TableView 相同来执行对应操作。如上面代码中提到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">    </span><br><span class="line">    if tableView == self.tableViewRight &#123;</span><br><span class="line">        //此处 -1 是为了让展示内容有区分，因为用的相同数据</span><br><span class="line">        return self.notifications.count - 1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self.notifications.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同上，有多个 scrollView 时，同样方法判定当前是哪个 scrollView。</p>
</li>
<li>UITableView 为 UIScrollView 的子类。如果添加了 scrollView delegate，不进行判断的话，可能会出现上下滑动 tableView 时触发 scrollViewDidScroll 方法，导致在第二页时上下滑动时 tab 标签切换到第一个标签。</li>
<li>不要忘记设置 scrollView.delegate</li>
<li>不要忘记设置 scrollView.contentSize</li>
<li>通过设置空白 tableFooterView 为空白 UIView，消除多余分割线。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关键词：Swift，实现多个 TableView 的侧滑与切换，在 ScrollView 中嵌套多个 TableView，一个页面显示两个 tableview…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标与成果&quot;&gt;&lt;a href=&quot;#目标与成果&quot; class=&quot;headerlink&quot; title=&quot;目标与成果&quot;&gt;&lt;/a&gt;目标与成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;将多个 TableView 放在 ScrollView 里面，将 ScrollView Paging 设置为 Enabled，实现多个 TableView 的侧滑与切换。&lt;/p&gt;
&lt;p&gt;上方的 tab 标签跟随 ScrollView.offset.x 进行动画，蓝条为单独绘制的一个长方形 UIView。&lt;/p&gt;
&lt;p&gt;通过 UIButton 的 IBAction 中的动画，实现点击 tab 标签滑动到对应 TableView。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UITableView" scheme="http://chengkang.me/tags/UITableView/"/>
    
      <category term="UIScrollView" scheme="http://chengkang.me/tags/UIScrollView/"/>
    
  </entry>
  
  <entry>
    <title>实现 instagram 底部弹出菜单的一个例子（模拟 instagram 系列）</title>
    <link href="http://chengkang.me/2016/04/03/%E5%AE%9E%E7%8E%B0%20instagram%20%E5%BA%95%E9%83%A8%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88%E6%A8%A1%E6%8B%9F%20instagram%20%E7%B3%BB%E5%88%97%EF%BC%89/"/>
    <id>http://chengkang.me/2016/04/03/实现 instagram 底部弹出菜单的一个例子（模拟 instagram 系列）/</id>
    <published>2016-04-03T22:51:08.000Z</published>
    <updated>2016-04-06T01:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标和成果"><a href="#目标和成果" class="headerlink" title="目标和成果"></a>目标和成果</h3><p>instagram 截图如下：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_IMG_8669.PNG" alt=""></p>
<p>成果如下：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-1.gif" alt=""></p>
<p>要实现的内容：</p>
<ol>
<li>黑色半透明遮罩层</li>
<li>弹出动画</li>
<li>点击取消按钮或者背景菜单收回</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>应该是有一种跟 UIPresentationController 有关的解决方法，但是我还不会，所以这次不用。</p>
<p>之前在模拟微博的项目里也用到了弹出层，所以我想这次也义勇和上次同样的方式，在 TabBarController 里面添加 subview。</p>
<p>但有两点不同：</p>
<ol>
<li>上次是点击 tabBarItem 来执行弹出，这次要点击第一个 tab 页里的按钮。怎么样让 TabBarController 得到消息？</li>
<li>上次弹出的按钮是独立的，这次弹出的菜单和指定的图片有关。所以需要有一个标志记录当前点击的是哪一张图片的 more 按钮。<a id="more"></a>
<h3 id="解决方案-Part-1-创建菜单视图"><a href="#解决方案-Part-1-创建菜单视图" class="headerlink" title="解决方案 Part.1 创建菜单视图"></a>解决方案 Part.1 创建菜单视图</h3></li>
</ol>
<p>在 storyboard 拖进一个 ViewController，添加好内容，设置好约束。如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-03%20at%2011.25.13%20PM.png" alt=""></p>
<p>注意，这个 ViewController 的 root view 要讲背景设置为 黑色、透明度 30%，以模拟遮罩层。</p>
<p>新建一个视图文件 BottomMenuView.swift，继承 UIViewController。修改刚才新建的 ViewController 类为 BottomMenuView，并设置 StoryboardID 为”BottomMenu”。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-03%20at%2011.49.49%20PM.png" alt=""></p>
<p>关联好 IBOutlet 对象和点击事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class BottomMenuView: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var menuBgView: UIView!</span><br><span class="line">    @IBOutlet weak var reportBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var shareToFacebookBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var tweetBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var copyURLBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var noticeBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var dismissBtn: UIButton!</span><br><span class="line">    @IBOutlet weak var buttonPanel: UIView!</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func viewDidAppear(animated: Bool) &#123;</span><br><span class="line">        //这里是设置颜色、按钮边框形状。</span><br><span class="line">        let maskPathAllCorner = UIBezierPath(roundedRect: noticeBtn.bounds,</span><br><span class="line">            byRoundingCorners: [.BottomLeft, .BottomRight, .TopLeft, .TopRight],</span><br><span class="line">            cornerRadii: CGSize(width: 5, height: 5.0))</span><br><span class="line">        let maskPathTopCorner = UIBezierPath(roundedRect: noticeBtn.bounds,</span><br><span class="line">            byRoundingCorners: [.TopLeft, .TopRight],</span><br><span class="line">            cornerRadii: CGSize(width: 5, height: 5.0))</span><br><span class="line">        let maskPathBottomCorner = UIBezierPath(roundedRect: noticeBtn.bounds,</span><br><span class="line">            byRoundingCorners: [.BottomLeft, .BottomRight],</span><br><span class="line">            cornerRadii: CGSize(width: 5, height: 5.0))</span><br><span class="line">        let shapeAllCorner = CAShapeLayer()</span><br><span class="line">        shapeAllCorner.path = maskPathAllCorner.CGPath</span><br><span class="line">        let shapeTopCorner = CAShapeLayer()</span><br><span class="line">        shapeTopCorner.path = maskPathTopCorner.CGPath</span><br><span class="line">        let shapeBottomCorner = CAShapeLayer()</span><br><span class="line">        shapeBottomCorner.path = maskPathBottomCorner.CGPath</span><br><span class="line">        </span><br><span class="line">        reportBtn.layer.mask = shapeTopCorner</span><br><span class="line">        noticeBtn.layer.mask = shapeBottomCorner</span><br><span class="line">        dismissBtn.layer.mask = shapeAllCorner</span><br><span class="line">    &#125;</span><br><span class="line">    @IBAction func bgTapped(sender: UITapGestureRecognizer) &#123;</span><br><span class="line">        //给背景 view 添加一个点击事件</span><br><span class="line">        //当点击时，让菜单收回</span><br><span class="line">    &#125;</span><br><span class="line">    @IBAction func dismissBtnPressed(sender: UIButton) &#123;</span><br><span class="line">		    //点击事件，当点击时，让菜单收回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 TabBarViewController.swift 中，修改 viewDidLoad 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    self.tabBar.tintColor = UIColor.whiteColor()</span><br><span class="line">    for it in self.tabBar.items! &#123;</span><br><span class="line">        it.badgeValue = &quot;100&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.delegate = self</span><br><span class="line">    </span><br><span class="line">    //找到对应视图，并添加为 TabBarView 的子视图。子视图默认 alpha 值为0。</span><br><span class="line">    //这样每次只用修改 alpha 值来显示和隐藏，不用重新添加子视图。</span><br><span class="line">    self.bottomMenu = self.storyboard?.instantiateViewControllerWithIdentifier(&quot;BottomMenu&quot;) as! BottomMenuView</span><br><span class="line">    self.bottomMenu.modalTransitionStyle = .CoverVertical</span><br><span class="line">    self.view.addSubview(self.bottomMenu.view)</span><br><span class="line">    self.bottomMenu.view.alpha = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="解决方案-Part-2-给-TabBarController-传递消息"><a href="#解决方案-Part-2-给-TabBarController-传递消息" class="headerlink" title="解决方案 Part.2 给 TabBarController 传递消息"></a>解决方案 Part.2 给 TabBarController 传递消息</h3><p>因为 more 按钮在 tab 页的 viewController 里面，我们暂时没办法直接执行 TabBarController 里面的函数，或者对它的 view 进行操作，所以要想个办法发送通知。</p>
<p>发送通知当然是用 NSNotification。</p>
<p><strong>发送显示菜单通知</strong></p>
<p>在 firstViewController （即第一个 tab 页的 controller）中添加 more 按钮点击事件，在里面发送一个通知。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func moreButtonPressed(sender: UIButton) &#123;</span><br><span class="line">	NSNotificationCenter.defaultCenter().postNotification(NSNotification(name: &quot;ShowBottomMenu&quot;, object: sender.tag))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个通知里面，object 是当前按钮的 tag 值。这是在每个 cell 初始化的时候，给当前 cell 的每个 button 的 tag 赋值为当前图片的 id，保证之后能够判断每个点击事件来自哪个 cell/图片。</p>
<p><strong>发送收回菜单通知</strong></p>
<p>回到 BottomMenuView.swift，在两个点击事件添加发送通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func bgTapped(sender: UITapGestureRecognizer) &#123;</span><br><span class="line">    NSNotificationCenter.defaultCenter().postNotification(NSNotification(name: &quot;DismissBottomMenu&quot;, object: nil))</span><br><span class="line">&#125;</span><br><span class="line">@IBAction func dismissBtnPressed(sender: UIButton) &#123;</span><br><span class="line">    </span><br><span class="line">    NSNotificationCenter.defaultCenter().postNotification(NSNotification(name: &quot;DismissBottomMenu&quot;, object: nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>接收通知</strong></p>
<p>在 TabBarViewController.swift 的 viewDidLoad 方法中添加一下两行用于接收通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;showBottomMenu:&quot;, name: &quot;ShowBottomMenu&quot;, object: nil)</span><br><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector: &quot;dismissBottomMenu:&quot;, name: &quot;DismissBottomMenu&quot;, object: nil)</span><br></pre></td></tr></table></figure></p>
<p>经过上面的步骤，TabBarViewController 就能接收到显示或者收回底部菜单的通知了。然后我们可以在自定义的函数里面编写显示和隐藏的动画。</p>
<h3 id="解决方案-Part-3-显示-收回菜单动画"><a href="#解决方案-Part-3-显示-收回菜单动画" class="headerlink" title="解决方案 Part.3 显示/收回菜单动画"></a>解决方案 Part.3 显示/收回菜单动画</h3><p>这部分很简单啦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func showBottomMenu(notification: NSNotification) &#123;</span><br><span class="line">    //获取当前 section id</span><br><span class="line">    let tag = notification.object as! Int</span><br><span class="line">    print(tag)</span><br><span class="line">    </span><br><span class="line">    self.bottomMenu.buttonPanel.frame.origin.y = self.view.frame.height</span><br><span class="line">    UIView.animateWithDuration(0.3) &#123; () -&gt; Void in</span><br><span class="line">        self.bottomMenu.view.alpha = 1</span><br><span class="line">        self.bottomMenu.buttonPanel.frame.origin.y = self.view.frame.height - self.bottomMenu.buttonPanel.frame.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func dismissBottomMenu(notification: NSNotification) &#123;</span><br><span class="line">    print(notification.object)</span><br><span class="line">    UIView.animateWithDuration(0.3) &#123; () -&gt; Void in</span><br><span class="line">        self.bottomMenu.view.alpha = 0</span><br><span class="line">        self.bottomMenu.buttonPanel.frame.origin.y = self.view.frame.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 showBottomMenu 方法中，获取到了一个 tag 值，这个是留着将来编写对应的菜单按钮点击事件的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;instagram 截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_IMG_8669.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;成果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;要实现的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;黑色半透明遮罩层&lt;/li&gt;
&lt;li&gt;弹出动画&lt;/li&gt;
&lt;li&gt;点击取消按钮或者背景菜单收回&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;应该是有一种跟 UIPresentationController 有关的解决方法，但是我还不会，所以这次不用。&lt;/p&gt;
&lt;p&gt;之前在模拟微博的项目里也用到了弹出层，所以我想这次也义勇和上次同样的方式，在 TabBarController 里面添加 subview。&lt;/p&gt;
&lt;p&gt;但有两点不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上次是点击 tabBarItem 来执行弹出，这次要点击第一个 tab 页里的按钮。怎么样让 TabBarController 得到消息？&lt;/li&gt;
&lt;li&gt;上次弹出的按钮是独立的，这次弹出的菜单和指定的图片有关。所以需要有一个标志记录当前点击的是哪一张图片的 more 按钮。
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>自定义 UITabBar 总结（一个模拟 instagram TabBar 的例子）</title>
    <link href="http://chengkang.me/2016/03/31/%E8%87%AA%E5%AE%9A%E4%B9%89%20UITabBar%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%8B%9F%20instagram%20TabBar%20%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%89/"/>
    <id>http://chengkang.me/2016/03/31/自定义 UITabBar 总结（一个模拟 instagram TabBar 的例子）/</id>
    <published>2016-03-31T22:48:38.000Z</published>
    <updated>2016-04-06T01:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目 github 仓库：<a href="https://github.com/cheng-kang/iosDev/tree/master/Instagram" target="_blank" rel="external">模拟 instagram</a></p>
</blockquote>
<h3 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h3><p>我在练习 iOS 开发。</p>
<p>碰到了跟 TabBar 有关的东西，希望自己尽量对 TabBar 的使用了解清楚而不是直接复制粘贴，所以整体研究一番，在此总结。</p>
<p>内容主要跟 TabBar 的样式修改有关，涉及到一点点点击事件。文中提到的诸如<code>比较重要的方法</code>、<code>比较重要的属性</code>的重要性均是相对本文内容而言。</p>
<p>要实现的结果如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.46.56%20PM.png" alt=""></p>
<p>其中，点击中间按钮时，不激活那个 tab 页，而是执行自定义的任务。（因为 instagram 中间那个按钮功能就是和其他的不一样嘛。）</p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p>首先，敬上四篇相关文档：</p>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarController_Class/" target="_blank" rel="external">UITabBarController Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarControllerDelegate_Protocol/index.html#//apple_ref/occ/intf/UITabBarControllerDelegate" target="_blank" rel="external">UITabBarControllerDelegate Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBar_Class/index.html#//apple_ref/occ/cl/UITabBar" target="_blank" rel="external">UITabBar Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarItem_Class/index.html#//apple_ref/occ/cl/UITabBarItem" target="_blank" rel="external">UITabBarItem Class Reference</a><a id="more"></a>
<h3 id="UITabBarController、UITabBarControllerDelegate、UITabBar-和-UITabBarItem"><a href="#UITabBarController、UITabBarControllerDelegate、UITabBar-和-UITabBarItem" class="headerlink" title="UITabBarController、UITabBarControllerDelegate、UITabBar 和 UITabBarItem"></a>UITabBarController、UITabBarControllerDelegate、UITabBar 和 UITabBarItem</h3></li>
</ul>
<blockquote>
<p>先来一点没那么有趣的东西：D。</p>
</blockquote>
<p><strong>UITabBarController</strong><br>当你使用 UITabBarController 的时候，你可以新建一个类继承 UITabBarController 来管理你的 TabBar 及相关事件。</p>
<p>UITabBarController 包含许多属性，与本文相关的比较重要的几个属性是：</p>
<ul>
<li>delegate：一个 UITabBarControllerDelegate 对象，用于追踪和处理一些 TabBar 事件。</li>
<li>tabBar： 一个 UITabBar 对象，直接一点说就是你在屏幕上看到的那个 TabBar。</li>
<li>viewControllers：每个 Tab 页面对应的 viewController 组成的列表。可以通过排列顺序值获取对应 viewController，比如第一个 tab 的 viewController 为：self.viewControllers[0]。</li>
</ul>
<p><strong>UITabBarControllerDelegate</strong><br>一个比较重要的方法：</p>
<ul>
<li><code>override func tabBarController(_ tabBarController: UITabBarController, shouldSelectViewController viewController: UIViewController) -&gt; Bool</code><br>用于决定被选中的 tab 是否激活。当返回值是 false 时，保留在之前的 tab 页面；当返回值是 true 时，激活当前选中的 tab 页面。</li>
</ul>
<p><strong>UITabBar</strong></p>
<p>几个重要的属性：</p>
<ul>
<li>items：一个 UITabBarItem 列表，即每一个 tab 按钮对象组成的列表。</li>
<li>selectedItem：当前被选中的 TabBarItem。</li>
<li>tintColor：覆盖被选中的 TabBarItem 图片的颜色。（默认为蓝色。就是选中时图标的颜色。）<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.43.26%20PM.png" alt=""><ul>
<li>barTintColor：整个 TabBar 的背景颜色。</li>
</ul>
</li>
</ul>
<p><strong>UITabBarItem</strong></p>
<p>几个重要的方法和属性：</p>
<ul>
<li>初始化方法（init(…)）。可以通过 init 方法新建 TabBarItem，并赋予指定初始值，比如图片、图片颜色、选中状态时的图片及颜色、tag 值等等。</li>
<li>badgeValue：看图。通过设置这个值可以直接得到这个效果，我觉得挺有意思的，很省事的样子。<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.39.12%20PM.png" alt=""></li>
<li>selectedImage：TabBarItem 被选中时显示的图片，默认和未选中状态图片一样。</li>
</ul>
<h3 id="TabBar-基本样式的设置"><a href="#TabBar-基本样式的设置" class="headerlink" title="TabBar 基本样式的设置"></a>TabBar 基本样式的设置</h3><p>我目前的看法是，<strong>能用 storyboard 解决的一定不用代码</strong>。所以基本样式设置全部在 storyboard 完成。</p>
<p><strong>TabBar</strong></p>
<p>选中 TabBar，打开右侧的属性面板。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.58.59%20PM.png" alt=""><br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen_Shot_2016-03-31_at_8_59_09_PM.png" alt=""></p>
<ul>
<li>一般都不用修改 item Positioning，默认是居中均匀分布，应该符合大部分需求。</li>
<li>Translucent 半透明度可以根据需要勾选。像微博的客户端就是半透明的，而instagram 不是。</li>
<li>没有特别需求的话，可以直接在这里设置 Image Tint。我们这个例子在代码里面设置。</li>
<li>Style：系统提供了 Default 默认的白色背景和可选的 Black 黑色背景。可根据需要选择。如图：</li>
</ul>
<p><strong>TabBarItem</strong></p>
<p>选中 tab 页面的 viewController 底部的 tab 图标。右侧的属性面板如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.20.49%20PM.png" alt=""></p>
<p>先看下面的：</p>
<ul>
<li>Title：就是在图标下显示的文字。可以为空，可以通过 Title Position 调整位置。</li>
<li>Image：图标的图片。</li>
<li>Tag：当前 TabBarItem 的标志，设置一个值方便在代码里找到对应的 TabBarItem。</li>
<li>Enabled：没什么好说的：）</li>
</ul>
<p>然后是这些：</p>
<ul>
<li>Badge：就是之前提到过的红点。可以在这里设置一个初始值。</li>
<li>System Item：一些系统自带的 Tab 图标，根据需要自行取用。一般还是用自己的图吧。</li>
<li>Selected Image：tab 被选中的时候的图片。</li>
<li>Title Postition：设置 title 的位置。<br>可以如图设置<code>水平偏移</code>和<code>垂直偏移</code>。</li>
</ul>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.28.11%20PM.png" alt=""></p>
<p><strong>值得注意的是：水平偏移对图标有影响，垂直偏移对图标没有影响。</strong>效果如图，红线是我自己加的一条中线，用于对比。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.28.19%20PM.png" alt=""></p>
<p>One more thing :)</p>
<p>属性面板右边有一个设置尺寸的面板：<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.34.25%20PM.png" alt=""><br>在这里可以设置图标的偏移量，从而修改图标的位置。</p>
<p>因为默认图标在 Title上面，位置偏高，就算没有 Title 图标也在那个位置。所以当我们不用 Title 的时候，像 instagram，需要调整图标的位置，让它看起来居中一点。</p>
<p>一种是直接在面板设置，一种是用代码设置。<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.40.26%20PM.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tabBarItem.imageInsets = UIEdgeInsetsMake(6, 0, -6, 0);</span><br></pre></td></tr></table></figure></p>
<p>对比效果如图：<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.40.45%20PM.png" alt=""></p>
<p><strong>注意：top 和 bottom 要设置成相反数，不然点击 tab 图标时 image 的大小会一直改变！！！</strong><br>如图：<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_tabbar-1.gif" alt=""></p>
<p><strong>一个建议</strong></p>
<p>有时候需要调整图标的大小，不建议用代码修改或者视图通过 image inset 来修改。</p>
<p>建议做图标的时候，就在图标周围留白。比如 75px 的图片，其中上下左右各留白 20px，这样图标就小了。</p>
<p>另外，根据 Apple 制定的标准，tab 图标准备 3 个尺寸，分别是 75 px（@3x），55px（@2x）和25px。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2011.40.42%20PM.png" alt=""></p>
<h3 id="TabBar-个性化样式设置要求（大家好，重点要开始了：D）"><a href="#TabBar-个性化样式设置要求（大家好，重点要开始了：D）" class="headerlink" title="TabBar 个性化样式设置要求（大家好，重点要开始了：D）"></a>TabBar 个性化样式设置要求（大家好，重点要开始了：D）</h3><p>经过之前一些简单的步骤，你将得到如图效果：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.50.54%20PM.png" alt=""></p>
<p>记得将五个 TabBarItem 的 tag 设置为 0 - 5，方便以后。</p>
<p>但是我们要实现的不是这么简单。</p>
<p><strong>要求：</strong></p>
<ul>
<li>选中 TabBarItem 背景颜色为黑色。</li>
<li>未选中 TabBarItem 背景颜色为某种灰色。</li>
<li>选中 TabBarItem 图标颜色为白色。</li>
<li>未选中 TabBarItem 图标颜色为某种灰色。</li>
<li>中间按钮始终背景颜色为某种蓝色、图标颜色为白色。</li>
</ul>
<h3 id="如何在-UITabBarController-中修改样式"><a href="#如何在-UITabBarController-中修改样式" class="headerlink" title="如何在 UITabBarController 中修改样式"></a>如何在 UITabBarController 中修改样式</h3><p>新建一个 Cocoa Touch Class，取名叫<code>MainTabBarViewController</code>，继承 UITabBarController。去 storyboard 把作为入口的那个 UITabBarController 的类修改为<code>MainTabBarViewController</code>。</p>
<p>这个时候，我们就可以在<code>MainTabBarViewController</code>中对 TabBar 进行修改了。</p>
<p>首先来试验一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class MainTabBarViewController: UITabBarController &#123;</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        //设置 tabBar 图标选中时的颜色</span><br><span class="line">        self.tabBar.tintColor = UIColor.whiteColor()</span><br><span class="line">        //遍历全部 tabBarItem，设置 badege 值</span><br><span class="line">        for one in self.tabBar.items! &#123;</span><br><span class="line">            one.badgeValue = &quot;100&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WOW。好酷。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.01.19%20PM.png" alt=""></p>
<ul>
<li><del>选中 TabBarItem 图标颜色为白色。</del> 达成√！！</li>
<li><del>未选中 TabBarItem 图标颜色为某种灰色。</del> 达成√！！</li>
</ul>
<p>然后还顺便尝试了设置 badge 值。</p>
<h3 id="如何通过代码设置单个-TabBarItem-背景颜色"><a href="#如何通过代码设置单个-TabBarItem-背景颜色" class="headerlink" title="如何通过代码设置单个 TabBarItem 背景颜色"></a>如何通过代码设置单个 TabBarItem 背景颜色</h3><p>之前提到过 barTintColor 这个属性。通过<code>self.tabBar.barTintColor = UIColor().greyColor()</code>就可以把背景设置为灰色了。但是这并没有完成被选中 TabBarItem 背景颜色变为黑色的要求。</p>
<p>事实上，<strong>并没有直接设置单个 TabBarItem 背景颜色的方法</strong>。</p>
<p><strong>解决方案</strong></p>
<p>重写 viewDidAppear 方法和 didSelectItem 方法。didSelectItem 是每当有 tabBarItem 被选中时执行的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class MainTabBarViewController: UITabBarController &#123;</span><br><span class="line"></span><br><span class="line">		//定义一个用于存储背景层 view 的列表</span><br><span class="line">    var tabBarItemBgViews: [UIView] = []</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        self.tabBar.tintColor = UIColor.whiteColor()</span><br><span class="line">        for it in self.tabBar.items! &#123;</span><br><span class="line">            it.badgeValue = &quot;100&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func viewDidAppear(animated: Bool) &#123;</span><br><span class="line">		    //初始化需要用到的尺寸数值</span><br><span class="line">        let ITEM_WIDTH = self.tabBar.frame.width / 5</span><br><span class="line">        let ITEM_HEIGHT = CGFloat(49)</span><br><span class="line">        </span><br><span class="line">        //初始化 tab bar item 背景层</span><br><span class="line">        for one in self.tabBar.items! &#123;</span><br><span class="line">            let vw = UIView()</span><br><span class="line">            vw.backgroundColor = UIColor(red: 37/255, green: 29/255, blue: 42/255, alpha: 1)</span><br><span class="line">            vw.frame = CGRectMake(ITEM_WIDTH * CGFloat(one.tag), 0, ITEM_WIDTH, ITEM_HEIGHT)</span><br><span class="line">            self.tabBarItemBgViews.append(vw)</span><br><span class="line">            //将背景层插入到 index 为 1 的位置，这样背景层就在图标下面。记住这个 1 就好了：）</span><br><span class="line">            tabBar.insertSubview(vw, atIndex: 1)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //修改第一个 item 的背景色为选中状态颜色</span><br><span class="line">        self.tabBarItemBgViews[0].backgroundColor = UIColor.blackColor()</span><br><span class="line">        </span><br><span class="line">        //自定义中间按钮样式</span><br><span class="line">        self.tabBarItemBgViews[2].backgroundColor = UIColor(red: 17/255, green: 86/255, blue: 136/255, alpha: 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func tabBar(tabBar: UITabBar, didSelectItem item: UITabBarItem) &#123;</span><br><span class="line">	    //当选中的 TabBarItem 不是中间那个时，改变背景颜色</span><br><span class="line">	    if item.tag != 2 &#123;</span><br><span class="line">	        for one in tabBar.items! &#123;</span><br><span class="line">			        //将当前被选中的 TabBarItem 背景颜色设置为黑色</span><br><span class="line">	            if one.tag == item.tag &#123;</span><br><span class="line">	                self.tabBarItemBgViews[one.tag].backgroundColor = UIColor.blackColor()</span><br><span class="line">	            &#125; else &#123;</span><br><span class="line">	                //将其他 TabBarItem 背景颜色设置为灰色</span><br><span class="line">					        self.tabBarItemBgViews[one.tag].backgroundColor = UIColor(red: 37/255, green: 29/255, blue: 42/255, alpha: 1)</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        </span><br><span class="line">	        //将中间 TabBarItem 的背景颜色重置为蓝色</span><br><span class="line">	        self.tabBarItemBgViews[2].backgroundColor = UIColor(red: 17/255, green: 86/255, blue: 136/255, alpha: 1)</span><br><span class="line">	    &#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码，得到了：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.14.04%20PM.png" alt=""></p>
<p><strong>解释：为什么是重写 viewDidAppear 方法而不是 viewDidLoad</strong></p>
<p>如果把上面那段代码写在<code>viewDidLoad</code>方法中，会出现如下情况：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_tabbar-2.gif" alt=""></p>
<p>可以看到，第一个 TabBarItem 没有图标，而且点击无效。</p>
<p>简单来说，在<code>viewDidLoad</code>的时候，页面的那些视图大概还没准备好，所以插入的时候会有错误。包括写在<code>viewWillAppear</code>中也会出现同样问题。</p>
<p>所以记得重写<code>viewDiaAppear</code>。</p>
<p><strong>两个问题</strong></p>
<ol>
<li>打开 app 的时候，中间按钮图标颜色不是白色。（当然这是因为我们上面代码里面没有设置。）</li>
<li>点击中间按钮，进入了对应的 tab 页面，如图。（这不是我们希望的。）<br><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.24.06%20PM.png" alt=""></li>
</ol>
<h3 id="如何修改-TabBarItem-样式"><a href="#如何修改-TabBarItem-样式" class="headerlink" title="如何修改 TabBarItem 样式"></a>如何修改 TabBarItem 样式</h3><p>初一想，在<code>viewDidAppear</code>结尾加上这段代码就可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将 tabBar 包含的 tabBarItem 中的第二个修改为自定义的一个 UITabBarItem</span><br><span class="line">//使用原本设置的图片，原本设置的 tag 值，并将图片设置为使用原图片。</span><br><span class="line">//imageWithRenderingMode(.AlwaysOriginal)，稍后详细解释</span><br><span class="line">self.tabBar.items![2] = UITabBarItem(title: nil, image: self.tabBarItem.image?.imageWithRenderingMode(.AlwaysOriginal), tag: self.tabBarItem.tag)</span><br><span class="line">//修改偏移量，让图标居中</span><br><span class="line">self.tabBar.items![2].imageInsets = UIEdgeInsetsMake(6, 0, -6, 0)</span><br></pre></td></tr></table></figure></p>
<p>编译也没有问题。但是运行的时候报错了。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.38.58%20PM.png" alt=""></p>
<p><strong>需要注意：不能直接在 tab bar controller 里面修改 tab bar item 的属性</strong></p>
<blockquote>
<p>文档原文是这样说的：<br>”You should never access the tab bar view of a tab bar controller directly. To configure the tabs of a tab bar controller, you assign the view controllers that provide the root view for each tab to the <code>viewControllers</code> property.”<br>这里我觉得 tab bar view 可能说得不够清楚，应该是 tab bar item view。</p>
</blockquote>
<p>可能有同学会对上面我们增加背景有疑问。那难道不是修改 tab bar item 吗？</p>
<p>并不是。上面我们其实是给 TabBar 增加子视图，并定位到各个 TabBarItem 背后，看起来像是在给 TabBarItem 添加背景。并没有直接修改 TabBarItem。</p>
<p><strong>解决方案</strong></p>
<p>如文档所说，我们应该在对应的 viewController 里面去操作。</p>
<p>到我们之前应该创建好了的<code>ThirdViewController.swift</code>里面，写一个用于修改第三个 TabBarItem 样式的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class ThirdViewController: UIViewController, UITabBarControllerDelegate &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func initTabBarItem() &#123;</span><br><span class="line">        //将该 TabBarItem 替换为一个新的</span><br><span class="line">        self.tabBarItem = UITabBarItem(title: nil, image: self.tabBarItem.image?.imageWithRenderingMode(.AlwaysOriginal), tag: self.tabBarItem.tag)</span><br><span class="line">        //设置偏移量</span><br><span class="line">        self.tabBarItem.imageInsets = UIEdgeInsetsMake(6, 0, -6, 0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后回到<code>MainTabBarViewController.swift</code>。加上这两句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let vc = self.viewControllers![2] as! ThirdViewController</span><br><span class="line">vc.initTabBarItem()</span><br></pre></td></tr></table></figure></p>
<p><code>viewDidAppear</code>方法现在应该如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidAppear(animated: Bool) &#123;</span><br><span class="line">    let ITEM_WIDTH = self.tabBar.frame.width / 5</span><br><span class="line">    let ITEM_HEIGHT = CGFloat(49)</span><br><span class="line">    </span><br><span class="line">    //初始化 tab bar item 背景层</span><br><span class="line">    for one in self.tabBar.items! &#123;</span><br><span class="line">        let vw = UIView()</span><br><span class="line">        vw.backgroundColor = UIColor(red: 37/255, green: 29/255, blue: 42/255, alpha: 1)</span><br><span class="line">        vw.frame = CGRectMake(ITEM_WIDTH * CGFloat(one.tag), 0, ITEM_WIDTH, ITEM_HEIGHT)</span><br><span class="line">        self.tabBarItemBgViews.append(vw)</span><br><span class="line">        tabBar.insertSubview(vw, atIndex: 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //修改第一个 item 的背景色为选中状态颜色</span><br><span class="line">    self.tabBarItemBgViews[0].backgroundColor = UIColor.blackColor()</span><br><span class="line">    </span><br><span class="line">    //自定义中间按钮样式</span><br><span class="line">    self.tabBarItemBgViews[2].backgroundColor = UIColor(red: 17/255, green: 86/255, blue: 136/255, alpha: 1)</span><br><span class="line">    //获取第三个 TabBarItem 对应的 viewController，然后调用修改样式函数</span><br><span class="line">    let vc = self.viewControllers![2] as! ThirdViewController</span><br><span class="line">    vc.initTabBarItem()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们用到了之前提到的<code>UITabBarController</code>的<code>viewControllers</code>属性，通过下标获取到对应的<code>viewContrller</code>，然后调用里面的函数，完成样式修改。</p>
<p>效果如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.54.50%20PM.png" alt=""></p>
<ul>
<li><del>中间按钮始终背景颜色为某种蓝色、图标颜色为白色。</del> 达成√！！</li>
</ul>
<p>但是点击中间的按钮还是会进入对应的 tab 页面。下下部分继续解决这个问题。</p>
<h3 id="imageWithRenderingMode（稍微详细的介绍）"><a href="#imageWithRenderingMode（稍微详细的介绍）" class="headerlink" title="imageWithRenderingMode（稍微详细的介绍）"></a>imageWithRenderingMode（稍微详细的介绍）</h3><blockquote>
<p>官方文档：<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#//apple_ref/occ/instm/UIImage/imageWithRenderingMode:" target="_blank" rel="external">imageWithRenderingMode:</a></p>
</blockquote>
<p>UIImage 自身有一个方法是 imageWithRenderingMode()。<br>有三个可选值：</p>
<ul>
<li>.Automatic</li>
<li>.AlwaysOriginal：保持原样</li>
<li>.AlwaysTemplate：留住图片的样板，忽略原图颜色。（比如设置为 tabBarItem.image 的图片，默认是渲染模式（rendering mode）是 .AlwaysTemplate，只保留了形状，默认是灰色。）</li>
</ul>
<p>如果想让 tabBarItem.image 的颜色保持原图颜色，就要用一个 RenderingMode 为 .AlwaysOriginal 的图片替换。也就是上面用到的那种方式。</p>
<h3 id="如何自定义-TabBarItem-点击事件，UITabBarControllerDelegate"><a href="#如何自定义-TabBarItem-点击事件，UITabBarControllerDelegate" class="headerlink" title="如何自定义 TabBarItem 点击事件，UITabBarControllerDelegate"></a>如何自定义 TabBarItem 点击事件，UITabBarControllerDelegate</h3><p>之前提到， <code>override func tabBarController(_ tabBarController: UITabBarController, shouldSelectViewController viewController: UIViewController) -&gt; Bool</code>，用于决定被选中的 tab 是否激活。当返回值是 false 时，保留在之前的 tab 页面；当返回值是 true 时，激活当前选中的 tab 页面。</p>
<p>我们要做的是，当被选中的是第三个 tab 时，保留之前的 tab 页面。</p>
<p>思路就是这样，怎么做呢？</p>
<p><strong>1.设置 UITabBarControllerDelegate</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MainTabBarViewController: UITabBarController, UITabBarControllerDelegate &#123;</span><br><span class="line"></span><br><span class="line">    var tabBarItemBgViews: [UIView] = []</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        self.tabBar.tintColor = UIColor.whiteColor()</span><br><span class="line">        for it in self.tabBar.items! &#123;</span><br><span class="line">            it.badgeValue = &quot;100&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.delegate = self</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>给<code>MainTabBarViewController</code>类添加<code>UITabBarControllerDelegate</code>委托，并在<code>viewDidLoad</code>中将自己的 delegate 设置为自己。</p>
<p>这个时候我们就可以在<code>MainTabBarViewController</code>中实现<code>UITabBarControllerDelegate</code>中的方法来监控和响应事件。</p>
<p>重写如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func tabBarController(tabBarController: UITabBarController, shouldSelectViewController viewController: UIViewController) -&gt; Bool &#123;</span><br><span class="line">    if viewController.tabBarItem.tag == 2 &#123;</span><br><span class="line">		    print(viewController.tabBarItem.tag)</span><br><span class="line">        return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当被选中 tabBarItem.tag 等于 2 时，即为中间按钮时，返回 false，保留之前的 tab 页面；否则切换到新页面。</p>
<p>效果如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_tabbar-3.gif" alt=""></p>
<p>其中<code>print()</code>方法是用来演示，我们可以在这里做一些其他的事情，比如像 instagram 一样弹出拍照页面。具体实现可以参考我之前的模拟微博项目。之后我也会继续完成模拟 instagram 项目，到时候也可以在我 github 看到。</p>
<p>如图，当点击中间按钮时，打印出了tag值。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2011.25.41%20PM.png" alt=""></p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>以上就是对自定义 TabBar 样式以及一点点事件相关的总结。</p>
<p>希望对大家有帮助。</p>
<p>因为我也是刚开始自学 iOS 开发，遇到很多问题需要花很长时间去找答案。所以希望能写出一些有意义的总结，和其他初学者分享，减少大家找不到解决方案的烦恼。</p>
<p>：D</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目 github 仓库：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Instagram&quot;&gt;模拟 instagram&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;我在练习 iOS 开发。&lt;/p&gt;
&lt;p&gt;碰到了跟 TabBar 有关的东西，希望自己尽量对 TabBar 的使用了解清楚而不是直接复制粘贴，所以整体研究一番，在此总结。&lt;/p&gt;
&lt;p&gt;内容主要跟 TabBar 的样式修改有关，涉及到一点点点击事件。文中提到的诸如&lt;code&gt;比较重要的方法&lt;/code&gt;、&lt;code&gt;比较重要的属性&lt;/code&gt;的重要性均是相对本文内容而言。&lt;/p&gt;
&lt;p&gt;要实现的结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.46.56%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，点击中间按钮时，不激活那个 tab 页，而是执行自定义的任务。（因为 instagram 中间那个按钮功能就是和其他的不一样嘛。）&lt;/p&gt;
&lt;h3 id=&quot;相关文档&quot;&gt;&lt;a href=&quot;#相关文档&quot; class=&quot;headerlink&quot; title=&quot;相关文档&quot;&gt;&lt;/a&gt;相关文档&lt;/h3&gt;&lt;p&gt;首先，敬上四篇相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarController_Class/&quot;&gt;UITabBarController Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarControllerDelegate_Protocol/index.html#//apple_ref/occ/intf/UITabBarControllerDelegate&quot;&gt;UITabBarControllerDelegate Protocol Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBar_Class/index.html#//apple_ref/occ/cl/UITabBar&quot;&gt;UITabBar Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarItem_Class/index.html#//apple_ref/occ/cl/UITabBarItem&quot;&gt;UITabBarItem Class Reference&lt;/a&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UITabBar" scheme="http://chengkang.me/tags/UITabBar/"/>
    
      <category term="UITabBatItem" scheme="http://chengkang.me/tags/UITabBatItem/"/>
    
      <category term="UITabBarController" scheme="http://chengkang.me/tags/UITabBarController/"/>
    
      <category term="UITabBarControllerDelegate" scheme="http://chengkang.me/tags/UITabBarControllerDelegate/"/>
    
  </entry>
  
  <entry>
    <title>仿微博 iOS 客户端 TabBar 中间按钮</title>
    <link href="http://chengkang.me/2016/03/30/%E4%BB%BF%E5%BE%AE%E5%8D%9A%20iOS%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20TabBar%20%E4%B8%AD%E9%97%B4%E6%8C%89%E9%92%AE/"/>
    <id>http://chengkang.me/2016/03/30/仿微博 iOS 客户端 TabBar 中间按钮/</id>
    <published>2016-03-30T01:02:07.000Z</published>
    <updated>2016-04-06T01:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/cheng-kang/iosDev/tree/master/Weibo" target="_blank" rel="external">模仿微博客户端项目源码</a></p>
</blockquote>
<p>我在模仿微博 iOS 客户端。如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.05.03%20AM%20copy.png" alt=""></p>
<p>微博客户端 TabBar 中间按钮和其他按钮不一样，一个是样式不一样，一个是点击事件不一样。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一个想法其实是建一个 UITabBarController 的子类，自定义 TabBar 的样式，但是因为还没学习过，所以这次希望另找一个办法。</p>
<p>第二个想法是用一个 button 覆盖 TabBar 中间按钮。无非就是在代码里新建一个<code>UIButton</code>，用<code>CGRectMake()</code>定位。</p>
<h3 id="一个错误的尝试"><a href="#一个错误的尝试" class="headerlink" title="一个错误的尝试"></a>一个错误的尝试</h3><a id="more"></a> 
<p>有了上面的思路，我就在首页的 ViewController 中的<code>viewDidLoad()</code>方法中添加了如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//100px 高宽随便设置用来测试的。</span><br><span class="line">let postBtn = UIButton()</span><br><span class="line">postBtn.frame = CGRectMake(self.view.frame.width/2 - 50, self.view.frame.height - 100, 100, 100)</span><br><span class="line">postBtn.setBackgroundImage(UIImage(named: &quot;post_btn&quot;), forState: .Normal)</span><br><span class="line">self.view.addSubview(postBtn)</span><br></pre></td></tr></table></figure></p>
<p>结果如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.16.31%20AM.png" alt=""></p>
<p><strong>两个问题</strong></p>
<ul>
<li>按钮被什么东西挡住了？</li>
<li>这个按钮添加在首页的 View 里面，所以只有首页有，其他 tab 怎么办？每个 tab 写一个吗？</li>
</ul>
<p><strong>问题一</strong></p>
<p>在 Tabbed Application，底部始终有一个在最上层的 TabBar。每一个 tab 页面的 view 都在 TabBar 下面，所以在 tab 页面的 view 中在 TabBar 所在的位置添加子 subview，subview 会被盖住。</p>
<p>所以思路二行不通了吗？</p>
<p><strong>问题二</strong></p>
<p>重复一点代码倒没什么，不过有没有办法避免呢？</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我发现作为 Initial View Controller 的这个 Tab Bar View Controller 也可以添加一个自定义的 ViewController。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.31.34%20AM2.png" alt=""></p>
<p>于是我新建了一个 UITabBarController 的子类。在<code>viewDidLoad()</code>中添加了 button。下面的代码是调整过 button 大小位置后的最终代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//  TabBarViewController.swift</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class TabBarViewController: UITabBarController &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        //  初始化一些要用到的参数</span><br><span class="line">        let WINDOW_HEIGHT = self.view.frame.height</span><br><span class="line">        let TAB_HEIGHT = self.tabBar.frame.height</span><br><span class="line">        let GRID_WIDTH = self.view.frame.width / 5</span><br><span class="line">        let MARGIN_X = CGFloat(2)</span><br><span class="line">        let MARGIN_Y = CGFloat(5)</span><br><span class="line">        let BTN_WIDTH = TAB_HEIGHT - MARGIN_X * 2</span><br><span class="line">        let BTN_HEIGHT = TAB_HEIGHT - MARGIN_Y * 2</span><br><span class="line">        </span><br><span class="line">        //  遮罩层，用于遮挡原本的 TabBarItem</span><br><span class="line">        let modalView = UIView()</span><br><span class="line">        modalView.frame = CGRectMake(GRID_WIDTH * 2, WINDOW_HEIGHT - TAB_HEIGHT, GRID_WIDTH, TAB_HEIGHT)</span><br><span class="line">        self.view.addSubview(modalView)</span><br><span class="line">        </span><br><span class="line">        //  添加自定义按钮</span><br><span class="line">        let postBtn = UIButton()</span><br><span class="line">        postBtn.frame = CGRectMake(GRID_WIDTH * 2 + (GRID_WIDTH - BTN_WIDTH) / 2, WINDOW_HEIGHT - TAB_HEIGHT + MARGIN_Y, BTN_WIDTH, BTN_HEIGHT)</span><br><span class="line">        postBtn.setBackgroundImage(UIImage(named: &quot;post_btn&quot;), forState: .Normal)</span><br><span class="line">        self.view.addSubview(postBtn)</span><br><span class="line">        </span><br><span class="line">        //  给按钮添加事件</span><br><span class="line">        postBtn.addTarget(self, action: &quot;postButtonClicked:&quot;, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如图：</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.05.03%20AM.png" alt=""></p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><strong>对于问题一</strong></p>
<p>因为是直接在 TabBarController 的 view 上添加 subview，所以按钮正常显示。</p>
<p><strong>对于问题二</strong></p>
<p>因为 TabBar 是所有 tab 页面公用的，所以不用在每个页面单独添加按钮。</p>
<p><strong>遮罩层的作用</strong></p>
<p>因为自定义按钮的大小没有覆盖 TabBar 中间 item 的大小，所以点击边缘部分会进入对应的 tab 页面。而微博客户端这个按钮点击后，应该是出现如下页面，而非进入 tab 页。所以用遮罩层挡住那个 TabBar item。</p>
<p><img src="http://7u2sl0.com1.z0.glb.clouddn.com/ios_weibo-1.gif" alt=""></p>
<p><strong>自定义按钮的点击事件</strong></p>
<p>这个加号按钮点击完之后应该是出现一个半透明视图，包含一些按钮。所以我在最后给按钮添加了一个点击事件，负责完成显示新视图及其中的动画。</p>
<p>如果对这个半透明视图和其中动画的实现有兴趣，可以到我 github 下载源码看看。因为都是最基本的 Animation，所以可能不会单独写一篇分享。</p>
<blockquote>
<p><a href="https://github.com/cheng-kang/iosDev/tree/master/Weibo" target="_blank" rel="external">模拟微博客户端 github 仓库</a></p>
</blockquote>
<p>个人觉得值得注意的是，我的解决方案是：这个半透明视图在第一次出现之后就保存在 TabBarViewController 的类成员变量里，之后的关闭和再显示只是将视图的 alpha 值在 0 和 1 之间切换。</p>
<p>说不定也会总结一次。因为实现过程中踩到一些跟 Animation 有关的坑，比如<strong>有些属性变换是立即执行的，不能用动画渐变实现</strong>。</p>
<p>基本的 Animation 知识，建议去看 <a href="http://weibo.com/yongjianlin" target="_blank" rel="external">@林永坚Jake </a> 在慕课网发布的 <a href="http://www.imooc.com/learn/392" target="_blank" rel="external">iOS-动画入门</a> 和 <a href="http://www.imooc.com/learn/395" target="_blank" rel="external">iOS-动画进阶</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Weibo&quot;&gt;模仿微博客户端项目源码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在模仿微博 iOS 客户端。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.05.03%20AM%20copy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;微博客户端 TabBar 中间按钮和其他按钮不一样，一个是样式不一样，一个是点击事件不一样。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;第一个想法其实是建一个 UITabBarController 的子类，自定义 TabBar 的样式，但是因为还没学习过，所以这次希望另找一个办法。&lt;/p&gt;
&lt;p&gt;第二个想法是用一个 button 覆盖 TabBar 中间按钮。无非就是在代码里新建一个&lt;code&gt;UIButton&lt;/code&gt;，用&lt;code&gt;CGRectMake()&lt;/code&gt;定位。&lt;/p&gt;
&lt;h3 id=&quot;一个错误的尝试&quot;&gt;&lt;a href=&quot;#一个错误的尝试&quot; class=&quot;headerlink&quot; title=&quot;一个错误的尝试&quot;&gt;&lt;/a&gt;一个错误的尝试&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://chengkang.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
      <category term="UITabBar" scheme="http://chengkang.me/tags/UITabBar/"/>
    
  </entry>
  
</feed>
