<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENG KANG</title>
  <subtitle>Hello World Anyway</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cheng-kang.github.io/"/>
  <updated>2016-06-21T14:08:09.000Z</updated>
  <id>http://cheng-kang.github.io/</id>
  
  <author>
    <name>程康·Ant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】JavaScript 中的命名空间</title>
    <link href="http://cheng-kang.github.io/2016/06/21/Namespacing%20in%20JavaScript/"/>
    <id>http://cheng-kang.github.io/2016/06/21/Namespacing in JavaScript/</id>
    <published>2016-06-21T13:59:30.000Z</published>
    <updated>2016-06-21T14:08:09.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Namespacing in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-中的命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-中的命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的命名空间&quot;&gt;&lt;/a&gt;JavaScript 中的命名空间&lt;/h1&gt;&lt;p&gt;全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。&lt;/p&gt;
&lt;p&gt;不过，恩，这些你早都知道了……&lt;/p&gt;
&lt;p&gt;所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 &lt;a href=&quot;http://www.brothercake.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;James Edwards&lt;/a&gt; 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;静态命名空间&quot;&gt;&lt;a href=&quot;#静态命名空间&quot; class=&quot;headerlink&quot; title=&quot;静态命名空间&quot;&gt;&lt;/a&gt;静态命名空间&lt;/h2&gt;&lt;p&gt;我用&lt;code&gt;静态命名空间&lt;/code&gt;作为那些命名空间标签实际上硬编码的解决方案的涵盖性术语。是的，你可以将一个命名空间重新分配给另一个，不过新的命名空间将会引用和旧的那一个同样的对象。&lt;/p&gt;
&lt;h3 id=&quot;1-通过直接分配&quot;&gt;&lt;a href=&quot;#1-通过直接分配&quot; class=&quot;headerlink&quot; title=&quot;1.通过直接分配&quot;&gt;&lt;/a&gt;1.通过直接分配&lt;/h3&gt;&lt;p&gt;最基础的方法。这样非常冗长，并且如果你还想重命名这些命名空间，你就有得活儿干了。不过它是安全和清楚明白的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.id = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.next = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return myApp.id++;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.reset = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.id = 0;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;); //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你也可以通过使用&lt;code&gt;this&lt;/code&gt;引用兄弟属性来使将来的维护更轻松一些，不过这有一点冒险因为没有什么能阻止你的那些命名空间里的方法被重新分配。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.id = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.next = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return this.id++;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.reset = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.id = 0;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.next(); //0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp.next(); //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var getNextId = myApp.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getNextId(); //NaN whoops!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-使用对象字面量&quot;&gt;&lt;a href=&quot;#2-使用对象字面量&quot; class=&quot;headerlink&quot; title=&quot;2.使用对象字面量&quot;&gt;&lt;/a&gt;2.使用对象字面量&lt;/h3&gt;&lt;p&gt;现在我们只需要引用命名空间名一次，因此之后改变名字更简单了一些（假设你还没反复引用这个命名空间）。仍有一个危险是&lt;code&gt;this&lt;/code&gt;的值可能会抛出一个『惊喜』 - 不过假设在一个对象字面结构里定义的对象不会被重新分配相对安全一点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id: 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next: function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.id++;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reset: function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.id = 0;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;3-模块模式&quot;&gt;&lt;a href=&quot;#3-模块模式&quot; class=&quot;headerlink&quot; title=&quot;3.模块模式&quot;&gt;&lt;/a&gt;3.模块模式&lt;/h3&gt;&lt;p&gt;我发现自己最近用&lt;code&gt;模块模式&lt;/code&gt;更多。逻辑被一个方法包装从全局域隔离开了（通常是自调用的），它返回一个代表这个模块公开接口的对象。通过立即调用这个方法并分配结果给一个命名空间变量，我们就锁住了这个命名变量中模块的 API。此外，任何没有包括在返回值中的变量将永远保持私有，只对引用他们的公开方法可见。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = (function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var id= 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next: function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return id++;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reset: function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            id = 0;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上对象字面量例子，命名空间名字可以轻易更换，不过还有额外优势：对象字面量是四班的 - 它全是关于属性分配，没有支持逻辑的空间。此外，所有属性必须被初始化，并且属性值无法轻易跨对象引用（因此，比如，内部闭包就不可能使用了）。模块模式没有任何上述约束，并且给我们额外的隐私福利。&lt;/p&gt;
&lt;h2 id=&quot;动态命名空间&quot;&gt;&lt;a href=&quot;#动态命名空间&quot; class=&quot;headerlink&quot; title=&quot;动态命名空间&quot;&gt;&lt;/a&gt;动态命名空间&lt;/h2&gt;&lt;p&gt;我们也可以将这一节称为&lt;code&gt;命名空间注入&lt;/code&gt;。命名空间由一个直接引用方法包装&lt;code&gt;内部&lt;/code&gt;的代理代表 - 这意味着我们不再需要打包分配给命名空间的返回值。这让命名空间定义变得更灵活并且让拥有多个存在于独立命名空间中（或者甚至在全局上下文中）的模块的独立实例。动态命名空间支持模块模式的全部特征并附加直观和可读性强的优势。&lt;/p&gt;
&lt;h3 id=&quot;4-提供命名空间参数&quot;&gt;&lt;a href=&quot;#4-提供命名空间参数&quot; class=&quot;headerlink&quot; title=&quot;4.提供命名空间参数&quot;&gt;&lt;/a&gt;4.提供命名空间参数&lt;/h3&gt;&lt;p&gt;在这里我们只是将命名空间作为参数传给自调用方法。变量&lt;code&gt;id&lt;/code&gt;是私有的，因为他并没有被分配给&lt;code&gt;context&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function(context) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var id = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    context.next = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return id++;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    context.reset = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        id = 0;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)(myApp);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们甚至可以把&lt;code&gt;context&lt;/code&gt;设置给全局对象（通过一个字的改变！）。这是库主们的巨大财富 - 他们可以将他们的特性包装在一个自调用函数中，然后让用户来决定它们是不是全局的（John Resig 在他写 JQuery 时就是一个这个理论的早期采用者）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function(context) &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var id = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    context.next = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return id++;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    context.reset = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        id = 0;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)(this);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;5-用this作为命名空间代理&quot;&gt;&lt;a href=&quot;#5-用this作为命名空间代理&quot; class=&quot;headerlink&quot; title=&quot;5.用this作为命名空间代理&quot;&gt;&lt;/a&gt;5.用&lt;code&gt;this&lt;/code&gt;作为命名空间代理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.brothercake.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;James Edwads&lt;/a&gt; 最近发布的一篇文章激起了我的兴趣。&lt;a href=&quot;http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《My Favorite JavaScript Design Patter》&lt;/a&gt; 显然被很多评论者误解了，他们认为他可能也是借助于模块模式。这篇文章宣传了多种技术（可能导致了读者的迷惑），但是在它的核心部分是一点我已经修改并呈现为一个命名空间工具的很天才的东西。&lt;/p&gt;
&lt;p&gt;这个模式的美就在于它仅仅是按照这个语言被设计的方式使用 - 不多不少、不投机也不取巧。此外因为命名空间是通过&lt;code&gt;this&lt;/code&gt;关键字（它在给定的执行上下文中是不变的）注入的，它不可能被意外修改。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var myApp = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var id = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.next = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return id++;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.reset = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        id = 0;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).apply(myApp);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    myApp.next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;); //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更棒的是，&lt;code&gt;apply&lt;/code&gt;（以及&lt;code&gt;call&lt;/code&gt;） API 提供了与上下文和参数天然的隔离 - 因此给模块创建者传递附加参数非常干净。下面的例子表明了这一点，并且展示了如何独立于多个命名空间来运行模块。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var subsys1 = &amp;#123;&amp;#125;, subsys2 = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var nextIdMod = function(startId) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var id = startId || 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.next = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return id++;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.reset = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        id = 0;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nextIdMod.call(subsys1);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nextIdMod.call(subsys2,1000);   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subsys1.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subsys1.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subsys2.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subsys1.reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subsys2.next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subsys1.next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) //0, 1, 1000, undefined, 1001, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然如果我们如果我们需要一个全局 id 生成器，非常简单……&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nextIdMod();    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.console &amp;amp;&amp;amp; console.log(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reset(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) //0, 1, undefined, 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个我们作为例子使用的 id 生成器工具并没有表现出这个模式的全部潜力。通过包裹一整个库和使用&lt;code&gt;this&lt;/code&gt;关键字作为命名空间的替身，我们使得用户在任何他们选择的上下文中运行这个库很轻松（包括全局上下文）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//library code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var protoQueryMooJo = function() &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //everything&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//user code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var thirdParty = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;protoQueryMooJo.apply(thirdParty);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;其他的考虑&quot;&gt;&lt;a href=&quot;#其他的考虑&quot; class=&quot;headerlink&quot; title=&quot;其他的考虑&quot;&gt;&lt;/a&gt;其他的考虑&lt;/h2&gt;&lt;p&gt;我希望避免命名空间嵌套。它们很难追踪（对人和电脑都是）并且它们会让你的代码因为一些乱七八糟的东西变得很多。如 &lt;a href=&quot;http://michaux.ca/articles/javascript-namespacing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Peter Michaux&lt;/a&gt; 指出的，深度嵌套的命名空间可能是那些视图重新创建他们熟悉和热爱的长包链的老派 Java 开发者的遗产。&lt;/p&gt;
&lt;p&gt;通过 .js 文件来固定一个单独的命名空间也是可以的（虽然只能通过命名空间注入或者直接分配每一个变量），不过你应该对依赖谨慎些。此外将命名空间绑定到文件上可以帮助读者更轻易弄清整个代码。&lt;/p&gt;
&lt;p&gt;因为 JavaScript 并没有正式的命名空间结构，所以有很多自然形成的方法。这个调查只详细说明了其中的一部分，可能有更好的技术我没有发现。我很乐意知道它们。&lt;/p&gt;
&lt;h2 id=&quot;更多文章&quot;&gt;&lt;a href=&quot;#更多文章&quot; class=&quot;headerlink&quot; title=&quot;更多文章&quot;&gt;&lt;/a&gt;更多文章&lt;/h2&gt;&lt;p&gt;James Edwards： &lt;a href=&quot;http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;My Favorite JavaScript Design Pattern&lt;/a&gt;&lt;br&gt;Peter Michaux: &lt;a href=&quot;http://michaux.ca/articles/javascript-namespacing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript Namespacing&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/&quot;&gt;Namespacing in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-中的命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-中的命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的命名空间&quot;&gt;&lt;/a&gt;JavaScript 中的命名空间&lt;/h1&gt;&lt;p&gt;全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。&lt;/p&gt;
&lt;p&gt;不过，恩，这些你早都知道了……&lt;/p&gt;
&lt;p&gt;所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 &lt;a href=&quot;http://www.brothercake.com/&quot;&gt;James Edwards&lt;/a&gt; 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cheng-kang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cheng-kang.github.io/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://cheng-kang.github.io/tags/Namespacing/"/>
    
  </entry>
  
  <entry>
    <title>【译】Swift2 中的错误处理：try，catch，do 以及 throw</title>
    <link href="http://cheng-kang.github.io/2016/05/15/Swift2%20%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9Atry%EF%BC%8Ccatch%EF%BC%8Cdo%20%E4%BB%A5%E5%8F%8A%20throw/"/>
    <id>http://cheng-kang.github.io/2016/05/15/Swift2 中的错误处理：try，catch，do 以及 throw/</id>
    <published>2016-05-15T15:14:40.000Z</published>
    <updated>2016-05-15T15:21:48.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Error handling in Swift 2: try, catch, do and throw》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你已经看了我那篇讨论 Swift2 中所有新东西的文章并且想了解更多关于新的错误处理系统的东西，这篇文章非常合适。简单来说，它已经被完全重写得现代化，快速和安全，并且除非你只使用 iOS API 的一小部分的话，你需要花些时间来学习一下。&lt;/p&gt;
&lt;p&gt;如果你喜欢这篇文章，你可能也会想读读这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/swift2-2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What’s new in Swift 2.2?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/ios9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What’s new in iOS 9?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;My free Swift tutorial series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gum.co/proswift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pre-order Pro Swift for just $20!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;过去是怎样：NSError-和-NSErrorPointer&quot;&gt;&lt;a href=&quot;#过去是怎样：NSError-和-NSErrorPointer&quot; class=&quot;headerlink&quot; title=&quot;过去是怎样：NSError 和 NSErrorPointer&quot;&gt;&lt;/a&gt;过去是怎样：NSError 和 NSErrorPointer&lt;/h3&gt;&lt;p&gt;用于处理错误的历史方法是通过使用一个作为指针传递的 NSError 对象。在 Objective-C 中，它是 NSError*，但在 Swift 中你会看到 NSError？ 和 NSErrorPointer。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;当你调用一个可能失败的方法，你要传递一个空 NSError 作为参数，如果有问题的话这个参数就会被赋值。这让方法的返回值是你真正关心的那个数据。例如，在 Swift1.2 中，从硬盘加载一个 NSString 看起来是这样的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var err: NSError?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let contents = NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding, error: &amp;amp;err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if err != nil &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // uh-oh!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这种编程风格在 Cocoa 中非常广泛，或者说至少：Swift2 完全不这么干，所以上面的代码要么要重写要么就移除掉。&lt;/p&gt;
&lt;p&gt;至于为什么，有很多原因。例如，用上面的调用方法，很容易就忽略了错误，要么是没有检查 err 的值，要么是根本就没用 NSError 而是直接传递了一个 nil。&lt;/p&gt;
&lt;p&gt;虽然 Swift2 中的新错误处理需要多费点功夫，但是它让程序员阅读起来清楚明白得多，它抛弃了那些复杂的东西例如用 &amp;amp; 来传递 NSError，并且它通过保证你捕获所有错误来给你更高的安全性。&lt;/p&gt;
&lt;h3 id=&quot;Swift2-中的方法：try，catch，do-以及-throw&quot;&gt;&lt;a href=&quot;#Swift2-中的方法：try，catch，do-以及-throw&quot; class=&quot;headerlink&quot; title=&quot;Swift2 中的方法：try，catch，do 以及 throw&quot;&gt;&lt;/a&gt;Swift2 中的方法：try，catch，do 以及 throw&lt;/h3&gt;&lt;p&gt;当你导入一个 Swift1.2 项目到 Xcode7 时，你会被问道是否想要将它转换成最新的 Swift 语法。它并不能生成和你手写的一模一样的代码，但是它能帮你解决很大一部分工作，这样你就差不多确定要去使用它了。&lt;/p&gt;
&lt;p&gt;在上面那个从文件中加载字符串的例子中，它会将其转化为 Swift2 版本：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let contents: NSString?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    contents = try NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch _ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    contents = nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里展示了五个你需要学习的新关键字其中三个。当然，严格来说有一个不新，不过它的用法是新的：do 之前使用在 do … while 循环中，不过为了避免混淆，在 Swift2 中，它已经被重命名为 repeat … while。&lt;/p&gt;
&lt;p&gt;第四和第五个关键字是 throw 和 throws，我们现在来更深入地看看。&lt;/p&gt;
&lt;p&gt;请创建一个新的 Xcode 项目，用单视图应用模板。随便命个名，随便选个目标设备 - 都没关系，因为我们这次不做任何跟视图有关的东西。&lt;/p&gt;
&lt;p&gt;选择 ViewController.swift 并且添加这个新方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func encryptString(str: String, withPassword password: String) -&amp;gt; String &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // complicated encryption goes here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let encrypted = password + str + password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return String(encrypted.characters.reverse())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个方法会用传递进来的密码加密一个字符串。当然，它不会自动就这样做 - 这篇文章不是关于加密的，所以我的『加密』算法很悲剧：它将密码添加在输入的字符串前后，然后翻转这个字符串。你之后可以随意加上复杂的加密算法。&lt;/p&gt;
&lt;p&gt;修改 viewDidLoad() 来调用这个方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let encrypted = encryptString(&amp;quot;secret information!&amp;quot;, withPassword: &amp;quot;12345&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(encrypted)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你现在运行你的应用，你将看到在 Xcode 终端上打印出了『54321！noitamrofni terces54321』。很简单对吧。&lt;/p&gt;
&lt;p&gt;但是有一个问题：假设你实际上设定了一个有意义的加密算法，你没办法阻止用户输入一个空字符串作为密码，或者输入明显的密码类似『password』，或者甚至尝试在没有任何可加密数据的情况下调用加密算法。&lt;/p&gt;
&lt;p&gt;Swift2 来帮忙了：你可以告诉 Swift 当这个方法发现它自己处于一个不可接受的状态时，它可以抛出一个错误，例如如果密码是六位或者更少位。这些错误是由你定义的，然后 Swift 用某种办法来保证你捕获所有的错误。&lt;/p&gt;
&lt;p&gt;首先，我们需要关键字 throws，你需要在定义你的方法时把它加在返回值前面，就像这样：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func encryptString(str: String, withPassword password: String) throws -&amp;gt; String &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // complicated encryption goes here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let encrypted = password + str + password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return String(encrypted.characters.reverse())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一旦你这样做了，你的代码就会停止工作：添加 throws 命名让情况更糟了！不过它变糟了是因为一个好原因：Swift 中的 try/catch 系统被设计为对开发者清晰明了，这意味着你需要用关键字 try 标记所有可以抛出错误的方法，就像这样：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;let encrypted = try encryptString(“secret information!”, withPassword: “12345”)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;…不过即使现在你的代码还是不能编译成功，因为你还没有告诉 Swift 当错误被抛出时要做什么。这就是关键字 do 和 catch 派上用场的地方：它们开始了一段可能运行失败的代码，并且处理那些失败。在我们的简单例子里，它可能看起来是这样：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;do {&lt;br&gt;    let encrypted = try encryptString(“secret information!”, withPassword: “12345”)&lt;br&gt;    print(encrypted)&lt;br&gt;} catch {&lt;br&gt;    print(“Something went wrong!”)&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;这样所有的错误都没了，你的代码又可以运行了。不过目前为止它实际上还没有做任何有意思的事情，因为即使我们说 encryptString() 可能抛出一个错误，它从没有真正发生。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 如何在 Swift2 中抛出错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在你可以抛出一个错误之前，你需要制作一个你要抛出的可能错误的列表。在我们这个例子中，我们要组织人们提供空密码，短密码和明显密码，不过之后你可以扩展它。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;要做到这些，我们需要创建一个枚举类型变量来代表我们错误的类型。这需要建立在内建的 ErrorType 枚举类型上，不过不管怎样都很简单。把这个加载 ViewController 类的前面：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;enum EncryptionError: ErrorType {&lt;br&gt;    case Empty&lt;br&gt;    case Short&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;它定义了两个错误类型，然后我们可以马上开始用它们。因为它们是运行这个方法的前提条件，我们要用这个新关键字 guard 来使我们的意图清晰。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;把这个放在 encryptString() 前面：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;guard password.characters.count &amp;gt; 0 else { throw EncryptionError.Empty }&lt;br&gt;guard password.characters.count &amp;gt;= 5 else { throw EncryptionError.Short }&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;如果你现在运行应用，没有什么变化，因为我们在提供『12345』这个密码。不过如果你把它设置为一个空字符串，你会看到『Something went wrong！』在 Xcode 控制台打印出来了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然，有一个错误信息帮助不是很大 - 因为这个方法调用时有多种方式失败，并且我们希望给每一种情况提供一些有意义的信息。所以，把 viewDidLoad() 中的 try/catch 代码块改成这样：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;do {&lt;br&gt;    let encrypted = try encryptString(“secret information!”, withPassword: “”)&lt;br&gt;    print(encrypted)&lt;br&gt;} catch EncryptionError.Empty {&lt;br&gt;    print(“You must provide a password.”)&lt;br&gt;} catch EncryptionError.Short {&lt;br&gt;    print(“Passwords must be at least five characters, preferably eight or more.”)&lt;br&gt;} catch {&lt;br&gt;    print(“Something went wrong!”)&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;现在有了有意义的错误信息，我们的代码开始看起来更棒了。不过你可能注意到了，虽然我们已经捕获到了 .Empty 和 .Short 的情况，我们还需要第三个 catch 代码块。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### Swift2 要求详尽无遗的 try/catch 错误处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果你还记得的话，我说过『Swift 通过一些方式来保证你捕获到所有错误』，这里我们来说明清楚：我们已经能捕获所有我们定义的错误，但是 Swift 还希望我们定义一个一般的 catch all 来处理任何其他可能出现的错误。我们不用告诉 Swift 到底加密算法可能抛出哪种错误，只需要说明它会抛出某些错误，因此这个额外的 catch-all 代码块是必须的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有一个不好的地方：如果你新增任何值给枚举类型，它会直接进到默认的 catch 代码块 - 你不会被要求为它提供任何代码。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们将要给枚举类型加一个新的值来检测明显的密码。不过我们将要用 Swift 超强枚举类型这样我们可以返回一个带着错误类型的信息。因此，将 EncryptionError 枚举类型修改成这样：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;enum EncryptionError: ErrorType {&lt;br&gt;    case Empty&lt;br&gt;    case Short&lt;br&gt;    case Obvious(String)&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;现在当你想要抛出一个 EncrytionError.Obvious 类型的错误是，你必须提供一个理由。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;guard password != “12345” else { throw EncryptionError.Obvious(“I’ve got the same passcode on my luggage!”) }&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;显然你不想写无数个 guard 声明来过滤出明显的密码，不过如果你记得如何使用 UITextChecker 来做拼写检查的话，就很方便了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这就是完整的 Swift 基本 do/try/throw/catch 例子。你可能觉得 try 声明没什么用，不过他是作为一个信号告诉开发者『这个调用可能失败』。这很重要：当一个 try 调用失败了，执行立刻跳转到 catch 代码块，因此如果你看到一个调用之前的 try，它标志着底下的代码可能不会被执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;还有一个要说的事情就是，如果你知道一个调用就是不会失败你该怎么做。现在，很显然这是一个你需要根据情况来做的决定，不过如果你知道有一个方法绝对不可能调用失败或者如果它调用失败的你的代码就会完全崩溃，你可以使用 try! 来告诉 Swift。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当你使用关键字 try!，你不需要用 do/catch 来包裹你的代码，因为你在保证它永远不会失败。你只需要这样写：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;let encrypted = try! encryptString(“secret information!”, withPassword: “12345”)&lt;br&gt;print(encrypted)&lt;br&gt;```&lt;br&gt;使用关键字 try! 清楚地表达了你的意图：你知道理论上这个调用可能失败，但是你确定它在你的用例中不会失败。例如，如果你从你的应用包中的文件中加载内容，任何失败意味着你的应用包被损坏了或者不可用，所以你需要终止应用。&lt;/p&gt;
&lt;p&gt;这就是所有关于 Swift2 中错误处理的东西。如果你想学习 Swift 是怎样处理 try/finally，你应该读读我这篇&lt;a href=&quot;https://www.hackingwithswift.com/new-syntax-swift-2-defer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于关键词 defer 的文章&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.hackingwithswift.com/new-syntax-swift-2-error-handling-try-catch&quot;&gt;《Error handling in Swift 2: try, catch, do and throw》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你已经看了我那篇讨论 Swift2 中所有新东西的文章并且想了解更多关于新的错误处理系统的东西，这篇文章非常合适。简单来说，它已经被完全重写得现代化，快速和安全，并且除非你只使用 iOS API 的一小部分的话，你需要花些时间来学习一下。&lt;/p&gt;
&lt;p&gt;如果你喜欢这篇文章，你可能也会想读读这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/swift2-2&quot;&gt;What’s new in Swift 2.2?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/ios9&quot;&gt;What’s new in iOS 9?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackingwithswift.com/&quot;&gt;My free Swift tutorial series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gum.co/proswift&quot;&gt;Pre-order Pro Swift for just $20!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;过去是怎样：NSError-和-NSErrorPointer&quot;&gt;&lt;a href=&quot;#过去是怎样：NSError-和-NSErrorPointer&quot; class=&quot;headerlink&quot; title=&quot;过去是怎样：NSError 和 NSErrorPointer&quot;&gt;&lt;/a&gt;过去是怎样：NSError 和 NSErrorPointer&lt;/h3&gt;&lt;p&gt;用于处理错误的历史方法是通过使用一个作为指针传递的 NSError 对象。在 Objective-C 中，它是 NSError*，但在 Swift 中你会看到 NSError？ 和 NSErrorPointer。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="error" scheme="http://cheng-kang.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView 总结</title>
    <link href="http://cheng-kang.github.io/2016/04/13/UICollectionView%20%E6%80%BB%E7%BB%93/"/>
    <id>http://cheng-kang.github.io/2016/04/13/UICollectionView 总结/</id>
    <published>2016-04-12T23:13:54.000Z</published>
    <updated>2016-04-13T06:18:48.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模拟凤凰新闻 Github 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;昨天给自己布置这个作业之后，看完文档实践的过程中发现一片很棒的英文总结，于是翻译了一下。这篇总结会简单总结一下我翻译的那篇文章里的内容，以及基于模拟凤凰新闻客户端部分页面的一些 UICollectionView 使用总结。&lt;/p&gt;
&lt;p&gt;文章主要是总结一些需要注意的内容，具体请看源码。实现的内容及对应文件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个 section 内拖动 cell&lt;ul&gt;
&lt;li&gt;直接使用 UICollectionViewController（&lt;code&gt;TestCollectionViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在 UIViewController 中使用 UICollectionView（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同 section 间拖动 cell（&lt;code&gt;Test.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;不同 section 间点击移动 cell（&lt;code&gt;TabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;点击移除 cell（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要内容如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;《【译】UICollectionView-轻松重排》&quot;&gt;&lt;a href=&quot;#《【译】UICollectionView-轻松重排》&quot; class=&quot;headerlink&quot; title=&quot;《【译】UICollectionView 轻松重排》&quot;&gt;&lt;/a&gt;《【译】UICollectionView 轻松重排》&lt;/h3&gt;&lt;p&gt;这篇文章主要介绍了在 iOS9 之后 UICollectionView 自带的重新排列方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果直接使用 UICollectionViewController，通过重写&lt;code&gt;func collectionView(collectionView: UICollectionView,
 moveItemAtIndexPath sourceIndexPath: NSIndexPath,
 toIndexPath destinationIndexPath: NSIndexPath)&lt;/code&gt;即可以实现拖动重排。&lt;/li&gt;
&lt;li&gt;如果是在 UIViewController 里面使用 UICollectionView，则需要自己添加一个 UILongPressGestureRecognizer，对应状态进行对应处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比较重要的几个方法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;func collectionView(collectionView: UICollectionView,&lt;br&gt;  moveItemAtIndexPath sourceIndexPath: NSIndexPath,&lt;br&gt;  toIndexPath destinationIndexPath: NSIndexPath)&lt;/li&gt;
&lt;li&gt;indexPathForItemAtPoint&lt;/li&gt;
&lt;li&gt;beginInteractiveMovementForItemAtIndexPath&lt;/li&gt;
&lt;li&gt;updateInteractiveMovementTargetPosition&lt;/li&gt;
&lt;li&gt;endInteractiveMovement&lt;/li&gt;
&lt;li&gt;cancelInteractiveMovement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特别注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法&lt;code&gt;func collectionView(collectionView: UICollectionView,
    moveItemAtIndexPath sourceIndexPath: NSIndexPath,
    toIndexPath destinationIndexPath: NSIndexPath)&lt;/code&gt;,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重写这个方法之后，自带的拖动重排才能生效。&lt;/li&gt;
&lt;li&gt;这个方法究竟有什么作用？这个方法是在 cell 位置变换之后触发的。它包含两个很有用的参数，被拖动的 cell 的初始 indexPath 和落点 indexPath。因为这个位置的变换只是视图的改变，这些 cell 背后的数据的 index 其实并没有受到影响。因此如果此时 reloadData() 会发现，格子位置又恢复了，但这不是我们想要的，在实际项目中我们希望移动后就一直保持那个位置，也就是说数据的 index 发生相应改变。这个方法就是方便我们处理数据的。具体请看之后内容中的例子。&lt;/li&gt;
&lt;li&gt;另外这个方法只与通过交互移动 cell 事件有关。如果是直接调用移动 cell 的方法并不会触发这个方法。所以在类似凤凰新闻编辑订阅频道页面，”点击下面 section 中的频道，移动到上面的 section 中”，实现时需要在 didSelect 方法中添加对应修改数据源的代码。具体参看源码中&lt;code&gt;TabsViewController.swift&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用-UICollectionView-必做的事情&quot;&gt;&lt;a href=&quot;#使用-UICollectionView-必做的事情&quot; class=&quot;headerlink&quot; title=&quot;使用 UICollectionView 必做的事情&quot;&gt;&lt;/a&gt;使用 UICollectionView 必做的事情&lt;/h3&gt;&lt;p&gt;首先你的 UIViewController 要继承 UICollectionViewDataSource，UICollectionViewDelegate，UICollectionViewDelegateFlowLayout。&lt;/p&gt;
&lt;p&gt;其次，记得绑定 delegate 和 datasource。&lt;/p&gt;
&lt;p&gt;然后是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;func numberOfSectionsInCollectionView(collectionView: UICollectionView) -&amp;gt; Int&lt;/li&gt;
&lt;li&gt;collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -&amp;gt; Int&lt;/li&gt;
&lt;li&gt;collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&amp;gt; UICollectionViewCell&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有需要的话用上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;func collectionView(collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAtIndexPath indexPath: NSIndexPath) -&amp;gt; CGSize&lt;/li&gt;
&lt;li&gt;func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -&amp;gt; UICollectionReusableView &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特别注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你在 storyboard 设置了使用 header 或者 footer 或者两者都用的时候，记得添加对应的内容在 viewForSupplementaryElementOfKind 里面。例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func collectionView(collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: NSIndexPath) -&amp;gt; UICollectionReusableView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if kind == UICollectionElementKindSectionHeader &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let header = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: &amp;quot;TabSectionHeader&amp;quot;, forIndexPath: indexPath) as! TabSectionHeader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let footer = collectionView.dequeueReusableSupplementaryViewOfKind(kind, withReuseIdentifier: &amp;quot;TabSectionFooter&amp;quot;, forIndexPath: indexPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return footer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;个人对这个方法的设计持怀疑态度，觉得像 UITableView 那样分离开会更好。（又或许是我理解不够深刻吧。）&lt;/p&gt;
&lt;p&gt;记得设置 reuseIdentifier。&lt;/p&gt;
&lt;h3 id=&quot;插入、移动、删除-cell-以及-cell-总数的问题&quot;&gt;&lt;a href=&quot;#插入、移动、删除-cell-以及-cell-总数的问题&quot; class=&quot;headerlink&quot; title=&quot;插入、移动、删除 cell 以及 cell 总数的问题&quot;&gt;&lt;/a&gt;插入、移动、删除 cell 以及 cell 总数的问题&lt;/h3&gt;&lt;p&gt;UICollectionView 是在生成 cell 的时候，先通过 numberOfItemsInSection 获得 cell 数量，然后一个一个生成添加在视图中。&lt;/p&gt;
&lt;p&gt;你可通过这些方法来插入、移动、删除 cell：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insertItemAtIndexPaths&lt;/li&gt;
&lt;li&gt;moveItemAtIndexPath&lt;/li&gt;
&lt;li&gt;deleteItemsAtIndexPaths&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，当来自服务器的数据更新了，新增或者减少了一个数据，我们可以想到有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 reloadData() 将整个 UICollectionView 更新。&lt;/li&gt;
&lt;li&gt;只在对应的位置插入或删除对应的那一个 cell。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用第一种方法是没有任何问题的。问题在第二种方法。&lt;/p&gt;
&lt;p&gt;当我们直接通过 insertItemAtIndexPaths 或者 deleteItemsAtIndexPaths 添加或删除 cell 时，UICollectionView 中的 cell 数量发生变化了。貌似没问题？如果你尝试滑动一下屏幕，你会发现程序崩溃了。你会看到类似下面的报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-13%20at%206.20.09%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原因在于，当 UICollectionView 进行任何的更新时，包括局部更新，都会检查 numberOfItemInSection 方法返回的值和当前 UICollectionView 中实际包含的 cell 数量。如果二者不一致就会报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UICollectionView 中实际包含的 cell 数量在下一次更新前 collection view 视图前一定要和 numberOfItemInSection 的返回值一直。&lt;/p&gt;
&lt;p&gt;所以我们在新增或者删除 cell 之后，记得要修改对应的数据源。（当然在实际项目中应该不会忘记。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入、移动、删除 section 类似&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;不同-section-间拖动-cell&quot;&gt;&lt;a href=&quot;#不同-section-间拖动-cell&quot; class=&quot;headerlink&quot; title=&quot;不同 section 间拖动 cell&quot;&gt;&lt;/a&gt;不同 section 间拖动 cell&lt;/h3&gt;&lt;p&gt;项目中的 Test.swift 是关于不同 section 间拖动 cell 的例子。&lt;/p&gt;
&lt;p&gt;基本原理和在一个 section 内拖动 cell 一样，都是调用那几个方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意的还是上面提到的记得修改对应数据源，否则第二次拖动就会报错。因为此时两个 section 内 cell 数量和 numberOfItemInSection 返回值不一样了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请看一下两个实现方法：&lt;/p&gt;
&lt;p&gt;一，『原始』方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func longPressGestureRecognizerAction(sender: UILongPressGestureRecognizer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch sender.state &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case .Began:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let location = sender.locationInView(self.collectionView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let indexPath = self.collectionView.indexPathForItemAtPoint(location)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.originalSectionIndex = (indexPath?.section)!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.interactiveItem = self.collectionView.cellForItemAtIndexPath(indexPath!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.beginInteractiveMovementForItemAtIndexPath(indexPath!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case .Changed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let location = sender.locationInView(self.collectionView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(location)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let indexPath = self.collectionView.indexPathForItemAtPoint(location)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(indexPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.updateInteractiveMovementTargetPosition(location)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case .Ended:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.endInteractiveMovement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let currentSectionIndex = (self.collectionView.indexPathForCell(self.interactiveItem)?.section)!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.sections[currentSectionIndex]++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.sections[self.originalSectionIndex]--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.cancelInteractiveMovement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;二，借助自带方法的简便方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func collectionView(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.sections[destinationIndexPath.section]++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.sections[sourceIndexPath.section]--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func longPressGestureRecognizerAction(sender: UILongPressGestureRecognizer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch sender.state &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case .Began:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(sender.locationInView(self.collectionView)) else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case .Changed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.updateInteractiveMovementTargetPosition(sender.locationInView(self.collectionView))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case .Ended:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.endInteractiveMovement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.cancelInteractiveMovement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第一个方法定义了两个全局变量&lt;code&gt;var originalSectionIndex = 0&lt;/code&gt;和&lt;code&gt;var interactiveItem:UICollectionViewCell!&lt;/code&gt;来记录初始位置和正在进行移动的 cell。&lt;/p&gt;
&lt;p&gt;而第二个方法，通过使用&lt;code&gt;func collectionView(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath)&lt;/code&gt;，直接就可以使用开始和结束位置 indexPath。非常方便。&lt;/p&gt;
&lt;p&gt;所以当然一定要用第二种方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot;&gt;模拟凤凰新闻 Github 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;昨天给自己布置这个作业之后，看完文档实践的过程中发现一片很棒的英文总结，于是翻译了一下。这篇总结会简单总结一下我翻译的那篇文章里的内容，以及基于模拟凤凰新闻客户端部分页面的一些 UICollectionView 使用总结。&lt;/p&gt;
&lt;p&gt;文章主要是总结一些需要注意的内容，具体请看源码。实现的内容及对应文件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个 section 内拖动 cell&lt;ul&gt;
&lt;li&gt;直接使用 UICollectionViewController（&lt;code&gt;TestCollectionViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在 UIViewController 中使用 UICollectionView（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同 section 间拖动 cell（&lt;code&gt;Test.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;不同 section 间点击移动 cell（&lt;code&gt;TabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;点击移除 cell（&lt;code&gt;EditTabsViewController.swift&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要内容如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://cheng-kang.github.io/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>【译】UICollectionView 轻松重排</title>
    <link href="http://cheng-kang.github.io/2016/04/12/%E3%80%90%E8%AF%91%E3%80%91UICollectionView%20%E8%BD%BB%E6%9D%BE%E9%87%8D%E6%8E%92/"/>
    <id>http://cheng-kang.github.io/2016/04/12/【译】UICollectionView 轻松重排/</id>
    <published>2016-04-12T15:38:28.000Z</published>
    <updated>2016-04-12T22:40:25.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UICollectionViews Now Have Easy Reordering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我超喜欢&lt;code&gt;UICollectionView&lt;/code&gt;。相比&lt;code&gt;UITableView&lt;/code&gt;，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 &lt;a href=&quot;https://github.com/nshintio/uicollectionview-reordering&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github&lt;/a&gt; 上找到对应的 Xcode 项目。&lt;/p&gt;
&lt;p&gt;最简单的实现重排是通过使用&lt;code&gt;UICollectionViewController&lt;/code&gt;。它现在有一个新的属性叫做&lt;code&gt;installsStandardGestureForInteractiveMovement&lt;/code&gt;，作用是添加手势（gestures）来重排 cells。这个属性默认值为&lt;code&gt;True&lt;/code&gt;，这意味着要使用它我们只需要重写一个方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func collectionView(collectionView: UICollectionView,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    moveItemAtIndexPath sourceIndexPath: NSIndexPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toIndexPath destinationIndexPath: NSIndexPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // move your data order&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 可以留空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当前的 collection view 判定 items 可以被移动，因为&lt;code&gt;moveItemAtIndexPath&lt;/code&gt;被重写了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;当我们希望在一个简单的&lt;code&gt;UIViewController&lt;/code&gt;中使用 collection view 时，会麻烦一点。我们也要实现之前提到的&lt;code&gt;UICollectionViewDataSource&lt;/code&gt;方法，不过我们需要重写&lt;code&gt;installsStandardGestureForInteractiveMovement&lt;/code&gt;。不用担心，也很简单。&lt;code&gt;UILongPressGestureRecognizer&lt;/code&gt;是一种持续性的手势识别器并且完全支持拖动。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            longPressGesture = UILongPressGestureRecognizer(target: self, action: &amp;quot;handleLongGesture:&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.collectionView.addGestureRecognizer(longPressGesture)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func handleLongGesture(gesture: UILongPressGestureRecognizer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        switch(gesture.state) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case UIGestureRecognizerState.Began:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            guard let selectedIndexPath = self.collectionView.indexPathForItemAtPoint(gesture.locationInView(self.collectionView)) else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            collectionView.beginInteractiveMovementForItemAtIndexPath(selectedIndexPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case UIGestureRecognizerState.Changed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            collectionView.updateInteractiveMovementTargetPosition(gesture.locationInView(gesture.view!))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case UIGestureRecognizerState.Ended:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            collectionView.endInteractiveMovement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            collectionView.cancelInteractiveMovement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们保存了在 long press gesture 中不活的被选中的 index path 并且基于它是否有值决定允不允许拖动手势生效。然后，我们根据手势状态调用一些新的 collection view 方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath)&lt;/code&gt;：开始指定位置 cell 的交互移动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateInteractiveMovementTargetPosition(targetPosition: CGPoint)&lt;/code&gt;：更新交互移动对象的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endInteractiveMovement()&lt;/code&gt;：在你结束拖动手势之后结束交互移动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cancelInteractiveMovement()&lt;/code&gt;：取消交互移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些让搞定拖动手势非常容易。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;效果和标准的&lt;code&gt;UICollectionViewController&lt;/code&gt;一样。很酷对吧，不过更酷的是我们可以将我们自定义的 collection view layout 应用到重排中去。看看下面在简单的瀑布视图中的交互移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗯，看起来不错，不过如果我们不想在移动的时候改变 cell 大小呢？选中的 cell 大小应该在交互移动时保持一致。这是可以实现的。&lt;code&gt;UICollectionViewLayout&lt;/code&gt;也有一些其他的方法来负责重排。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    withTargetPosition targetPosition: CGPoint,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    previousIndexPaths: [NSIndexPath],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    previousPosition: CGPoint) -&amp;gt; UICollectionViewLayoutInvalidationContext&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths(indexPaths: [NSIndexPath],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    previousIndexPaths: [NSIndexPath],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    movementCancelled: Bool) -&amp;gt; UICollectionViewLayoutInvalidationContext&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;前一个在目标 indexPath 和之前的 indexPath 之间进行移动时调用。另一个类似，不过是在移动结束之后调用。有了这些我们就可以通过一些小手段达到我们的要求。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;internal override func invalidationContextForInteractivelyMovingItems(targetIndexPaths: [NSIndexPath],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    withTargetPosition targetPosition: CGPoint,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    previousIndexPaths: [NSIndexPath],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    previousPosition: CGPoint) -&amp;gt; UICollectionViewLayoutInvalidationContext &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var context = super.invalidationContextForInteractivelyMovingItems(targetIndexPaths,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        withTargetPosition: targetPosition, previousIndexPaths: previousIndexPaths,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        previousPosition: previousPosition)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.delegate?.collectionView!(self.collectionView!, moveItemAtIndexPath: previousIndexPaths[0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        toIndexPath: targetIndexPaths[0])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决方案非常清晰。获取正在移动的 cell 之前和目标 index path。然后调用&lt;code&gt;UICollectionViewDataSource&lt;/code&gt;来移动这些 item。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/4.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不用怀疑，collection view 重排是一个非常棒的更新。UIKit 工程师干得太棒了！：）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://nshint.io/blog/2015/07/16/uicollectionviews-now-have-easy-reordering/&quot;&gt;UICollectionViews Now Have Easy Reordering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本打算总结一下 UICollectionView 的一些用法，看到一篇比较好的文章，所以直接翻译了。翻译得比较生硬，见谅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我超喜欢&lt;code&gt;UICollectionView&lt;/code&gt;。相比&lt;code&gt;UITableView&lt;/code&gt;，它容易自定义得多。现在我使用甚至使用 collection view 比使用 table view 还要频繁了。在 iOS9 中，它开始支持使用起来很简单的重排。在之前是不可能直接重排的，而且实现起来很麻烦。让我们一起来看看 API。你可以在 &lt;a href=&quot;https://github.com/nshintio/uicollectionview-reordering&quot;&gt;Github&lt;/a&gt; 上找到对应的 Xcode 项目。&lt;/p&gt;
&lt;p&gt;最简单的实现重排是通过使用&lt;code&gt;UICollectionViewController&lt;/code&gt;。它现在有一个新的属性叫做&lt;code&gt;installsStandardGestureForInteractiveMovement&lt;/code&gt;，作用是添加手势（gestures）来重排 cells。这个属性默认值为&lt;code&gt;True&lt;/code&gt;，这意味着要使用它我们只需要重写一个方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func collectionView(collectionView: UICollectionView,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    moveItemAtIndexPath sourceIndexPath: NSIndexPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toIndexPath destinationIndexPath: NSIndexPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // move your data order&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 可以留空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当前的 collection view 判定 items 可以被移动，因为&lt;code&gt;moveItemAtIndexPath&lt;/code&gt;被重写了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nshint.io/images/uicollectionview-reordering/1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="UICollectionView" scheme="http://cheng-kang.github.io/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>模拟凤凰新闻 | 更复杂的标签动画 - Swift 实现多个 TableView 的侧滑与切换</title>
    <link href="http://cheng-kang.github.io/2016/04/08/%E6%A8%A1%E6%8B%9F%E5%87%A4%E5%87%B0%E6%96%B0%E9%97%BB%20%7C%20%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E6%A0%87%E7%AD%BE%E5%8A%A8%E7%94%BB%20-%20Swift%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%20TableView%20%E7%9A%84%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%88%87%E6%8D%A2/"/>
    <id>http://cheng-kang.github.io/2016/04/08/模拟凤凰新闻 | 更复杂的标签动画 - Swift 实现多个 TableView 的侧滑与切换/</id>
    <published>2016-04-08T12:59:13.000Z</published>
    <updated>2016-04-08T20:01:04.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github 仓库：模拟凤凰新闻首页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下午逛 SegmentFault 时看到有人问如何实现凤凰新闻 app 首页效果，正好这两天在学习如何实现多个 TableView 的侧滑与切换，索性自己尝试一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单列一下关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟随滑动&lt;/li&gt;
&lt;li&gt;点击事件&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;凤凰新闻 app 里面下划线是在下面的 ScrollView 滚动动画结束之后才开始侧滑的，所以需要监听滚动是否结束。&lt;ul&gt;
&lt;li&gt;我刚开始想用 scrollViewDidEndScrollingAnimation，结果并不行。这个方法具体使用场景我还没搞清楚。&lt;/li&gt;
&lt;li&gt;应该使用 scrollViewDidEndDecelerating，当 ScrollView 停止减速的时候即动画结束的时候。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;刚开始忘记了点击事件，所以标签用的 UILabel，其实可以换成 UIButton。这样就能省去寻找位置那一步。不过感觉 UIButton 的样式调整也很麻烦。幸运的是 UILabel 默认样式（字体、字号）非常符合这个项目要求。&lt;/li&gt;
&lt;li&gt;不要忘记设置每个 ScrollView 的 delegate；不要忘记在 delegate 方法中判断当前是哪个 ScrollView&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;182&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;183&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;184&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;185&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;186&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;187&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;188&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;189&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;190&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;191&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;193&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;195&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;196&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;197&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;198&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;199&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;201&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;202&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;203&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;204&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;205&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;206&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;207&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;208&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;209&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;210&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;212&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;213&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;214&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;215&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;216&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;217&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;218&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  ViewController.swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  FenghuangXinwen&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Ant on 4/8/16.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright © 2016 Ant. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class ViewController: UIViewController, UIScrollViewDelegate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var tabScrollView: UIScrollView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var contentScrollView: UIScrollView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let tabLine = UIView() //tab 标签下划线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TAB_LINE_HEIGHT = CGFloat(2) //tab 标签下划线高度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let tabTitles = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;头条&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;推荐&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;娱乐&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;财经&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;自媒体&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;凤凰卫视&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;科技&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;良品&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;美女&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;军事&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;体育&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;历史&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;汽车&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;时尚&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;房产&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;FUN来了&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;段子&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;萌物&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ] //tab 标签标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var tabLbls: [UILabel] = [] //tab 标签对应的 UILabl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //定义要用到的颜色及 RGB 值差，用于颜色变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_NORMAL = UIColor(red: 115/255, green: 120/255, blue: 134/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_ACTIVE = UIColor(red: 245/255, green: 67/255, blue: 66/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_NORMAL_RED = CGFloat(115)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_NORMAL_GREEN = CGFloat(120)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_NORMAL_BLUE = CGFloat(134)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_ACTIVE_RED = CGFloat(245)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_ACTIVE_GREEN = CGFloat(67)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_ACTIVE_BLUE = CGFloat(66)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_RED_DIF = CGFloat(130)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_GREEN_DIF = CGFloat(-53)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TEXT_COLOR_BLUE_DIF = CGFloat(-68)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let TAB_LINE_COLOR = UIColor(red: 245/255, green: 67/255, blue: 66/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let MARGIN = CGFloat(20) //tab 标签左右间距&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var currentTabIndex = 0 //当前 tab 标签 index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var currentTabX = CGFloat(20) //当前 tab 标签 x 坐标，方便定位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 scrollView delegate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tabScrollView.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        contentScrollView.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //初始化视图内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        initView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func initView() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //定义一些常量方便使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let TABSCROLLVIEW_HEIGHT = self.tabScrollView.frame.height //tabScrollview 高度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let LABEL_Y = TABSCROLLVIEW_HEIGHT / 2 - 5 // 每个 tab 标签的 y 坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //生成 tab 标签，添加到 tabScrollview 并设置大小位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for var i = 0; i &amp;lt; self.tabTitles.count; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let tabLbl = UILabel()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabLbl.text = tabTitles[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabLbl.textColor = self.TEXT_COLOR_NORMAL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabLbl.sizeToFit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabLbls.append(tabLbl)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.tabScrollView.addSubview(tabLbl)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if i &amp;gt; 0 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tabLbl.center = CGPointMake( self.MARGIN + self.tabLbls[i-1].center.x + self.tabLbls[i-1].frame.width / 2 + tabLbl.frame.width / 2 , LABEL_Y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tabLbl.center = CGPointMake( self.MARGIN + tabLbl.frame.width / 2, LABEL_Y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //顺便生成并添加每个 tab 页面对应的 view。用于测试。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let tabContentView = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.contentScrollView.addSubview(tabContentView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabContentView.backgroundColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabContentView.frame = CGRectMake(self.view.frame.width * CGFloat(i), 0, self.view.frame.width, self.contentScrollView.frame.height)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let labelInContent = UILabel()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            labelInContent.text = tabTitles[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            labelInContent.sizeToFit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabContentView.addSubview(labelInContent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            labelInContent.center = CGPointMake(tabContentView.frame.width / 2, tabContentView.frame.height / 2 - 100)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.contentScrollView.contentSize = CGSizeMake(self.view.frame.width * CGFloat(self.tabLbls.count), self.contentScrollView.frame.height) //设置 contentScrollView 内容大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //计算并设置 tabScrollView 内容大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var TABVIEW_WIDTH = CGFloat(0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for tabLbl in self.tabLbls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            TABVIEW_WIDTH += self.MARGIN + tabLbl.frame.width&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TABVIEW_WIDTH += self.MARGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabScrollView.contentSize = CGSizeMake(TABVIEW_WIDTH, 40)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //默认选中第一个标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabLbls[0].textColor = self.TEXT_COLOR_ACTIVE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.currentTabIndex = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.currentTabX = self.tabLbls[0].frame.origin.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //添加 tab 标签下划线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置位置有一个没搞清楚的问题：不知为何 y 坐标设为 TABSCROLLVIEW_HEIGHT - self.TAB_LINE_HEIGHT 时，下划线看不见&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabScrollView.addSubview(self.tabLine)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabLine.backgroundColor = TAB_LINE_COLOR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabLine.frame = CGRectMake(MARGIN, TABSCROLLVIEW_HEIGHT - 5, self.tabLbls[0].frame.width, self.TAB_LINE_HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func scrollViewDidScroll(scrollView: UIScrollView) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //当 contentScrollView 滚动时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if scrollView == self.contentScrollView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let index = scrollView.contentOffset.x / self.view.frame.width //获取当前页面 index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if floor(index) == index &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.currentTabIndex = Int(index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.currentTabX = self.tabLbls[self.currentTabIndex].frame.origin.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //阻止第一页和最后一页越界滚动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let MIN_X = CGFloat(0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let MAX_X = scrollView.contentSize.width - self.view.frame.width&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let CONTENT_OFFSET_X = scrollView.contentOffset.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if CONTENT_OFFSET_X &amp;lt; MIN_X &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                scrollView.contentOffset.x = MIN_X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else if CONTENT_OFFSET_X &amp;gt; MAX_X &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                scrollView.contentOffset.x = MAX_X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //当没有越界时，执行『动画』&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //初始化一些要用到的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                let isLeft = index &amp;lt; CGFloat(self.currentTabIndex)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                let nextTabIndex = isLeft ? self.currentTabIndex - 1 : index == CGFloat(self.currentTabIndex) ? self.currentTabIndex : self.currentTabIndex + 1 //下一个标签 index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                let currentTabWidth = self.tabLbls[self.currentTabIndex].frame.width //当前标签宽度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                let nextTabWidth = self.tabLbls[nextTabIndex].frame.width //下一个标签宽度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                let widthDif = nextTabWidth - currentTabWidth //两个标签宽度差&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                let distance = self.MARGIN + (isLeft ? self.tabLbls[nextTabIndex].frame.width : currentTabWidth) //下划线需要滑动的距离&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var offsetPercentage = index - CGFloat(self.currentTabIndex) //当前偏移百分比&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //如果滑动超过一页，将偏移百分比设置为 ±1，避免多余动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if offsetPercentage &amp;lt; -1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    offsetPercentage = -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if offsetPercentage &amp;gt; 1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    offsetPercentage = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //改变标签底部横线位置和长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.tabLine.frame = CGRectMake(currentTabX + distance * offsetPercentage, self.tabLine.frame.origin.y, currentTabWidth + widthDif * abs(offsetPercentage), self.tabLine.frame.height)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //改变颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.tabLbls[nextTabIndex].textColor = UIColor(red: (TEXT_COLOR_NORMAL_RED + TEXT_COLOR_RED_DIF * abs(offsetPercentage)) / 255, green: (TEXT_COLOR_NORMAL_GREEN + TEXT_COLOR_GREEN_DIF * abs(offsetPercentage)) / 255, blue: (TEXT_COLOR_NORMAL_BLUE + TEXT_COLOR_BLUE_DIF * abs(offsetPercentage)) / 255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.tabLbls[self.currentTabIndex].textColor = UIColor(red: (TEXT_COLOR_ACTIVE_RED - TEXT_COLOR_RED_DIF * abs(offsetPercentage)) / 255, green: (TEXT_COLOR_ACTIVE_GREEN - TEXT_COLOR_GREEN_DIF * abs(offsetPercentage)) / 255, blue: (TEXT_COLOR_ACTIVE_BLUE - TEXT_COLOR_BLUE_DIF * abs(offsetPercentage)) / 255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func scrollViewDidEndDecelerating(scrollView: UIScrollView) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if scrollView == self.contentScrollView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let TWO_WORD_WIDTH = CGFloat(34) //两个字标签的宽度。这个间距其实是根据自己需求随便设置的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //当标签左边被遮挡时，调整 tabScrollView x 轴偏移量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if self.tabLine.frame.origin.x &amp;lt; self.tabScrollView.contentOffset.x &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    self.tabScrollView.contentOffset.x = self.tabLine.frame.origin.x - self.MARGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;, completion: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //当下划线 x 坐标在 tabScrollView 中部之后时，调整 tabScrollView x 轴偏移量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if self.tabLine.frame.origin.x &amp;gt; self.tabScrollView.frame.width / 2 &amp;amp;&amp;amp; self.currentTabIndex + 1 &amp;lt; self.tabLbls.count - 3 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    self.tabScrollView.contentOffset.x = self.tabLine.frame.origin.x - self.MARGIN - TWO_WORD_WIDTH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;, completion: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //当标签右边被遮挡时，调整 tabScrollView x 轴偏移量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if self.tabLine.frame.origin.x + self.tabLine.frame.width + self.MARGIN &amp;gt; self.tabScrollView.contentOffset.x + self.tabScrollView.frame.width&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                UIView.animateWithDuration(0.4, delay: 0, options: [.CurveEaseInOut], animations: &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    self.tabScrollView.contentOffset.x += (self.tabLine.frame.origin.x + self.tabLine.frame.width + self.MARGIN) - (self.tabScrollView.contentOffset.x + self.tabScrollView.frame.width) + self.MARGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;, completion: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBAction func tabScrollViewTapped(sender: UITapGestureRecognizer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let location = sender.locationInView(self.tabScrollView) //获取当前点击事件在 tabScrollView 里的坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //循环找到点击的是哪一个标签，找到时执行方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for var i = 0; i &amp;lt; self.tabLbls.count; i++ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if CGRectContainsPoint(self.tabLbls[i].frame, location) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.tabLbls[self.currentTabIndex].textColor = TEXT_COLOR_NORMAL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.tabLbls[i].textColor = TEXT_COLOR_ACTIVE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.currentTabIndex = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.currentTabX = self.tabLbls[self.currentTabIndex].frame.origin.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.contentScrollView.contentOffset.x = self.view.frame.width * CGFloat(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目源码：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/FenghuangXinwen&quot;&gt;github 仓库：模拟凤凰新闻首页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下午逛 SegmentFault 时看到有人问如何实现凤凰新闻 app 首页效果，正好这两天在学习如何实现多个 TableView 的侧滑与切换，索性自己尝试一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_fenghuangxinwen-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单列一下关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟随滑动&lt;/li&gt;
&lt;li&gt;点击事件
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="UITableView" scheme="http://cheng-kang.github.io/tags/UITableView/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="UISrollView" scheme="http://cheng-kang.github.io/tags/UISrollView/"/>
    
  </entry>
  
  <entry>
    <title>AutoLayout 中需要注意的点</title>
    <link href="http://cheng-kang.github.io/2016/04/07/AutoLayout%20%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>http://cheng-kang.github.io/2016/04/07/AutoLayout 中需要注意的点/</id>
    <published>2016-04-06T16:41:14.000Z</published>
    <updated>2016-04-06T23:44:59.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文用于记录我在使用 AutoLayout 过程中遇到的一些需要注意的事情，一种是容易犯的错误，一种是我找不到原因的情况。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;容易犯的错误&quot;&gt;&lt;a href=&quot;#容易犯的错误&quot; class=&quot;headerlink&quot; title=&quot;容易犯的错误&quot;&gt;&lt;/a&gt;容易犯的错误&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;如果预览的样式和你预想的不一样，检查一下是不是忘记给作为背景的 view 添加约束（上下左右），可能有一个约束缺失，导致整体样式出错。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;找不到原因的情况&quot;&gt;&lt;a href=&quot;#找不到原因的情况&quot; class=&quot;headerlink&quot; title=&quot;找不到原因的情况&quot;&gt;&lt;/a&gt;找不到原因的情况&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 ScrollView 中通过 AutoLayout 设置 StackView 子视图不固定宽度时，需要设置和 superview Equal Widths，然后根据需要调整间距。否则子视图宽度约束设置不生效。如果出现其他 view 宽度不对劲的情况，也可以试着用 Equal Widths 解决。&lt;/p&gt;
&lt;p&gt; 如图，分别为宽度不正常情况和使用 Eauql Widths 之后正常情况：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-07%20at%2012.37.01%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-07%20at%2012.37.31%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文用于记录我在使用 AutoLayout 过程中遇到的一些需要注意的事情，一种是容易犯的错误，一种是我找不到原因的情况。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://cheng-kang.github.io/tags/AutoLayout/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 实现多个 TableView 的侧滑与切换（模拟 instagram 系列）</title>
    <link href="http://cheng-kang.github.io/2016/04/06/Swift%20%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%20TableView%20%E7%9A%84%E4%BE%A7%E6%BB%91%E4%B8%8E%E5%88%87%E6%8D%A2%EF%BC%88%E6%A8%A1%E6%8B%9F%20instagram%20%E7%B3%BB%E5%88%97%EF%BC%89/"/>
    <id>http://cheng-kang.github.io/2016/04/06/Swift 实现多个 TableView 的侧滑与切换（模拟 instagram 系列）/</id>
    <published>2016-04-05T18:50:01.000Z</published>
    <updated>2016-04-08T19:36:51.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;关键词：Swift，实现多个 TableView 的侧滑与切换，在 ScrollView 中嵌套多个 TableView，一个页面显示两个 tableview…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标与成果&quot;&gt;&lt;a href=&quot;#目标与成果&quot; class=&quot;headerlink&quot; title=&quot;目标与成果&quot;&gt;&lt;/a&gt;目标与成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;将多个 TableView 放在 ScrollView 里面，将 ScrollView Paging 设置为 Enabled，实现多个 TableView 的侧滑与切换。&lt;/p&gt;
&lt;p&gt;上方的 tab 标签跟随 ScrollView.offset.x 进行动画，蓝条为单独绘制的一个长方形 UIView。&lt;/p&gt;
&lt;p&gt;通过 UIButton 的 IBAction 中的动画，实现点击 tab 标签滑动到对应 TableView。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;storyboard&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;添加一个 UIView，高度设置为 30px，上左右与 superview 间距为 0。在里面放置两个 UIButton。将两个 UIButton 组合成 StackView，设置 StackView 上下左右与 superview 间距为 0，设置 Distribution 为 Fill Equally。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%202.08.00%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%202.09.54%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 storyboard 创建好 ScrollView 和两个 TableView。在 TableView 中创建好 TableViewCell 模板，并且将对应的类和 reuse identifier 设置好（当然你可以新建 xib 文件，然后在代码里设置 reuse identifier）。两个 TableView 应该是 ScrollView 的子视图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你是在 storyboard 里面给 TableView 添加 Prototype Cells，记得给每个 TableView 添加各自的 Prototype Cells。如果只给其中一个添加 Prototype Cells，那么另一个不会自动添加 reuse identifier。在 cellForRowAtIndexPath 方法中，对未添加 Prototype Cells 的 TableView 调用 dequeReusableCellWithIdentifier 时会报错，因为那个 TableView 本来就没有嘛。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置 ScrollView 的约束，本项目为下左右间距均为 0，上间距为 1（用于显示上边 tab 标签栏的阴影）。&lt;/p&gt;
&lt;p&gt;TableView 的约束不用设置，因为我们要在代码中给他们重新定位。&lt;/p&gt;
&lt;p&gt;设置好各个 Prototype Cell 的约束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%202.08.21%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-06%20at%201.53.58%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;FourthViewController.swift（对应的 viewController）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全部代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  FourthViewController.swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Instagram&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Ant on 3/31/16.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright © 2016 Ant. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class FourthViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UIScrollViewDelegate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var tableViewLeft: UITableView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var tableViewRight: UITableView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var tabPanel: UIView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var followBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var youBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var scrollView: UIScrollView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let scrollBar = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var notifications: [Notification] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //创建模拟数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let notification1 = Notification(from: &amp;quot;CHENGKANG&amp;quot;, fromAvatar: UIImage(named: &amp;quot;IMG_8040&amp;quot;)!, to: &amp;quot;Deer&amp;quot;, toAvatar: UIImage(named: &amp;quot;test&amp;quot;)!, type: &amp;quot;like&amp;quot;, images: [UIImage(named: &amp;quot;test&amp;quot;)!, UIImage(named: &amp;quot;test&amp;quot;)!, UIImage(named: &amp;quot;test&amp;quot;)!, UIImage(named: &amp;quot;test&amp;quot;)!, UIImage(named: &amp;quot;test&amp;quot;)!, ], date: &amp;quot;3天前&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let notification2 = Notification(from: &amp;quot;CHENGKANG&amp;quot;, fromAvatar: UIImage(named: &amp;quot;IMG_8040&amp;quot;)!, to: &amp;quot;Deer&amp;quot;, toAvatar: UIImage(named: &amp;quot;test&amp;quot;)!, type: &amp;quot;like&amp;quot;, images: [UIImage(named: &amp;quot;test&amp;quot;)!], date: &amp;quot;3天前&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //添加模拟数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.notifications.append(notification1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.notifications.append(notification2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //初始化要用到的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let WIDTH = self.view.frame.width&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let HEIGHT = self.view.frame.height - 60 - 30 - 49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 tab 标签面板底部阴影&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabPanel.layer.shadowColor = COLOR_GREY.CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabPanel.layer.shadowRadius = 0.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabPanel.layer.shadowOffset = CGSizeMake(0, 0.5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabPanel.layer.shadowOpacity = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //添加 tab 标签面板底部蓝条&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.view.addSubview(self.scrollBar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.scrollBar.backgroundColor = COLOR_LIGHT_BLUE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.scrollBar.frame = CGRectMake(0, 87, WIDTH / 2, 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //初始化按钮颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.followBtn.setTitleColor(COLOR_LIGHT_BLUE, forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 scrollView delegate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.scrollView.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 tableViewLeft delegate，并消除多余分割线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewLeft.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewLeft.dataSource = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewLeft.tableFooterView = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 tableViewRight delegate，并消除多余分割线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewRight.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewRight.dataSource = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewRight.tableFooterView = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 scrollView contentSize&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.scrollView.contentSize = CGSizeMake(WIDTH * 2, HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置两个 tableView 大小位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewLeft.frame = CGRectMake(8, 0, WIDTH - 16, HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tableViewRight.frame = CGRectMake(WIDTH + 8, 0, WIDTH - 16, HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func numberOfSectionsInTableView(tableView: UITableView) -&amp;gt; Int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //可以通过判断当前 tableView 是否与某一个 TableView 相同来给定对应内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        if tableView == self.tableViewRight &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            if self.notifications[indexPath.row].images.count == 1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                let cell = LikeWithPicCell()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                cell.initCell(self.notifications[indexPath.row])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                return cell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                let cell = LikeWithPicsCell()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                cell.initCell(self.notifications[indexPath.row])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                return cell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if self.notifications[indexPath.row].images.count == 1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;LikeWithPicCell&amp;quot;) as! LikeWithPicCell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cell.initCell(self.notifications[indexPath.row])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return cell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;LikeWithPicsCell&amp;quot;) as! LikeWithPicsCell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cell.initCell(self.notifications[indexPath.row])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return cell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if tableView == self.tableViewRight &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //此处 -1 是为了让展示内容有区分，因为用的相同数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return self.notifications.count - 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return self.notifications.count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; CGFloat &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return UITableViewAutomaticDimension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; CGFloat &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return UITableViewAutomaticDimension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func scrollViewDidScroll(scrollView: UIScrollView) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //判断当前 scrollView 是我们项目中的 ScrollView 而非那两个 tableView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if scrollView == self.scrollView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //改变 scrollBar x 坐标，达成同步滑动效果。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let offsetX = scrollView.contentOffset.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.scrollBar.frame = CGRectMake(offsetX / 2, 87, self.view.frame.width / 2, 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //对应修改 btn 文字颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if offsetX &amp;gt; self.view.frame.width / 2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.followBtn.setTitleColor(UIColor.blackColor(), forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.youBtn.setTitleColor(COLOR_LIGHT_BLUE, forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.followBtn.setTitleColor(COLOR_LIGHT_BLUE, forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.youBtn.setTitleColor(UIColor.blackColor(), forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBAction func followBtnPressed(sender: UIButton) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //点击按钮时，通过动画移动到对应 tableView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIView.animateWithDuration(0.3, delay: 0, options: [.CurveEaseInOut], animations: &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.scrollView.contentOffset.x = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;, completion: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBAction func youBtnPressed(sender: UIButton) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //点击按钮时，通过动画移动到对应 tableView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIView.animateWithDuration(0.3, delay: 0, options: [.CurveEaseInOut], animations: &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.scrollView.contentOffset.x = self.view.frame.width&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;, completion: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个项目中，我懒所以两个 TableView 用的相同的 Prototype Cell 和同一组数据，然后在返回第二个 TableView cell 个数时 -1，好在显示时区分二者。&lt;/p&gt;
&lt;h3 id=&quot;需要注意的几点&quot;&gt;&lt;a href=&quot;#需要注意的几点&quot; class=&quot;headerlink&quot; title=&quot;需要注意的几点&quot;&gt;&lt;/a&gt;需要注意的几点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当在一个 ViewController 里面包含多个 TableView 的时候，使用 TableView Delegate 提供的方法时，可以通过判断参数 tableView 是否与项目中对应 TableView 相同来执行对应操作。如上面代码中提到的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if tableView == self.tableViewRight &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //此处 -1 是为了让展示内容有区分，因为用的相同数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return self.notifications.count - 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self.notifications.count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同上，有多个 scrollView 时，同样方法判定当前是哪个 scrollView。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;UITableView 为 UIScrollView 的子类。如果添加了 scrollView delegate，不进行判断的话，可能会出现上下滑动 tableView 时触发 scrollViewDidScroll 方法，导致在第二页时上下滑动时 tab 标签切换到第一个标签。&lt;/li&gt;
&lt;li&gt;不要忘记设置 scrollView.delegate&lt;/li&gt;
&lt;li&gt;不要忘记设置 scrollView.contentSize&lt;/li&gt;
&lt;li&gt;通过设置空白 tableFooterView 为空白 UIView，消除多余分割线。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关键词：Swift，实现多个 TableView 的侧滑与切换，在 ScrollView 中嵌套多个 TableView，一个页面显示两个 tableview…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;目标与成果&quot;&gt;&lt;a href=&quot;#目标与成果&quot; class=&quot;headerlink&quot; title=&quot;目标与成果&quot;&gt;&lt;/a&gt;目标与成果&lt;/h3&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;将多个 TableView 放在 ScrollView 里面，将 ScrollView Paging 设置为 Enabled，实现多个 TableView 的侧滑与切换。&lt;/p&gt;
&lt;p&gt;上方的 tab 标签跟随 ScrollView.offset.x 进行动画，蓝条为单独绘制的一个长方形 UIView。&lt;/p&gt;
&lt;p&gt;通过 UIButton 的 IBAction 中的动画，实现点击 tab 标签滑动到对应 TableView。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="UITableView" scheme="http://cheng-kang.github.io/tags/UITableView/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="UIScrollView" scheme="http://cheng-kang.github.io/tags/UIScrollView/"/>
    
  </entry>
  
  <entry>
    <title>实现 instagram 底部弹出菜单的一个例子（模拟 instagram 系列）</title>
    <link href="http://cheng-kang.github.io/2016/04/03/%E5%AE%9E%E7%8E%B0%20instagram%20%E5%BA%95%E9%83%A8%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88%E6%A8%A1%E6%8B%9F%20instagram%20%E7%B3%BB%E5%88%97%EF%BC%89/"/>
    <id>http://cheng-kang.github.io/2016/04/03/实现 instagram 底部弹出菜单的一个例子（模拟 instagram 系列）/</id>
    <published>2016-04-03T15:51:08.000Z</published>
    <updated>2016-04-06T01:51:32.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;instagram 截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_IMG_8669.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;成果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;要实现的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;黑色半透明遮罩层&lt;/li&gt;
&lt;li&gt;弹出动画&lt;/li&gt;
&lt;li&gt;点击取消按钮或者背景菜单收回&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;应该是有一种跟 UIPresentationController 有关的解决方法，但是我还不会，所以这次不用。&lt;/p&gt;
&lt;p&gt;之前在模拟微博的项目里也用到了弹出层，所以我想这次也义勇和上次同样的方式，在 TabBarController 里面添加 subview。&lt;/p&gt;
&lt;p&gt;但有两点不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上次是点击 tabBarItem 来执行弹出，这次要点击第一个 tab 页里的按钮。怎么样让 TabBarController 得到消息？&lt;/li&gt;
&lt;li&gt;上次弹出的按钮是独立的，这次弹出的菜单和指定的图片有关。所以需要有一个标志记录当前点击的是哪一张图片的 more 按钮。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;解决方案-Part-1-创建菜单视图&quot;&gt;&lt;a href=&quot;#解决方案-Part-1-创建菜单视图&quot; class=&quot;headerlink&quot; title=&quot;解决方案 Part.1 创建菜单视图&quot;&gt;&lt;/a&gt;解决方案 Part.1 创建菜单视图&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 storyboard 拖进一个 ViewController，添加好内容，设置好约束。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-03%20at%2011.25.13%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，这个 ViewController 的 root view 要讲背景设置为 黑色、透明度 30%，以模拟遮罩层。&lt;/p&gt;
&lt;p&gt;新建一个视图文件 BottomMenuView.swift，继承 UIViewController。修改刚才新建的 ViewController 类为 BottomMenuView，并设置 StoryboardID 为”BottomMenu”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-04-03%20at%2011.49.49%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关联好 IBOutlet 对象和点击事件。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import Foundation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class BottomMenuView: UIViewController &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var menuBgView: UIView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var reportBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var shareToFacebookBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var tweetBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var copyURLBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var noticeBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var dismissBtn: UIButton!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBOutlet weak var buttonPanel: UIView!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里是设置颜色、按钮边框形状。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let maskPathAllCorner = UIBezierPath(roundedRect: noticeBtn.bounds,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            byRoundingCorners: [.BottomLeft, .BottomRight, .TopLeft, .TopRight],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cornerRadii: CGSize(width: 5, height: 5.0))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let maskPathTopCorner = UIBezierPath(roundedRect: noticeBtn.bounds,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            byRoundingCorners: [.TopLeft, .TopRight],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cornerRadii: CGSize(width: 5, height: 5.0))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let maskPathBottomCorner = UIBezierPath(roundedRect: noticeBtn.bounds,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            byRoundingCorners: [.BottomLeft, .BottomRight],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cornerRadii: CGSize(width: 5, height: 5.0))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let shapeAllCorner = CAShapeLayer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        shapeAllCorner.path = maskPathAllCorner.CGPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let shapeTopCorner = CAShapeLayer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        shapeTopCorner.path = maskPathTopCorner.CGPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let shapeBottomCorner = CAShapeLayer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        shapeBottomCorner.path = maskPathBottomCorner.CGPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reportBtn.layer.mask = shapeTopCorner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        noticeBtn.layer.mask = shapeBottomCorner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dismissBtn.layer.mask = shapeAllCorner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBAction func bgTapped(sender: UITapGestureRecognizer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //给背景 view 添加一个点击事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //当点击时，让菜单收回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @IBAction func dismissBtnPressed(sender: UIButton) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    //点击事件，当点击时，让菜单收回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 TabBarViewController.swift 中，修改 viewDidLoad 方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.tabBar.tintColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for it in self.tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        it.badgeValue = &amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //找到对应视图，并添加为 TabBarView 的子视图。子视图默认 alpha 值为0。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这样每次只用修改 alpha 值来显示和隐藏，不用重新添加子视图。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.bottomMenu = self.storyboard?.instantiateViewControllerWithIdentifier(&amp;quot;BottomMenu&amp;quot;) as! BottomMenuView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.bottomMenu.modalTransitionStyle = .CoverVertical&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.view.addSubview(self.bottomMenu.view)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.bottomMenu.view.alpha = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方案-Part-2-给-TabBarController-传递消息&quot;&gt;&lt;a href=&quot;#解决方案-Part-2-给-TabBarController-传递消息&quot; class=&quot;headerlink&quot; title=&quot;解决方案 Part.2 给 TabBarController 传递消息&quot;&gt;&lt;/a&gt;解决方案 Part.2 给 TabBarController 传递消息&lt;/h3&gt;&lt;p&gt;因为 more 按钮在 tab 页的 viewController 里面，我们暂时没办法直接执行 TabBarController 里面的函数，或者对它的 view 进行操作，所以要想个办法发送通知。&lt;/p&gt;
&lt;p&gt;发送通知当然是用 NSNotification。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送显示菜单通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 firstViewController （即第一个 tab 页的 controller）中添加 more 按钮点击事件，在里面发送一个通知。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@IBAction func moreButtonPressed(sender: UIButton) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSNotificationCenter.defaultCenter().postNotification(NSNotification(name: &amp;quot;ShowBottomMenu&amp;quot;, object: sender.tag))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个通知里面，object 是当前按钮的 tag 值。这是在每个 cell 初始化的时候，给当前 cell 的每个 button 的 tag 赋值为当前图片的 id，保证之后能够判断每个点击事件来自哪个 cell/图片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送收回菜单通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到 BottomMenuView.swift，在两个点击事件添加发送通知：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@IBAction func bgTapped(sender: UITapGestureRecognizer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSNotificationCenter.defaultCenter().postNotification(NSNotification(name: &amp;quot;DismissBottomMenu&amp;quot;, object: nil))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@IBAction func dismissBtnPressed(sender: UIButton) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSNotificationCenter.defaultCenter().postNotification(NSNotification(name: &amp;quot;DismissBottomMenu&amp;quot;, object: nil))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收通知&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 TabBarViewController.swift 的 viewDidLoad 方法中添加一下两行用于接收通知：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSNotificationCenter.defaultCenter().addObserver(self, selector: &amp;quot;showBottomMenu:&amp;quot;, name: &amp;quot;ShowBottomMenu&amp;quot;, object: nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNotificationCenter.defaultCenter().addObserver(self, selector: &amp;quot;dismissBottomMenu:&amp;quot;, name: &amp;quot;DismissBottomMenu&amp;quot;, object: nil)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;经过上面的步骤，TabBarViewController 就能接收到显示或者收回底部菜单的通知了。然后我们可以在自定义的函数里面编写显示和隐藏的动画。&lt;/p&gt;
&lt;h3 id=&quot;解决方案-Part-3-显示-收回菜单动画&quot;&gt;&lt;a href=&quot;#解决方案-Part-3-显示-收回菜单动画&quot; class=&quot;headerlink&quot; title=&quot;解决方案 Part.3 显示/收回菜单动画&quot;&gt;&lt;/a&gt;解决方案 Part.3 显示/收回菜单动画&lt;/h3&gt;&lt;p&gt;这部分很简单啦。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func showBottomMenu(notification: NSNotification) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //获取当前 section id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let tag = notification.object as! Int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(tag)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.bottomMenu.buttonPanel.frame.origin.y = self.view.frame.height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView.animateWithDuration(0.3) &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.bottomMenu.view.alpha = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.bottomMenu.buttonPanel.frame.origin.y = self.view.frame.height - self.bottomMenu.buttonPanel.frame.height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func dismissBottomMenu(notification: NSNotification) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(notification.object)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView.animateWithDuration(0.3) &amp;#123; () -&amp;gt; Void in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.bottomMenu.view.alpha = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.bottomMenu.buttonPanel.frame.origin.y = self.view.frame.height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 showBottomMenu 方法中，获取到了一个 tag 值，这个是留着将来编写对应的菜单按钮点击事件的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标和成果&quot;&gt;&lt;a href=&quot;#目标和成果&quot; class=&quot;headerlink&quot; title=&quot;目标和成果&quot;&gt;&lt;/a&gt;目标和成果&lt;/h3&gt;&lt;p&gt;instagram 截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_IMG_8669.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;成果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_instagram-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;要实现的内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;黑色半透明遮罩层&lt;/li&gt;
&lt;li&gt;弹出动画&lt;/li&gt;
&lt;li&gt;点击取消按钮或者背景菜单收回&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;应该是有一种跟 UIPresentationController 有关的解决方法，但是我还不会，所以这次不用。&lt;/p&gt;
&lt;p&gt;之前在模拟微博的项目里也用到了弹出层，所以我想这次也义勇和上次同样的方式，在 TabBarController 里面添加 subview。&lt;/p&gt;
&lt;p&gt;但有两点不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上次是点击 tabBarItem 来执行弹出，这次要点击第一个 tab 页里的按钮。怎么样让 TabBarController 得到消息？&lt;/li&gt;
&lt;li&gt;上次弹出的按钮是独立的，这次弹出的菜单和指定的图片有关。所以需要有一个标志记录当前点击的是哪一张图片的 more 按钮。
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>自定义 UITabBar 总结（一个模拟 instagram TabBar 的例子）</title>
    <link href="http://cheng-kang.github.io/2016/03/31/%E8%87%AA%E5%AE%9A%E4%B9%89%20UITabBar%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%8B%9F%20instagram%20TabBar%20%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%89/"/>
    <id>http://cheng-kang.github.io/2016/03/31/自定义 UITabBar 总结（一个模拟 instagram TabBar 的例子）/</id>
    <published>2016-03-31T15:48:38.000Z</published>
    <updated>2016-04-06T01:51:37.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;项目 github 仓库：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Instagram&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模拟 instagram&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;我在练习 iOS 开发。&lt;/p&gt;
&lt;p&gt;碰到了跟 TabBar 有关的东西，希望自己尽量对 TabBar 的使用了解清楚而不是直接复制粘贴，所以整体研究一番，在此总结。&lt;/p&gt;
&lt;p&gt;内容主要跟 TabBar 的样式修改有关，涉及到一点点点击事件。文中提到的诸如&lt;code&gt;比较重要的方法&lt;/code&gt;、&lt;code&gt;比较重要的属性&lt;/code&gt;的重要性均是相对本文内容而言。&lt;/p&gt;
&lt;p&gt;要实现的结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.46.56%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，点击中间按钮时，不激活那个 tab 页，而是执行自定义的任务。（因为 instagram 中间那个按钮功能就是和其他的不一样嘛。）&lt;/p&gt;
&lt;h3 id=&quot;相关文档&quot;&gt;&lt;a href=&quot;#相关文档&quot; class=&quot;headerlink&quot; title=&quot;相关文档&quot;&gt;&lt;/a&gt;相关文档&lt;/h3&gt;&lt;p&gt;首先，敬上四篇相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarController_Class/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UITabBarController Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarControllerDelegate_Protocol/index.html#//apple_ref/occ/intf/UITabBarControllerDelegate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UITabBarControllerDelegate Protocol Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBar_Class/index.html#//apple_ref/occ/cl/UITabBar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UITabBar Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarItem_Class/index.html#//apple_ref/occ/cl/UITabBarItem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UITabBarItem Class Reference&lt;/a&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UITabBarController、UITabBarControllerDelegate、UITabBar-和-UITabBarItem&quot;&gt;&lt;a href=&quot;#UITabBarController、UITabBarControllerDelegate、UITabBar-和-UITabBarItem&quot; class=&quot;headerlink&quot; title=&quot;UITabBarController、UITabBarControllerDelegate、UITabBar 和 UITabBarItem&quot;&gt;&lt;/a&gt;UITabBarController、UITabBarControllerDelegate、UITabBar 和 UITabBarItem&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;先来一点没那么有趣的东西：D。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;UITabBarController&lt;/strong&gt;&lt;br&gt;当你使用 UITabBarController 的时候，你可以新建一个类继承 UITabBarController 来管理你的 TabBar 及相关事件。&lt;/p&gt;
&lt;p&gt;UITabBarController 包含许多属性，与本文相关的比较重要的几个属性是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delegate：一个 UITabBarControllerDelegate 对象，用于追踪和处理一些 TabBar 事件。&lt;/li&gt;
&lt;li&gt;tabBar： 一个 UITabBar 对象，直接一点说就是你在屏幕上看到的那个 TabBar。&lt;/li&gt;
&lt;li&gt;viewControllers：每个 Tab 页面对应的 viewController 组成的列表。可以通过排列顺序值获取对应 viewController，比如第一个 tab 的 viewController 为：self.viewControllers[0]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UITabBarControllerDelegate&lt;/strong&gt;&lt;br&gt;一个比较重要的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;override func tabBarController(_ tabBarController: UITabBarController, shouldSelectViewController viewController: UIViewController) -&amp;gt; Bool&lt;/code&gt;&lt;br&gt;用于决定被选中的 tab 是否激活。当返回值是 false 时，保留在之前的 tab 页面；当返回值是 true 时，激活当前选中的 tab 页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UITabBar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几个重要的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;items：一个 UITabBarItem 列表，即每一个 tab 按钮对象组成的列表。&lt;/li&gt;
&lt;li&gt;selectedItem：当前被选中的 TabBarItem。&lt;/li&gt;
&lt;li&gt;tintColor：覆盖被选中的 TabBarItem 图片的颜色。（默认为蓝色。就是选中时图标的颜色。）&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.43.26%20PM.png&quot; alt=&quot;&quot;&gt;&lt;ul&gt;
&lt;li&gt;barTintColor：整个 TabBar 的背景颜色。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;UITabBarItem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几个重要的方法和属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化方法（init(…)）。可以通过 init 方法新建 TabBarItem，并赋予指定初始值，比如图片、图片颜色、选中状态时的图片及颜色、tag 值等等。&lt;/li&gt;
&lt;li&gt;badgeValue：看图。通过设置这个值可以直接得到这个效果，我觉得挺有意思的，很省事的样子。&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.39.12%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;selectedImage：TabBarItem 被选中时显示的图片，默认和未选中状态图片一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;TabBar-基本样式的设置&quot;&gt;&lt;a href=&quot;#TabBar-基本样式的设置&quot; class=&quot;headerlink&quot; title=&quot;TabBar 基本样式的设置&quot;&gt;&lt;/a&gt;TabBar 基本样式的设置&lt;/h3&gt;&lt;p&gt;我目前的看法是，&lt;strong&gt;能用 storyboard 解决的一定不用代码&lt;/strong&gt;。所以基本样式设置全部在 storyboard 完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TabBar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选中 TabBar，打开右侧的属性面板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.58.59%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen_Shot_2016-03-31_at_8_59_09_PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般都不用修改 item Positioning，默认是居中均匀分布，应该符合大部分需求。&lt;/li&gt;
&lt;li&gt;Translucent 半透明度可以根据需要勾选。像微博的客户端就是半透明的，而instagram 不是。&lt;/li&gt;
&lt;li&gt;没有特别需求的话，可以直接在这里设置 Image Tint。我们这个例子在代码里面设置。&lt;/li&gt;
&lt;li&gt;Style：系统提供了 Default 默认的白色背景和可选的 Black 黑色背景。可根据需要选择。如图：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TabBarItem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选中 tab 页面的 viewController 底部的 tab 图标。右侧的属性面板如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.20.49%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;先看下面的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Title：就是在图标下显示的文字。可以为空，可以通过 Title Position 调整位置。&lt;/li&gt;
&lt;li&gt;Image：图标的图片。&lt;/li&gt;
&lt;li&gt;Tag：当前 TabBarItem 的标志，设置一个值方便在代码里找到对应的 TabBarItem。&lt;/li&gt;
&lt;li&gt;Enabled：没什么好说的：）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后是这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Badge：就是之前提到过的红点。可以在这里设置一个初始值。&lt;/li&gt;
&lt;li&gt;System Item：一些系统自带的 Tab 图标，根据需要自行取用。一般还是用自己的图吧。&lt;/li&gt;
&lt;li&gt;Selected Image：tab 被选中的时候的图片。&lt;/li&gt;
&lt;li&gt;Title Postition：设置 title 的位置。&lt;br&gt;可以如图设置&lt;code&gt;水平偏移&lt;/code&gt;和&lt;code&gt;垂直偏移&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.28.11%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是：水平偏移对图标有影响，垂直偏移对图标没有影响。&lt;/strong&gt;效果如图，红线是我自己加的一条中线，用于对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.28.19%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;One more thing :)&lt;/p&gt;
&lt;p&gt;属性面板右边有一个设置尺寸的面板：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.34.25%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在这里可以设置图标的偏移量，从而修改图标的位置。&lt;/p&gt;
&lt;p&gt;因为默认图标在 Title上面，位置偏高，就算没有 Title 图标也在那个位置。所以当我们不用 Title 的时候，像 instagram，需要调整图标的位置，让它看起来居中一点。&lt;/p&gt;
&lt;p&gt;一种是直接在面板设置，一种是用代码设置。&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.40.26%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tabBarItem.imageInsets = UIEdgeInsetsMake(6, 0, -6, 0);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对比效果如图：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.40.45%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：top 和 bottom 要设置成相反数，不然点击 tab 图标时 image 的大小会一直改变！！！&lt;/strong&gt;&lt;br&gt;如图：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_tabbar-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候需要调整图标的大小，不建议用代码修改或者视图通过 image inset 来修改。&lt;/p&gt;
&lt;p&gt;建议做图标的时候，就在图标周围留白。比如 75px 的图片，其中上下左右各留白 20px，这样图标就小了。&lt;/p&gt;
&lt;p&gt;另外，根据 Apple 制定的标准，tab 图标准备 3 个尺寸，分别是 75 px（@3x），55px（@2x）和25px。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2011.40.42%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;TabBar-个性化样式设置要求（大家好，重点要开始了：D）&quot;&gt;&lt;a href=&quot;#TabBar-个性化样式设置要求（大家好，重点要开始了：D）&quot; class=&quot;headerlink&quot; title=&quot;TabBar 个性化样式设置要求（大家好，重点要开始了：D）&quot;&gt;&lt;/a&gt;TabBar 个性化样式设置要求（大家好，重点要开始了：D）&lt;/h3&gt;&lt;p&gt;经过之前一些简单的步骤，你将得到如图效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%209.50.54%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;记得将五个 TabBarItem 的 tag 设置为 0 - 5，方便以后。&lt;/p&gt;
&lt;p&gt;但是我们要实现的不是这么简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选中 TabBarItem 背景颜色为黑色。&lt;/li&gt;
&lt;li&gt;未选中 TabBarItem 背景颜色为某种灰色。&lt;/li&gt;
&lt;li&gt;选中 TabBarItem 图标颜色为白色。&lt;/li&gt;
&lt;li&gt;未选中 TabBarItem 图标颜色为某种灰色。&lt;/li&gt;
&lt;li&gt;中间按钮始终背景颜色为某种蓝色、图标颜色为白色。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何在-UITabBarController-中修改样式&quot;&gt;&lt;a href=&quot;#如何在-UITabBarController-中修改样式&quot; class=&quot;headerlink&quot; title=&quot;如何在 UITabBarController 中修改样式&quot;&gt;&lt;/a&gt;如何在 UITabBarController 中修改样式&lt;/h3&gt;&lt;p&gt;新建一个 Cocoa Touch Class，取名叫&lt;code&gt;MainTabBarViewController&lt;/code&gt;，继承 UITabBarController。去 storyboard 把作为入口的那个 UITabBarController 的类修改为&lt;code&gt;MainTabBarViewController&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个时候，我们就可以在&lt;code&gt;MainTabBarViewController&lt;/code&gt;中对 TabBar 进行修改了。&lt;/p&gt;
&lt;p&gt;首先来试验一下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainTabBarViewController: UITabBarController &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置 tabBar 图标选中时的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBar.tintColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //遍历全部 tabBarItem，设置 badege 值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for one in self.tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            one.badgeValue = &amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;WOW。好酷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.01.19%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;选中 TabBarItem 图标颜色为白色。&lt;/del&gt; 达成√！！&lt;/li&gt;
&lt;li&gt;&lt;del&gt;未选中 TabBarItem 图标颜色为某种灰色。&lt;/del&gt; 达成√！！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后还顺便尝试了设置 badge 值。&lt;/p&gt;
&lt;h3 id=&quot;如何通过代码设置单个-TabBarItem-背景颜色&quot;&gt;&lt;a href=&quot;#如何通过代码设置单个-TabBarItem-背景颜色&quot; class=&quot;headerlink&quot; title=&quot;如何通过代码设置单个 TabBarItem 背景颜色&quot;&gt;&lt;/a&gt;如何通过代码设置单个 TabBarItem 背景颜色&lt;/h3&gt;&lt;p&gt;之前提到过 barTintColor 这个属性。通过&lt;code&gt;self.tabBar.barTintColor = UIColor().greyColor()&lt;/code&gt;就可以把背景设置为灰色了。但是这并没有完成被选中 TabBarItem 背景颜色变为黑色的要求。&lt;/p&gt;
&lt;p&gt;事实上，&lt;strong&gt;并没有直接设置单个 TabBarItem 背景颜色的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写 viewDidAppear 方法和 didSelectItem 方法。didSelectItem 是每当有 tabBarItem 被选中时执行的函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainTabBarViewController: UITabBarController &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//定义一个用于存储背景层 view 的列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var tabBarItemBgViews: [UIView] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBar.tintColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for it in self.tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            it.badgeValue = &amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    //初始化需要用到的尺寸数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let ITEM_WIDTH = self.tabBar.frame.width / 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let ITEM_HEIGHT = CGFloat(49)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //初始化 tab bar item 背景层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for one in self.tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            let vw = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            vw.backgroundColor = UIColor(red: 37/255, green: 29/255, blue: 42/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            vw.frame = CGRectMake(ITEM_WIDTH * CGFloat(one.tag), 0, ITEM_WIDTH, ITEM_HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.tabBarItemBgViews.append(vw)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //将背景层插入到 index 为 1 的位置，这样背景层就在图标下面。记住这个 1 就好了：）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tabBar.insertSubview(vw, atIndex: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //修改第一个 item 的背景色为选中状态颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBarItemBgViews[0].backgroundColor = UIColor.blackColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //自定义中间按钮样式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBarItemBgViews[2].backgroundColor = UIColor(red: 17/255, green: 86/255, blue: 136/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func tabBar(tabBar: UITabBar, didSelectItem item: UITabBarItem) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    //当选中的 TabBarItem 不是中间那个时，改变背景颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    if item.tag != 2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        for one in tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			        //将当前被选中的 TabBarItem 背景颜色设置为黑色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            if one.tag == item.tag &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	                self.tabBarItemBgViews[one.tag].backgroundColor = UIColor.blackColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	                //将其他 TabBarItem 背景颜色设置为灰色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					        self.tabBarItemBgViews[one.tag].backgroundColor = UIColor(red: 37/255, green: 29/255, blue: 42/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        //将中间 TabBarItem 的背景颜色重置为蓝色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        self.tabBarItemBgViews[2].backgroundColor = UIColor(red: 17/255, green: 86/255, blue: 136/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过上面的代码，得到了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.14.04%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：为什么是重写 viewDidAppear 方法而不是 viewDidLoad&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把上面那段代码写在&lt;code&gt;viewDidLoad&lt;/code&gt;方法中，会出现如下情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_tabbar-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，第一个 TabBarItem 没有图标，而且点击无效。&lt;/p&gt;
&lt;p&gt;简单来说，在&lt;code&gt;viewDidLoad&lt;/code&gt;的时候，页面的那些视图大概还没准备好，所以插入的时候会有错误。包括写在&lt;code&gt;viewWillAppear&lt;/code&gt;中也会出现同样问题。&lt;/p&gt;
&lt;p&gt;所以记得重写&lt;code&gt;viewDiaAppear&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开 app 的时候，中间按钮图标颜色不是白色。（当然这是因为我们上面代码里面没有设置。）&lt;/li&gt;
&lt;li&gt;点击中间按钮，进入了对应的 tab 页面，如图。（这不是我们希望的。）&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.24.06%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;如何修改-TabBarItem-样式&quot;&gt;&lt;a href=&quot;#如何修改-TabBarItem-样式&quot; class=&quot;headerlink&quot; title=&quot;如何修改 TabBarItem 样式&quot;&gt;&lt;/a&gt;如何修改 TabBarItem 样式&lt;/h3&gt;&lt;p&gt;初一想，在&lt;code&gt;viewDidAppear&lt;/code&gt;结尾加上这段代码就可以：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//将 tabBar 包含的 tabBarItem 中的第二个修改为自定义的一个 UITabBarItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//使用原本设置的图片，原本设置的 tag 值，并将图片设置为使用原图片。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//imageWithRenderingMode(.AlwaysOriginal)，稍后详细解释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.tabBar.items![2] = UITabBarItem(title: nil, image: self.tabBarItem.image?.imageWithRenderingMode(.AlwaysOriginal), tag: self.tabBarItem.tag)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//修改偏移量，让图标居中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.tabBar.items![2].imageInsets = UIEdgeInsetsMake(6, 0, -6, 0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;编译也没有问题。但是运行的时候报错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.38.58%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意：不能直接在 tab bar controller 里面修改 tab bar item 的属性&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文档原文是这样说的：&lt;br&gt;”You should never access the tab bar view of a tab bar controller directly. To configure the tabs of a tab bar controller, you assign the view controllers that provide the root view for each tab to the &lt;code&gt;viewControllers&lt;/code&gt; property.”&lt;br&gt;这里我觉得 tab bar view 可能说得不够清楚，应该是 tab bar item view。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能有同学会对上面我们增加背景有疑问。那难道不是修改 tab bar item 吗？&lt;/p&gt;
&lt;p&gt;并不是。上面我们其实是给 TabBar 增加子视图，并定位到各个 TabBarItem 背后，看起来像是在给 TabBarItem 添加背景。并没有直接修改 TabBarItem。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如文档所说，我们应该在对应的 viewController 里面去操作。&lt;/p&gt;
&lt;p&gt;到我们之前应该创建好了的&lt;code&gt;ThirdViewController.swift&lt;/code&gt;里面，写一个用于修改第三个 TabBarItem 样式的函数。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class ThirdViewController: UIViewController, UITabBarControllerDelegate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func initTabBarItem() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //将该 TabBarItem 替换为一个新的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBarItem = UITabBarItem(title: nil, image: self.tabBarItem.image?.imageWithRenderingMode(.AlwaysOriginal), tag: self.tabBarItem.tag)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置偏移量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBarItem.imageInsets = UIEdgeInsetsMake(6, 0, -6, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后回到&lt;code&gt;MainTabBarViewController.swift&lt;/code&gt;。加上这两句：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let vc = self.viewControllers![2] as! ThirdViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vc.initTabBarItem()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;viewDidAppear&lt;/code&gt;方法现在应该如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewDidAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let ITEM_WIDTH = self.tabBar.frame.width / 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let ITEM_HEIGHT = CGFloat(49)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //初始化 tab bar item 背景层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for one in self.tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let vw = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vw.backgroundColor = UIColor(red: 37/255, green: 29/255, blue: 42/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vw.frame = CGRectMake(ITEM_WIDTH * CGFloat(one.tag), 0, ITEM_WIDTH, ITEM_HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBarItemBgViews.append(vw)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tabBar.insertSubview(vw, atIndex: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //修改第一个 item 的背景色为选中状态颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.tabBarItemBgViews[0].backgroundColor = UIColor.blackColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义中间按钮样式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.tabBarItemBgViews[2].backgroundColor = UIColor(red: 17/255, green: 86/255, blue: 136/255, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //获取第三个 TabBarItem 对应的 viewController，然后调用修改样式函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let vc = self.viewControllers![2] as! ThirdViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vc.initTabBarItem()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里我们用到了之前提到的&lt;code&gt;UITabBarController&lt;/code&gt;的&lt;code&gt;viewControllers&lt;/code&gt;属性，通过下标获取到对应的&lt;code&gt;viewContrller&lt;/code&gt;，然后调用里面的函数，完成样式修改。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2010.54.50%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;中间按钮始终背景颜色为某种蓝色、图标颜色为白色。&lt;/del&gt; 达成√！！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是点击中间的按钮还是会进入对应的 tab 页面。下下部分继续解决这个问题。&lt;/p&gt;
&lt;h3 id=&quot;imageWithRenderingMode（稍微详细的介绍）&quot;&gt;&lt;a href=&quot;#imageWithRenderingMode（稍微详细的介绍）&quot; class=&quot;headerlink&quot; title=&quot;imageWithRenderingMode（稍微详细的介绍）&quot;&gt;&lt;/a&gt;imageWithRenderingMode（稍微详细的介绍）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#//apple_ref/occ/instm/UIImage/imageWithRenderingMode:&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;imageWithRenderingMode:&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UIImage 自身有一个方法是 imageWithRenderingMode()。&lt;br&gt;有三个可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.Automatic&lt;/li&gt;
&lt;li&gt;.AlwaysOriginal：保持原样&lt;/li&gt;
&lt;li&gt;.AlwaysTemplate：留住图片的样板，忽略原图颜色。（比如设置为 tabBarItem.image 的图片，默认是渲染模式（rendering mode）是 .AlwaysTemplate，只保留了形状，默认是灰色。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想让 tabBarItem.image 的颜色保持原图颜色，就要用一个 RenderingMode 为 .AlwaysOriginal 的图片替换。也就是上面用到的那种方式。&lt;/p&gt;
&lt;h3 id=&quot;如何自定义-TabBarItem-点击事件，UITabBarControllerDelegate&quot;&gt;&lt;a href=&quot;#如何自定义-TabBarItem-点击事件，UITabBarControllerDelegate&quot; class=&quot;headerlink&quot; title=&quot;如何自定义 TabBarItem 点击事件，UITabBarControllerDelegate&quot;&gt;&lt;/a&gt;如何自定义 TabBarItem 点击事件，UITabBarControllerDelegate&lt;/h3&gt;&lt;p&gt;之前提到， &lt;code&gt;override func tabBarController(_ tabBarController: UITabBarController, shouldSelectViewController viewController: UIViewController) -&amp;gt; Bool&lt;/code&gt;，用于决定被选中的 tab 是否激活。当返回值是 false 时，保留在之前的 tab 页面；当返回值是 true 时，激活当前选中的 tab 页面。&lt;/p&gt;
&lt;p&gt;我们要做的是，当被选中的是第三个 tab 时，保留之前的 tab 页面。&lt;/p&gt;
&lt;p&gt;思路就是这样，怎么做呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.设置 UITabBarControllerDelegate&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class MainTabBarViewController: UITabBarController, UITabBarControllerDelegate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var tabBarItemBgViews: [UIView] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tabBar.tintColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for it in self.tabBar.items! &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            it.badgeValue = &amp;quot;100&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.delegate = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;给&lt;code&gt;MainTabBarViewController&lt;/code&gt;类添加&lt;code&gt;UITabBarControllerDelegate&lt;/code&gt;委托，并在&lt;code&gt;viewDidLoad&lt;/code&gt;中将自己的 delegate 设置为自己。&lt;/p&gt;
&lt;p&gt;这个时候我们就可以在&lt;code&gt;MainTabBarViewController&lt;/code&gt;中实现&lt;code&gt;UITabBarControllerDelegate&lt;/code&gt;中的方法来监控和响应事件。&lt;/p&gt;
&lt;p&gt;重写如下方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func tabBarController(tabBarController: UITabBarController, shouldSelectViewController viewController: UIViewController) -&amp;gt; Bool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if viewController.tabBarItem.tag == 2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		    print(viewController.tabBarItem.tag)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当被选中 tabBarItem.tag 等于 2 时，即为中间按钮时，返回 false，保留之前的 tab 页面；否则切换到新页面。&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_tabbar-3.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;print()&lt;/code&gt;方法是用来演示，我们可以在这里做一些其他的事情，比如像 instagram 一样弹出拍照页面。具体实现可以参考我之前的模拟微博项目。之后我也会继续完成模拟 instagram 项目，到时候也可以在我 github 看到。&lt;/p&gt;
&lt;p&gt;如图，当点击中间按钮时，打印出了tag值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%2011.25.41%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;结束&quot;&gt;&lt;a href=&quot;#结束&quot; class=&quot;headerlink&quot; title=&quot;结束&quot;&gt;&lt;/a&gt;结束&lt;/h3&gt;&lt;p&gt;以上就是对自定义 TabBar 样式以及一点点事件相关的总结。&lt;/p&gt;
&lt;p&gt;希望对大家有帮助。&lt;/p&gt;
&lt;p&gt;因为我也是刚开始自学 iOS 开发，遇到很多问题需要花很长时间去找答案。所以希望能写出一些有意义的总结，和其他初学者分享，减少大家找不到解决方案的烦恼。&lt;/p&gt;
&lt;p&gt;：D&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目 github 仓库：&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Instagram&quot;&gt;模拟 instagram&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引语&quot;&gt;&lt;a href=&quot;#引语&quot; class=&quot;headerlink&quot; title=&quot;引语&quot;&gt;&lt;/a&gt;引语&lt;/h3&gt;&lt;p&gt;我在练习 iOS 开发。&lt;/p&gt;
&lt;p&gt;碰到了跟 TabBar 有关的东西，希望自己尽量对 TabBar 的使用了解清楚而不是直接复制粘贴，所以整体研究一番，在此总结。&lt;/p&gt;
&lt;p&gt;内容主要跟 TabBar 的样式修改有关，涉及到一点点点击事件。文中提到的诸如&lt;code&gt;比较重要的方法&lt;/code&gt;、&lt;code&gt;比较重要的属性&lt;/code&gt;的重要性均是相对本文内容而言。&lt;/p&gt;
&lt;p&gt;要实现的结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-31%20at%208.46.56%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，点击中间按钮时，不激活那个 tab 页，而是执行自定义的任务。（因为 instagram 中间那个按钮功能就是和其他的不一样嘛。）&lt;/p&gt;
&lt;h3 id=&quot;相关文档&quot;&gt;&lt;a href=&quot;#相关文档&quot; class=&quot;headerlink&quot; title=&quot;相关文档&quot;&gt;&lt;/a&gt;相关文档&lt;/h3&gt;&lt;p&gt;首先，敬上四篇相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarController_Class/&quot;&gt;UITabBarController Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarControllerDelegate_Protocol/index.html#//apple_ref/occ/intf/UITabBarControllerDelegate&quot;&gt;UITabBarControllerDelegate Protocol Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBar_Class/index.html#//apple_ref/occ/cl/UITabBar&quot;&gt;UITabBar Class Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITabBarItem_Class/index.html#//apple_ref/occ/cl/UITabBarItem&quot;&gt;UITabBarItem Class Reference&lt;/a&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="UITabBar" scheme="http://cheng-kang.github.io/tags/UITabBar/"/>
    
      <category term="UITabBatItem" scheme="http://cheng-kang.github.io/tags/UITabBatItem/"/>
    
      <category term="UITabBarController" scheme="http://cheng-kang.github.io/tags/UITabBarController/"/>
    
      <category term="UITabBarControllerDelegate" scheme="http://cheng-kang.github.io/tags/UITabBarControllerDelegate/"/>
    
  </entry>
  
  <entry>
    <title>仿微博 iOS 客户端 TabBar 中间按钮</title>
    <link href="http://cheng-kang.github.io/2016/03/30/%E4%BB%BF%E5%BE%AE%E5%8D%9A%20iOS%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20TabBar%20%E4%B8%AD%E9%97%B4%E6%8C%89%E9%92%AE/"/>
    <id>http://cheng-kang.github.io/2016/03/30/仿微博 iOS 客户端 TabBar 中间按钮/</id>
    <published>2016-03-29T18:02:07.000Z</published>
    <updated>2016-04-06T01:51:24.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Weibo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模仿微博客户端项目源码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在模仿微博 iOS 客户端。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.05.03%20AM%20copy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;微博客户端 TabBar 中间按钮和其他按钮不一样，一个是样式不一样，一个是点击事件不一样。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;第一个想法其实是建一个 UITabBarController 的子类，自定义 TabBar 的样式，但是因为还没学习过，所以这次希望另找一个办法。&lt;/p&gt;
&lt;p&gt;第二个想法是用一个 button 覆盖 TabBar 中间按钮。无非就是在代码里新建一个&lt;code&gt;UIButton&lt;/code&gt;，用&lt;code&gt;CGRectMake()&lt;/code&gt;定位。&lt;/p&gt;
&lt;h3 id=&quot;一个错误的尝试&quot;&gt;&lt;a href=&quot;#一个错误的尝试&quot; class=&quot;headerlink&quot; title=&quot;一个错误的尝试&quot;&gt;&lt;/a&gt;一个错误的尝试&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;p&gt;有了上面的思路，我就在首页的 ViewController 中的&lt;code&gt;viewDidLoad()&lt;/code&gt;方法中添加了如下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//100px 高宽随便设置用来测试的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let postBtn = UIButton()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;postBtn.frame = CGRectMake(self.view.frame.width/2 - 50, self.view.frame.height - 100, 100, 100)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;postBtn.setBackgroundImage(UIImage(named: &amp;quot;post_btn&amp;quot;), forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.view.addSubview(postBtn)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.16.31%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按钮被什么东西挡住了？&lt;/li&gt;
&lt;li&gt;这个按钮添加在首页的 View 里面，所以只有首页有，其他 tab 怎么办？每个 tab 写一个吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问题一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Tabbed Application，底部始终有一个在最上层的 TabBar。每一个 tab 页面的 view 都在 TabBar 下面，所以在 tab 页面的 view 中在 TabBar 所在的位置添加子 subview，subview 会被盖住。&lt;/p&gt;
&lt;p&gt;所以思路二行不通了吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重复一点代码倒没什么，不过有没有办法避免呢？&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;p&gt;我发现作为 Initial View Controller 的这个 Tab Bar View Controller 也可以添加一个自定义的 ViewController。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.31.34%20AM2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是我新建了一个 UITabBarController 的子类。在&lt;code&gt;viewDidLoad()&lt;/code&gt;中添加了 button。下面的代码是调整过 button 大小位置后的最终代码。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//  TabBarViewController.swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import UIKit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class TabBarViewController: UITabBarController &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override func viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //  初始化一些要用到的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let WINDOW_HEIGHT = self.view.frame.height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let TAB_HEIGHT = self.tabBar.frame.height&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let GRID_WIDTH = self.view.frame.width / 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let MARGIN_X = CGFloat(2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let MARGIN_Y = CGFloat(5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let BTN_WIDTH = TAB_HEIGHT - MARGIN_X * 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let BTN_HEIGHT = TAB_HEIGHT - MARGIN_Y * 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //  遮罩层，用于遮挡原本的 TabBarItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let modalView = UIView()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        modalView.frame = CGRectMake(GRID_WIDTH * 2, WINDOW_HEIGHT - TAB_HEIGHT, GRID_WIDTH, TAB_HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.view.addSubview(modalView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //  添加自定义按钮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let postBtn = UIButton()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        postBtn.frame = CGRectMake(GRID_WIDTH * 2 + (GRID_WIDTH - BTN_WIDTH) / 2, WINDOW_HEIGHT - TAB_HEIGHT + MARGIN_Y, BTN_WIDTH, BTN_HEIGHT)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        postBtn.setBackgroundImage(UIImage(named: &amp;quot;post_btn&amp;quot;), forState: .Normal)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.view.addSubview(postBtn)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //  给按钮添加事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        postBtn.addTarget(self, action: &amp;quot;postButtonClicked:&amp;quot;, forControlEvents: .TouchUpInside)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.05.03%20AM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot; title=&quot;解释&quot;&gt;&lt;/a&gt;解释&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;对于问题一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为是直接在 TabBarController 的 view 上添加 subview，所以按钮正常显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于问题二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 TabBar 是所有 tab 页面公用的，所以不用在每个页面单独添加按钮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遮罩层的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为自定义按钮的大小没有覆盖 TabBar 中间 item 的大小，所以点击边缘部分会进入对应的 tab 页面。而微博客户端这个按钮点击后，应该是出现如下页面，而非进入 tab 页。所以用遮罩层挡住那个 TabBar item。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_weibo-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义按钮的点击事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个加号按钮点击完之后应该是出现一个半透明视图，包含一些按钮。所以我在最后给按钮添加了一个点击事件，负责完成显示新视图及其中的动画。&lt;/p&gt;
&lt;p&gt;如果对这个半透明视图和其中动画的实现有兴趣，可以到我 github 下载源码看看。因为都是最基本的 Animation，所以可能不会单独写一篇分享。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Weibo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模拟微博客户端 github 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人觉得值得注意的是，我的解决方案是：这个半透明视图在第一次出现之后就保存在 TabBarViewController 的类成员变量里，之后的关闭和再显示只是将视图的 alpha 值在 0 和 1 之间切换。&lt;/p&gt;
&lt;p&gt;说不定也会总结一次。因为实现过程中踩到一些跟 Animation 有关的坑，比如&lt;strong&gt;有些属性变换是立即执行的，不能用动画渐变实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基本的 Animation 知识，建议去看 &lt;a href=&quot;http://weibo.com/yongjianlin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@林永坚Jake &lt;/a&gt; 在慕课网发布的 &lt;a href=&quot;http://www.imooc.com/learn/392&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-动画入门&lt;/a&gt; 和 &lt;a href=&quot;http://www.imooc.com/learn/395&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS-动画进阶&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Weibo&quot;&gt;模仿微博客户端项目源码&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在模仿微博 iOS 客户端。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-30%20at%201.05.03%20AM%20copy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;微博客户端 TabBar 中间按钮和其他按钮不一样，一个是样式不一样，一个是点击事件不一样。&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h3&gt;&lt;p&gt;第一个想法其实是建一个 UITabBarController 的子类，自定义 TabBar 的样式，但是因为还没学习过，所以这次希望另找一个办法。&lt;/p&gt;
&lt;p&gt;第二个想法是用一个 button 覆盖 TabBar 中间按钮。无非就是在代码里新建一个&lt;code&gt;UIButton&lt;/code&gt;，用&lt;code&gt;CGRectMake()&lt;/code&gt;定位。&lt;/p&gt;
&lt;h3 id=&quot;一个错误的尝试&quot;&gt;&lt;a href=&quot;#一个错误的尝试&quot; class=&quot;headerlink&quot; title=&quot;一个错误的尝试&quot;&gt;&lt;/a&gt;一个错误的尝试&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://cheng-kang.github.io/tags/Swift/"/>
    
      <category term="UITabBar" scheme="http://cheng-kang.github.io/tags/UITabBar/"/>
    
  </entry>
  
  <entry>
    <title>【译】iOS 基础：Frames、Bounds 和 CGGeometry</title>
    <link href="http://cheng-kang.github.io/2016/03/26/%E3%80%90%E8%AF%91%E3%80%91iOS%20%E5%9F%BA%E7%A1%80%EF%BC%9AFrames%E3%80%81Bounds%20%E5%92%8C%20CGGeometry/"/>
    <id>http://cheng-kang.github.io/2016/03/26/【译】iOS 基础：Frames、Bounds 和 CGGeometry/</id>
    <published>2016-03-26T11:35:02.000Z</published>
    <updated>2016-03-26T19:36:21.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://code.tutsplus.com/tutorials/ios-fundamentals-frames-bounds-and-cggeometry--cms-21196&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《iOS Fundamentals: Frames, Bounds, and CGGeometry》&lt;/a&gt;&lt;br&gt;程康，2016 年 3 月 26 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你习惯支持点语法的语言，要搞清楚&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;并不难。不过编程式定位视图或者编写绘图代码一般都很长，因此变得很难读明白。&lt;/p&gt;
&lt;p&gt;在这个教程里，我希望能澄清一些对 frames 和 bounds 的误解，并且介绍一下&lt;strong&gt;CGGeometry&lt;/strong&gt;，它是一个结构体、常量和功能的集合，能让你更轻松地运用&lt;code&gt;CGPoint&lt;/code&gt;，&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型&quot;&gt;&lt;/a&gt;1.数据类型&lt;/h3&gt;&lt;p&gt;如果你刚开始接触 iOS 或者 OS X 开发，你可能会想&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;到底是什么。CGGeometry Reference 定义了一系列几何图元（geometric primitives）或者说结构，我们现在关注的是其中的&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大多数人应该知道，&lt;code&gt;CGPoint&lt;/code&gt;是定义了坐标系中一个点的 C 结构体。这个坐标系的原点在 iOS 的左上方以及 OS X 的左下方。换句话说，纵轴方向在 iOS 和 OS X 上不一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CGSize&lt;/code&gt;是另一个简单的 C 结构体，它定义了一个宽度值（width）和高度值（height）。&lt;code&gt;CGRect&lt;/code&gt;包含一个&lt;code&gt;origin&lt;/code&gt;（原点）字段、一个&lt;code&gt;CGPoint&lt;/code&gt;和一个&lt;code&gt;size&lt;/code&gt;（大小）字段，即一个&lt;code&gt;CGSize&lt;/code&gt;。&lt;code&gt;origin&lt;/code&gt;（原点）和&lt;code&gt;size&lt;/code&gt;（大小）字段一起决定了一个矩形的位置和大小。&lt;/p&gt;
&lt;p&gt;CGGeometry Reference 也定义了其他类型，例如&lt;code&gt;CGFloat&lt;/code&gt;和&lt;code&gt;CGVector&lt;/code&gt;。&lt;code&gt;CGFloat&lt;/code&gt;就是一个&lt;code&gt;float&lt;/code&gt;（单精度浮点型）或者&lt;code&gt;double&lt;/code&gt;(双精度浮点型)的&lt;code&gt;typedef&lt;/code&gt;（类型重定义），是哪一种取决于应用运行的机器结构是 32 位还是 64 位。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-Frames-和-Bounds&quot;&gt;&lt;a href=&quot;#2-Frames-和-Bounds&quot; class=&quot;headerlink&quot; title=&quot;2.Frames 和 Bounds&quot;&gt;&lt;/a&gt;2.Frames 和 Bounds&lt;/h3&gt;&lt;p&gt;第一个要搞清楚的是一个视图的&lt;code&gt;frame&lt;/code&gt;和&lt;code&gt;bounds&lt;/code&gt;之间的区别，因为这困扰着很多 iOS 入门开发者。不过这个区别也不复杂。&lt;/p&gt;
&lt;p&gt;在 iOS 和 OS X 中，一个应用有多个坐标系。比如，在 iOS 中应用窗口定位在屏幕的坐标系，而窗口的每一个子视图定位在窗口的坐标系。换句话说，一个视图的子视图总是定位在该视图的坐标系中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Frames&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如文档中说的，视图的&lt;code&gt;frame&lt;/code&gt;是一个结构体，即一个&lt;code&gt;CGRect&lt;/code&gt;,它定义了这个视图的大小和它在父视图中的位置，或者说父视图坐标系中的位置。看看下面的图应该就能明白了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bounds&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视图的&lt;code&gt;bounds&lt;/code&gt;属性定义了这个视图的大小和它在自身坐标系中的位置。这意味着大多数情况下一个视图的 bounds 的原点都是&lt;code&gt;{0,0}&lt;/code&gt;，如下图。视图的&lt;code&gt;bounds&lt;/code&gt;对于绘制这个视图很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当视图的&lt;code&gt;frame&lt;/code&gt;属性被修改时，视图的&lt;code&gt;center&lt;/code&gt;和&lt;code&gt;bounds&lt;/code&gt;属性二者或者其一也同时被改变。&lt;/p&gt;
&lt;h3 id=&quot;CGGeometry-Reference&quot;&gt;&lt;a href=&quot;#CGGeometry-Reference&quot; class=&quot;headerlink&quot; title=&quot;CGGeometry Reference&quot;&gt;&lt;/a&gt;CGGeometry Reference&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;方便的取值方法&lt;/strong&gt;&lt;br&gt;之前提到过，CGGeometry Reference 是一个让运用坐标和矩形更方便的结构体、常量和方法的集合。你可能碰到过类似的下面的代码片段：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPoint point = CGPonitMake(self.view.frame.origin.x + self.view.frame.size.width, self.view.frame.origin.y + self.view.frame.size.height);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样的片段不尽难阅读，而且过于冗长。我们可以用在 CGGeometry Reference 中定义的两个方便的方法重写这段代码。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGRect frame = self.view.frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGPoint point = CGPointMake(CGRectGetMaxX(frame), CGRectGetMaxY(frame));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为了简化之前那段代码，我们把视图的&lt;code&gt;frame&lt;/code&gt;储存到一个叫&lt;code&gt;frame&lt;/code&gt;的变量中，并且使用了&lt;code&gt;CGRectGetMaxX&lt;/code&gt;和&lt;code&gt;CGRectGetMaxY&lt;/code&gt;两个方法。这两个方法的方法名解释了自己的功能。&lt;/p&gt;
&lt;p&gt;CGGeometry Reference 定义了返回一个矩形 x 轴坐标、y 轴坐标最小和最大值以及这个矩形中心坐标的方法。另外两个方便的取之方法是&lt;code&gt;CGRectGetWidth&lt;/code&gt;和&lt;code&gt;CGRectGetHeight&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建结构体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当要创建&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;时，大多数人都用&lt;code&gt;CGPointMake&lt;/code&gt;或者类似的方法。这些方法也被定义在 CGGeometry Reference 中。虽然它们的实现非常简单，它们特别有用并且让你少写一些代码。例如，&lt;code&gt;CGRectMake&lt;/code&gt;是这样实现的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CGRect rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rect.origin.x = x; rect.origin.y = y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rect.size.width = width; rect.size.height = height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改矩形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上提到过的方法都是 iOS 开发者熟知的，它们减少了我们的代码量并且让它们可读性增加。不过，CGGeometry Reference 也定义了一切其他大家不太了解的方法。比如 CGGeometry Reference 定义了一堆修改&lt;code&gt;CGRect&lt;/code&gt;结构的方法。让我们来看看其中一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CGRectUnion&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;&lt;code&gt;CGRectUnion&lt;/code&gt;接受两个&lt;code&gt;CGRect&lt;/code&gt;结构体作为参数并且返回一个能够包含这两个矩形的最小矩形。听起来可能没什么，我相信你也可以用几行代码轻松实现这个功能，不过 CGGeometry 做的是给你提供一些方法让你的代码更干净、可读性更强。&lt;/p&gt;
&lt;p&gt;如果你把下面代码片段加到一个 view controller 的&lt;code&gt;viewDidLoad&lt;/code&gt;方法中，你将在模拟器中看到如下结果。那个灰色的矩形就是使用&lt;code&gt;CGRectUnion&lt;/code&gt;的结果。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// CGRectUnion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect frame1 = CGRectMake(80.0, 100.0, 150.0, 240.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect frame2 = CGRectMake(140.0, 240.0, 120.0, 120.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect frame3 = CGRectUnion(frame1, frame2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *view1 = [[UIView alloc] initWithFrame:frame1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[view1 setBackgroundColor:[UIColor redColor]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *view2 = [[UIView alloc] initWithFrame:frame2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[view2 setBackgroundColor:[UIColor orangeColor]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *view3 = [[UIView alloc] initWithFrame:frame3];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[view3 setBackgroundColor:[UIColor grayColor]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:view3];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:view2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:view1];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;CGRectDivide&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另一个有用的方法是&lt;code&gt;CGRectDivide&lt;/code&gt;，它帮你把一个给定矩形分割成两个。看看下面的代码和截图来了解它是怎么运作的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// CGRectDivide&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect frame = CGRectMake(10.0, 50.0, 300.0, 300.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect part1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect part2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRectDivide(frame, &amp;amp;part1, &amp;amp;part2, 100.0, CGRectMaxYEdge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *view1 = [[UIView alloc] initWithFrame:frame];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[view1 setBackgroundColor:[UIColor grayColor]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *view2 = [[UIView alloc] initWithFrame:part1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[view2 setBackgroundColor:[UIColor orangeColor]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *view3 = [[UIView alloc] initWithFrame:part2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[view3 setBackgroundColor:[UIColor redColor]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:view1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:view2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:view3];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你不使用&lt;code&gt;CGRectDivide&lt;/code&gt;来计算红色和橙色矩形的话，你可能要多谢几十行代码。不信你就试试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较和包含&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用下面六个方法来比较几何结构和检查包含关系非常简单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CGPointEqualToPoint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGSizeEqualToSize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGRectEqualToRect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGRectIntersectsRect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGRectContainsPoint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGRectContainsRect&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CGGeometry Reference 还有一些其他宝贝，比如&lt;code&gt;CGPointCreateDictionaryRepresentation&lt;/code&gt;可以用来将一个 CGPoint 结构体转换为一个 &lt;code&gt;CGDictionaryRef&lt;/code&gt;，&lt;code&gt;CGRectIsEmpty&lt;/code&gt;可以用来检查一个矩形的宽高是否都为零。更多详情请看&lt;a href=&quot;&quot;&gt;《CGGeometry Reference 文档》&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;4-福利：打印日志&quot;&gt;&lt;a href=&quot;#4-福利：打印日志&quot; class=&quot;headerlink&quot; title=&quot;4.福利：打印日志&quot;&gt;&lt;/a&gt;4.福利：打印日志&lt;/h3&gt;&lt;p&gt;在 Xcode 控制台打印日志如果没有一些辅助方法的话很麻烦。幸运的是，UIKit 框架定义了一些让它变得很方便的方法。我天天用它们。看看下面的代码片段来了解它们是如何工作。并没有什么奇特的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CGPoint point = CGPointMake(10.0, 25.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGSize size = CGSizeMake(103.0, 223.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect frame = CGRectMake(point.x, point.y, size.width, size.height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;\n%@\n%@\n%@&amp;quot;, NSStringFromCGPoint(point), NSStringFromCGSize(size), NSStringFromCGRect(frame));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;还有一些方便打印仿射变换（affine transforms）（&lt;code&gt;NSStringFromCGAffineTransform&lt;/code&gt;）、边缘插入（&lt;code&gt;NSStringFromUIEdgeInsets&lt;/code&gt;）、偏移（&lt;code&gt;NSStringFromUIOffset&lt;/code&gt;）等的日志的方便方法。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;iOS SDK 包含了大量开发者们不了解的宝贝。我希望我给你们讲明白了 CGGeometry Reference 的实用性。一旦你开始使用它的那些方法，你就会开始问自己，以前没用它怎么活过来的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://code.tutsplus.com/tutorials/ios-fundamentals-frames-bounds-and-cggeometry--cms-21196&quot;&gt;《iOS Fundamentals: Frames, Bounds, and CGGeometry》&lt;/a&gt;&lt;br&gt;程康，2016 年 3 月 26 日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你习惯支持点语法的语言，要搞清楚&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;并不难。不过编程式定位视图或者编写绘图代码一般都很长，因此变得很难读明白。&lt;/p&gt;
&lt;p&gt;在这个教程里，我希望能澄清一些对 frames 和 bounds 的误解，并且介绍一下&lt;strong&gt;CGGeometry&lt;/strong&gt;，它是一个结构体、常量和功能的集合，能让你更轻松地运用&lt;code&gt;CGPoint&lt;/code&gt;，&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-数据类型&quot;&gt;&lt;a href=&quot;#1-数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.数据类型&quot;&gt;&lt;/a&gt;1.数据类型&lt;/h3&gt;&lt;p&gt;如果你刚开始接触 iOS 或者 OS X 开发，你可能会想&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;到底是什么。CGGeometry Reference 定义了一系列几何图元（geometric primitives）或者说结构，我们现在关注的是其中的&lt;code&gt;CGPoint&lt;/code&gt;、&lt;code&gt;CGSize&lt;/code&gt;和&lt;code&gt;CGRect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大多数人应该知道，&lt;code&gt;CGPoint&lt;/code&gt;是定义了坐标系中一个点的 C 结构体。这个坐标系的原点在 iOS 的左上方以及 OS X 的左下方。换句话说，纵轴方向在 iOS 和 OS X 上不一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CGSize&lt;/code&gt;是另一个简单的 C 结构体，它定义了一个宽度值（width）和高度值（height）。&lt;code&gt;CGRect&lt;/code&gt;包含一个&lt;code&gt;origin&lt;/code&gt;（原点）字段、一个&lt;code&gt;CGPoint&lt;/code&gt;和一个&lt;code&gt;size&lt;/code&gt;（大小）字段，即一个&lt;code&gt;CGSize&lt;/code&gt;。&lt;code&gt;origin&lt;/code&gt;（原点）和&lt;code&gt;size&lt;/code&gt;（大小）字段一起决定了一个矩形的位置和大小。&lt;/p&gt;
&lt;p&gt;CGGeometry Reference 也定义了其他类型，例如&lt;code&gt;CGFloat&lt;/code&gt;和&lt;code&gt;CGVector&lt;/code&gt;。&lt;code&gt;CGFloat&lt;/code&gt;就是一个&lt;code&gt;float&lt;/code&gt;（单精度浮点型）或者&lt;code&gt;double&lt;/code&gt;(双精度浮点型)的&lt;code&gt;typedef&lt;/code&gt;（类型重定义），是哪一种取决于应用运行的机器结构是 32 位还是 64 位。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="CGGeometry" scheme="http://cheng-kang.github.io/tags/CGGeometry/"/>
    
      <category term="frame" scheme="http://cheng-kang.github.io/tags/frame/"/>
    
      <category term="bounds" scheme="http://cheng-kang.github.io/tags/bounds/"/>
    
  </entry>
  
  <entry>
    <title>AutoLayout：constraint priority 约束优先级（九宫格续，一个更优方案）</title>
    <link href="http://cheng-kang.github.io/2016/03/20/AutoLayout%EF%BC%9Aconstraint%20priority%20%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%BB%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9B%B4%E4%BC%98%E6%96%B9%E6%A1%88%EF%BC%89/"/>
    <id>http://cheng-kang.github.io/2016/03/20/AutoLayout：constraint priority 约束优先级（九宫格续，一个更优方案）/</id>
    <published>2016-03-20T14:49:31.000Z</published>
    <updated>2016-03-21T03:18:07.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;这两个项目的源码均在我的 github，如有需要直接下载下来试一试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Weibo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;模仿微博客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Dynamic%20Table%20View%20Test&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自适应高度测试用项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前因为觉得麻烦，没有在那个项目里面尝试把九宫格图片分别作为九个&lt;code&gt;UIImageView&lt;/code&gt;来处理（而非一个&lt;code&gt;StackView&lt;/code&gt;）。这次我新建了一个项目，来尝试这种情况。&lt;/p&gt;
&lt;p&gt;依然是九宫格格子长宽 75px/75px，单张大图长宽 200px/200px。&lt;/p&gt;
&lt;p&gt;效果如下图。用了一些不同的颜色让各个 view 更明显。因为我用的图片背景都是白色，所以我把单张大图右移了一些以示区分。右边那一块白色就是单张大图。（上下两块区域的文字位置没调好，但这不是重点：D）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-20%20at%208.33.20%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;相同的高度？&quot;&gt;&lt;a href=&quot;#相同的高度？&quot; class=&quot;headerlink&quot; title=&quot;相同的高度？&quot;&gt;&lt;/a&gt;相同的高度？&lt;/h3&gt;&lt;p&gt;一看图就能发现，单张大图和九宫格是一样高的。&lt;/p&gt;
&lt;p&gt;我用&lt;code&gt;print(onePic.frame.height)&lt;/code&gt;单张大图高度打印下来看，结果是 200.0。没有问题。&lt;/p&gt;
&lt;p&gt;难道是九宫格变小了？&lt;code&gt;print(firstImg.frame.height)&lt;/code&gt;结果是 75.0。也没问题。&lt;/p&gt;
&lt;p&gt;打印没成功，于是我测量了一下截图中九宫格和单张大图的高度，结果两者都是 233px。&lt;strong&gt;这说明单张大图被拉伸了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我突然想起&lt;code&gt;print(onePic.image.size.height)&lt;/code&gt;，打印出来结果是 233.0。图片果然被拉伸了。&lt;/p&gt;
&lt;p&gt;之后我又检查了一下上次的截图，发现上次的单张大图一样被拉伸到九宫格的高度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这次的模拟是重现上次的解决方案，只是将&lt;code&gt;StackView&lt;/code&gt;换成了 9 个独立的&lt;code&gt;UIImageView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还是保持了底部的 button panel 与 onePic 和九宫格的间距都是 8px。（这次因为是分离的九个&lt;code&gt;UIImageView&lt;/code&gt;，所以设置的是 button panel 和第九章图片的距离为 8px， ninethPic）&lt;/p&gt;
&lt;p&gt;问题应该就是出在这里。当 button panel 与 onePic 之间存在这个 8px 的约束时，&lt;code&gt;AutoLayout&lt;/code&gt;忽略了设定在 onePic 上固定高宽 200px 的约束，拉伸图片，使它满足和 button panel 的间距为 8px。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为我也是刚接触 AutoLayout 不久，所以不清楚这样的情况是不是在文档里面已经写明了，还是这只是一个实际中发生的情况需要我们以后注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hidden-只是隐身、不可见，不是完全消失&quot;&gt;&lt;a href=&quot;#hidden-只是隐身、不可见，不是完全消失&quot; class=&quot;headerlink&quot; title=&quot;hidden 只是隐身、不可见，不是完全消失&quot;&gt;&lt;/a&gt;hidden 只是隐身、不可见，不是完全消失&lt;/h3&gt;&lt;p&gt;上一篇文章最后一部分是：九宫格图片数量变化时手动适应高度。&lt;/p&gt;
&lt;p&gt;当时觉得是因为我用的&lt;code&gt;StackView&lt;/code&gt;才导致隐藏下两排格子之后整个 view 的高度没有改变。现在我觉得我错了。&lt;/p&gt;
&lt;p&gt;真正的原因应该是，&lt;strong&gt;hidden 只是隐身、不可见，不是完全消失&lt;/strong&gt;。这意味着，虽然设置了图片为&lt;code&gt;hidden&lt;/code&gt;，但其实它还是在那里占位的。所以整个 cell 里面的各种约束、子视图间的相对位置不会改变。&lt;/p&gt;
&lt;p&gt;那怎么让九宫格的高度在格子隐藏之后变小，使得底下的 button panel 可以向上自适应呢？&lt;/p&gt;
&lt;p&gt;第一个办法是上一篇文章中提到的通过修改&lt;code&gt;constraint.constant&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另一个办法我们下面来说。&lt;/p&gt;
&lt;h3 id=&quot;constraint-priority&quot;&gt;&lt;a href=&quot;#constraint-priority&quot; class=&quot;headerlink&quot; title=&quot;constraint priority&quot;&gt;&lt;/a&gt;constraint priority&lt;/h3&gt;&lt;p&gt;为了让隐藏的 view 彻底消失，我赶紧 google 一下。&lt;/p&gt;
&lt;p&gt;在这个问题（&lt;a href=&quot;http://stackoverflow.com/questions/19561269/autolayout-with-hidden-uiviews&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《AutoLayout with hidden UIViews?》&lt;/a&gt;）的回答中找到了有趣的 constraint priority。&lt;/p&gt;
&lt;p&gt;被采纳的答案用的是提到过的第一个办法。&lt;/p&gt;
&lt;p&gt;得票第二的回答提到了另一种办法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The solution of using a constant 0 when hidden and another constant if you show it again is functional, but it is unsatisfying if your content has a flexible size. You’d need to measure your flexible content and set a constant back. This feels wrong, and has issues if content changes size because of server or UI events.&lt;br&gt;I have a better solution.&lt;br&gt;The idea is to set the a 0 height rule to have high priority when we hide the element so that it takes up no autolayout space.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他提到如果你的内容大小是可变化的，那么修改&lt;code&gt;constraints.constant&lt;/code&gt;会很麻烦。这一点我很赞同。&lt;/p&gt;
&lt;p&gt;而更好的办法就是设置 &lt;strong&gt;constraint priority&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/#//apple_ref/occ/instp/NSLayoutConstraint/priority&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSLayoutConstraint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutConstraint_Class/#//apple_ref/c/econst/UILayoutPriorityRequired&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UILayoutPriorityRequired&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，你可以给约束设置优先级，它的值在 0 - 1000 之间，优先极高的会先被满足。&lt;/p&gt;
&lt;p&gt;比如拿我现在这个例子来说，现在有 button panel - onePic 和 button panel - ninethPic 两个 8px 间距的约束，分别对应的&lt;code&gt;IBOutlet&lt;/code&gt;是&lt;code&gt;bpAndOnePic&lt;/code&gt;以及&lt;code&gt;bpAndNinethPic&lt;/code&gt;。假如我们如下设置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bpAndOnePic.priority = 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bpAndNinethPic.priority = 250&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么&lt;code&gt;AutoLayout&lt;/code&gt;会优先满足 button panel 和 onePic 之间的约束，效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-20%20at%2010.10.32%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到 button panel 跑到上面去了。单张大图大小正常了。&lt;/p&gt;
&lt;h3 id=&quot;实现自动向上适应&quot;&gt;&lt;a href=&quot;#实现自动向上适应&quot; class=&quot;headerlink&quot; title=&quot;实现自动向上适应&quot;&gt;&lt;/a&gt;实现自动向上适应&lt;/h3&gt;&lt;p&gt;九宫格的九张图片对应的&lt;code&gt;IBOutlet&lt;/code&gt;分别为 firstPic、secondPic、thirdPic、fourthPic…ninethPic；单张大图为 onePic；底部 button panel 为 buttonPanel。&lt;/p&gt;
&lt;p&gt;添加 buttonPanel 分别和 onePic、firstPic、fourthPic 以及 seventhPic 之间的 8px 上边距约束。&lt;/p&gt;
&lt;p&gt;bpAndOnePic 是 button panel 和单张大图之间的约束；bpAndFirstPic 是 button panel 和九宫格第一张图之间的约束，bpAndFourthPic.priority 和 bpAndSeventhPic.priority 与之类似。（因为是九宫格，所以高度由每排第一张图存不存在决定。）&lt;/p&gt;
&lt;p&gt;有了 constraint priority，我们可以这样设置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bpAndOnePic.priority = firstPic.hidden ? 1000 : 250&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bpAndFirstPic.priority = fourthPic.hidden &amp;amp;&amp;amp; seventhPic.hidden &amp;amp;&amp;amp; !firstPic.hidden ? 1000 : 250&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bpAndFourthPic.priority = !fourthPic.hidden &amp;amp;&amp;amp; seventhPic.hidden ? 1000 : 250&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bpAndSeventhPic.priority = !seventhPic.hidden ? 1000 : 250&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;情况分析&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果九宫格第一排第一张图片隐藏了，说明现在是在展示单张大图（微博没有附加图片的情况我们在这里不考虑）。这时&lt;code&gt;bpAndOnePic.priority&lt;/code&gt;等于 1000，而&lt;code&gt;bpAndSeventhPic.priority&lt;/code&gt;，&lt;code&gt;bpAndFourthPic.priority&lt;/code&gt;，&lt;code&gt;bpAndFirstPic.priority&lt;/code&gt;都等于 250。&lt;code&gt;bpAndOnePic.priority&lt;/code&gt;优先级最高，所以如下图：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-20%20at%2010.33.17%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;如果只有第三排的三张图片隐藏，那么&lt;code&gt;bpAndOnePic.priority&lt;/code&gt;、&lt;code&gt;bpAndSeventhPic.priority&lt;/code&gt;和&lt;code&gt;bpAndFirstPic.priority&lt;/code&gt;等于 250，而&lt;code&gt;bpAndFourthPic.priority&lt;/code&gt;等于 1000。&lt;code&gt;bpAndFourthPic.priority&lt;/code&gt;优先级最高，如下图：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-20%20at%2010.33.47%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他情况在此不一一列举。&lt;/p&gt;
&lt;p&gt;这样既解决了单张大图被拉伸的问题，又实现了九宫格图片数量变化时候的向上适应。&lt;/p&gt;
&lt;h3 id=&quot;待解决：多余的空白部分怎么办？&quot;&gt;&lt;a href=&quot;#待解决：多余的空白部分怎么办？&quot; class=&quot;headerlink&quot; title=&quot;待解决：多余的空白部分怎么办？&quot;&gt;&lt;/a&gt;待解决：多余的空白部分怎么办？&lt;/h3&gt;&lt;p&gt;可以从上面的截图上看到，当内容变化的时候，cell 的高度并没有变化，所以下方有空白。&lt;/p&gt;
&lt;p&gt;之前模仿微博客户端的项目中，我用了：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; CGFloat &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return UITableViewAutomaticDimension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; CGFloat &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return UITableViewAutomaticDimension&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;它帮我自动去除了空白部分。&lt;/p&gt;
&lt;p&gt;我尝试加上这两个函数在这个项目中，结果是：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-20%20at%2010.42.02%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以下一步我会去搞清楚这个自动计算重新设置高度具体是怎么回事，解决掉多余的空白部分。&lt;br&gt;（另外，我感觉这跟我之前的项目 cell 里包含了 textField 有关 = =）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为很丑的例子 ui 道歉 = =&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两个项目的源码均在我的 github，如有需要直接下载下来试一试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Weibo&quot;&gt;模仿微博客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cheng-kang/iosDev/tree/master/Dynamic%20Table%20View%20Test&quot;&gt;自适应高度测试用项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前因为觉得麻烦，没有在那个项目里面尝试把九宫格图片分别作为九个&lt;code&gt;UIImageView&lt;/code&gt;来处理（而非一个&lt;code&gt;StackView&lt;/code&gt;）。这次我新建了一个项目，来尝试这种情况。&lt;/p&gt;
&lt;p&gt;依然是九宫格格子长宽 75px/75px，单张大图长宽 200px/200px。&lt;/p&gt;
&lt;p&gt;效果如下图。用了一些不同的颜色让各个 view 更明显。因为我用的图片背景都是白色，所以我把单张大图右移了一些以示区分。右边那一块白色就是单张大图。（上下两块区域的文字位置没调好，但这不是重点：D）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-20%20at%208.33.20%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://cheng-kang.github.io/tags/AutoLayout/"/>
    
      <category term="constraint priority" scheme="http://cheng-kang.github.io/tags/constraint-priority/"/>
    
  </entry>
  
  <entry>
    <title>AutoLayout：UITableViewCell 自适应高度的一个例子</title>
    <link href="http://cheng-kang.github.io/2016/03/19/AutoLayout%EF%BC%9AUITableViewCell%20%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://cheng-kang.github.io/2016/03/19/AutoLayout：UITableViewCell 自适应高度的一个例子/</id>
    <published>2016-03-19T15:51:24.000Z</published>
    <updated>2016-03-21T03:19:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;我在模拟微博客户端。&lt;/p&gt;
&lt;p&gt;要实现：&lt;br&gt;当一条微博包含 2-9 张图的时候，图片以九宫格形式展示（去除空白格子）。&lt;br&gt;当一条微博只包含一张图的时候，图片会比较大。&lt;/p&gt;
&lt;h3 id=&quot;AutoLayout：实现-一张大图-和-九宫格-的样式&quot;&gt;&lt;a href=&quot;#AutoLayout：实现-一张大图-和-九宫格-的样式&quot; class=&quot;headerlink&quot; title=&quot;AutoLayout：实现 一张大图 和 九宫格 的样式&quot;&gt;&lt;/a&gt;AutoLayout：实现 一张大图 和 九宫格 的样式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2010.55.31%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，九宫格图片为&lt;code&gt;Nine Pics&lt;/code&gt;，底部按钮为&lt;code&gt;3-button-panel&lt;/code&gt;（这个命名很奇怪我知道：D），单张大图为&lt;code&gt;One Pic&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;九宫格每张图的大小是 75px/75px，上下左右有 4px 的间距，所以总长宽为 233px/233px。&lt;/p&gt;
&lt;p&gt;单张大图的长宽为 200px/200px。&lt;/p&gt;
&lt;p&gt;先不管单张大图的&lt;code&gt;UIImageView&lt;/code&gt;，将 view 里面其他元素通过 AutoLayout 设置好。九宫格的九张图片因为排布整齐，所以我直接用的一个 &lt;strong&gt;stackview&lt;/strong&gt;。&lt;br&gt;设置&lt;code&gt;Nine Pics&lt;/code&gt;和&lt;code&gt;3-button-panel&lt;/code&gt;的间距为 8px。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;然后调整&lt;code&gt;One Pic&lt;/code&gt;大小为合适大小，用 Constrains 束缚住。通过键盘把&lt;code&gt;One Pic&lt;/code&gt;移动到和&lt;code&gt;Nine Pics&lt;/code&gt;左上角对齐的位置。（移动位置为了看起来更直观。所有的约束不是由在&lt;code&gt;storyboard&lt;/code&gt;上显示的位置决定的。）&lt;br&gt;将&lt;code&gt;One Pic&lt;/code&gt;左、上设置成和&lt;code&gt;Nice Pics&lt;/code&gt;一样的约束：左边 8px，上面 8px。&lt;/p&gt;
&lt;p&gt;这个时候因为单张大图的高比九宫格的高小，所以看上去&lt;code&gt;One Pic&lt;/code&gt;和&lt;code&gt;3-button-panel&lt;/code&gt;的间距一定是大于 8px。&lt;/p&gt;
&lt;p&gt;但是约束的神奇就是这样。&lt;/p&gt;
&lt;p&gt;我们现在设置&lt;code&gt;One Pic&lt;/code&gt;和&lt;code&gt;3-button-panel&lt;/code&gt;的间距为 8px。&lt;/p&gt;
&lt;p&gt;这个时候，在&lt;code&gt;3-button-panel&lt;/code&gt;上就有两个上方的约束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2011.29.17%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当我们要显示单张大图的时候，通过代码隐藏九宫格&lt;code&gt;self.ninePicsView.hidden = true&lt;/code&gt;。此时，&lt;code&gt;AutoLayout&lt;/code&gt;就会忽略&lt;code&gt;3-button-panel&lt;/code&gt;和&lt;code&gt;Nine Pics&lt;/code&gt;之间的约束，而&lt;code&gt;3-button-panel&lt;/code&gt;和&lt;code&gt;One Pic&lt;/code&gt;之间的约束正常。&lt;/p&gt;
&lt;p&gt;如图：&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2010.54.30%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;九宫格图片数量变化时手动适应高度&quot;&gt;&lt;a href=&quot;#九宫格图片数量变化时手动适应高度&quot; class=&quot;headerlink&quot; title=&quot;九宫格图片数量变化时手动适应高度&quot;&gt;&lt;/a&gt;九宫格图片数量变化时手动适应高度&lt;/h3&gt;&lt;p&gt;九宫格图片数量不够时，当然是通过&lt;code&gt;hidden=true&lt;/code&gt;隐藏多余的格子。&lt;/p&gt;
&lt;p&gt;但是可能是由于我用的&lt;strong&gt;stackview&lt;/strong&gt;，所以隐藏第三排或者第二排和第三排之后，整个 view 的高度并没有改变。（我没有尝试不用 stackview的情况，因为不想破坏辛辛苦苦做好的 storyboard ：D。等有时间我再新建一个项目试试。）&lt;/p&gt;
&lt;p&gt;所以需要手动改一下。&lt;/p&gt;
&lt;p&gt;方法是，建立一个 Constraint Outlet，根据情况修改它的值。&lt;/p&gt;
&lt;p&gt;之前我们设置了&lt;code&gt;3-button-panel&lt;/code&gt;和&lt;code&gt;Nine Pics&lt;/code&gt;之间的距离是 8px。我们建立一个这样的 IBOutlet：&lt;code&gt;@IBOutlet weak var constraintButtonPanelAndNinePic: NSLayoutConstraint!&lt;/code&gt;。这个时候，我们就可以通过代码来修改约束值。&lt;/p&gt;
&lt;p&gt;比如当有 6 张图片时，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.seventhPic.hidden = true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.eighthPic.hidden = true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.ninethPic.hidden = true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;隐藏多余的格子，然后&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.constraintButtonPanelAndNinePic.constant = -75&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个时候，&lt;code&gt;3-button-panel&lt;/code&gt;和&lt;code&gt;Nine Pics&lt;/code&gt;的相对位置就正确了。&lt;/p&gt;
&lt;h3 id=&quot;成果&quot;&gt;&lt;a href=&quot;#成果&quot; class=&quot;headerlink&quot; title=&quot;成果&quot;&gt;&lt;/a&gt;成果&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2010.54.30%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2010.54.16%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2011.49.07%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;我在模拟微博客户端。&lt;/p&gt;
&lt;p&gt;要实现：&lt;br&gt;当一条微博包含 2-9 张图的时候，图片以九宫格形式展示（去除空白格子）。&lt;br&gt;当一条微博只包含一张图的时候，图片会比较大。&lt;/p&gt;
&lt;h3 id=&quot;AutoLayout：实现-一张大图-和-九宫格-的样式&quot;&gt;&lt;a href=&quot;#AutoLayout：实现-一张大图-和-九宫格-的样式&quot; class=&quot;headerlink&quot; title=&quot;AutoLayout：实现 一张大图 和 九宫格 的样式&quot;&gt;&lt;/a&gt;AutoLayout：实现 一张大图 和 九宫格 的样式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%2010.55.31%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，九宫格图片为&lt;code&gt;Nine Pics&lt;/code&gt;，底部按钮为&lt;code&gt;3-button-panel&lt;/code&gt;（这个命名很奇怪我知道：D），单张大图为&lt;code&gt;One Pic&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;九宫格每张图的大小是 75px/75px，上下左右有 4px 的间距，所以总长宽为 233px/233px。&lt;/p&gt;
&lt;p&gt;单张大图的长宽为 200px/200px。&lt;/p&gt;
&lt;p&gt;先不管单张大图的&lt;code&gt;UIImageView&lt;/code&gt;，将 view 里面其他元素通过 AutoLayout 设置好。九宫格的九张图片因为排布整齐，所以我直接用的一个 &lt;strong&gt;stackview&lt;/strong&gt;。&lt;br&gt;设置&lt;code&gt;Nine Pics&lt;/code&gt;和&lt;code&gt;3-button-panel&lt;/code&gt;的间距为 8px。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://cheng-kang.github.io/tags/AutoLayout/"/>
    
      <category term="九宫格" scheme="http://cheng-kang.github.io/tags/%E4%B9%9D%E5%AE%AB%E6%A0%BC/"/>
    
      <category term="自适应高度" scheme="http://cheng-kang.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>UISearchBar（一）修改背景层和输入框层的背景颜色和边框颜色</title>
    <link href="http://cheng-kang.github.io/2016/03/19/UISearchBar%EF%BC%88%E4%B8%80%EF%BC%89%E4%BF%AE%E6%94%B9%E8%83%8C%E6%99%AF%E5%B1%82%E5%92%8C%E8%BE%93%E5%85%A5%E6%A1%86%E5%B1%82%E7%9A%84%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2%E5%92%8C%E8%BE%B9%E6%A1%86%E9%A2%9C%E8%89%B2/"/>
    <id>http://cheng-kang.github.io/2016/03/19/UISearchBar（一）修改背景层和输入框层的背景颜色和边框颜色/</id>
    <published>2016-03-19T12:51:09.000Z</published>
    <updated>2016-03-21T03:21:32.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在模仿微博 iOS 客户端的时候，希望将首页上方的搜索框做成和它一样的&lt;strong&gt;整体浅灰色背景+输入框白色背景&lt;/strong&gt;，发现直接使用&lt;code&gt;IBOutlet&lt;/code&gt;建立连接修改&lt;code&gt;bordercolor&lt;/code&gt;或者&lt;code&gt;borderwidth&lt;/code&gt;没有用。所以研究了一下如何修改&lt;code&gt;UIsearchBar&lt;/code&gt;相关的颜色。&lt;/p&gt;
&lt;p&gt;另外：发现原来微博客户端首页上面的 search bar 大概就是一个图片按钮【白眼】。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为微博客户端首页上面的 search bar 高度很小，自己尝试修改没成功，于是 google 了一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/30858969/can-the-height-of-the-uisearchbar-textfield-be-modified&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《StackOverflow: Can the height of the UISearchbar TextField be modified?》&lt;/a&gt; 中提到一种方案：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewDidAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidAppear(animated)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for subView in searchBar.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(subView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for subsubView in subView.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(subsubView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if let textField = subsubView as? UITextField &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;								textField.font = UIFont.systemFontOfSize(20)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把这个函数放在&lt;code&gt;viewDidAppear&lt;/code&gt;会不会有点问题？是不是放在&lt;code&gt;viewWillAppear&lt;/code&gt;比较好？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;才发现 search bar 的结构很复杂。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;我加了两行打印，把子视图简单地打印出来。得到的结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;UIView: 0x7fb6204a09c0; frame = (390 0; 195 25); autoresize = RM+BM; gestureRecognizers = &amp;lt;NSArray: 0x7fb622479cf0&amp;gt;; layer = &amp;lt;CALayer: 0x7fb6204806e0&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;UIView: 0x7fb622122760; frame = (0 0; 320 44); clipsToBounds = YES; autoresize = W+H; layer = &amp;lt;CALayer: 0x7fb622120180&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;UISearchBarBackground: 0x7fb622123340; frame = (0 0; 320 44); opaque = NO; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x7fb622123800&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;UISearchBarTextField: 0x7fb622124bf0; frame = (8 8; 304 28); text = &amp;apos;&amp;apos;; clipsToBounds = YES; opaque = NO; layer = &amp;lt;CALayer: 0x7fb622120290&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不去深究，简而言之，在它的第二层子视图(subview)中至少包含了一个&lt;code&gt;UIView&lt;/code&gt;和一个&lt;code&gt;UiTextField&lt;/code&gt;，分别是 search bar 的背景视图和文本输入框。&lt;/p&gt;
&lt;p&gt;Search bar 的样式就是它们定义的。所以我们对它们进行修改就能达到目的。&lt;/p&gt;
&lt;h3 id=&quot;试验&quot;&gt;&lt;a href=&quot;#试验&quot; class=&quot;headerlink&quot; title=&quot;试验&quot;&gt;&lt;/a&gt;试验&lt;/h3&gt;&lt;p&gt;假设： @IBOutlet weak var searchBar: UISearchBar!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;searchBar.tintColor: 设置输入框光标颜色&lt;/li&gt;
&lt;li&gt;searchBar.barTintColor: 设置外层背景颜色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我通过下面的代码，试着给各种背景、边框设置不同颜色，得到的效果如图。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewWillAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for subView in searchBar.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for subsubView in subView.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if let bg = subsubView as? UIView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.backgroundColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.layer.backgroundColor = UIColor.orangeColor().CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.layer.borderColor = UIColor.redColor().CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.layer.borderWidth = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if let textField = subsubView as? UITextField &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                textField.backgroundColor = UIColor.blueColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                textField.layer.borderColor = UIColor.greenColor().CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                textField.layer.borderWidth = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchBar.barTintColor = UIColor.yellowColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchBar.tintColor = UIColor.blackColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%207.57.34%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以看到，红色、蓝色、绿色、黑色和黄色产生了效果。&lt;/p&gt;
&lt;h3 id=&quot;如何使-borderwidth-和-backgroundColor-生效&quot;&gt;&lt;a href=&quot;#如何使-borderwidth-和-backgroundColor-生效&quot; class=&quot;headerlink&quot; title=&quot;如何使 borderwidth 和 backgroundColor 生效&quot;&gt;&lt;/a&gt;如何使 borderwidth 和 backgroundColor 生效&lt;/h3&gt;&lt;p&gt;有一个问题是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须设置&lt;code&gt;borderwidth&lt;/code&gt;，否则自定义的&lt;code&gt;bordercolor&lt;/code&gt;和&lt;code&gt;backgroundColor&lt;/code&gt;都不会生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如注释掉&lt;code&gt;borderwidth&lt;/code&gt;：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewWillAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for subView in searchBar.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for subsubView in subView.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if let bg = subsubView as? UIView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.backgroundColor = UIColor.whiteColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.layer.backgroundColor = UIColor.orangeColor().CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bg.layer.borderColor = UIColor.redColor().CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //bg.layer.borderWidth = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if let textField = subsubView as? UITextField &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                textField.backgroundColor = UIColor.blueColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                textField.layer.borderColor = UIColor.greenColor().CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //textField.layer.borderWidth = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchBar.barTintColor = UIColor.yellowColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    searchBar.tintColor = UIColor.blackColor()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%207.54.24%20PM.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;会发现&lt;strong&gt;红色&lt;/strong&gt;和&lt;strong&gt;绿色&lt;/strong&gt;不见了。&lt;/p&gt;
&lt;h3 id=&quot;背后的-view&quot;&gt;&lt;a href=&quot;#背后的-view&quot; class=&quot;headerlink&quot; title=&quot;背后的 view&quot;&gt;&lt;/a&gt;背后的 view&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;仔细看&lt;/strong&gt;&lt;br&gt;这个时候在文本输入框的角落出现了橙色。&lt;/p&gt;
&lt;p&gt;这说明，searchBar 的子视图中，除了一个作为整体背景的&lt;code&gt;UIView&lt;/code&gt;和文本输入框之外，还有一个和文本输入框相同大小的&lt;code&gt;UIView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以我把文本输入框的背景色设置为&lt;code&gt;clearColor&lt;/code&gt;，然后得到下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%208.10.51%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个 view 具体作用是什么，之后再来和另外几个一起一个一个弄清楚。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;另一个问题：当-searchBarStyle-为-UISearchBarStyle-Minimal-时&quot;&gt;&lt;a href=&quot;#另一个问题：当-searchBarStyle-为-UISearchBarStyle-Minimal-时&quot; class=&quot;headerlink&quot; title=&quot;另一个问题：当 searchBarStyle 为 UISearchBarStyle.Minimal 时&quot;&gt;&lt;/a&gt;另一个问题：当 searchBarStyle 为 UISearchBarStyle.Minimal 时&lt;/h3&gt;&lt;p&gt;&lt;code&gt;searchBarStyle&lt;/code&gt;默认为&lt;code&gt;Prominent&lt;/code&gt;，你可以自己修改为&lt;code&gt;Minimal&lt;/code&gt;，它的样式更简洁。&lt;/p&gt;
&lt;p&gt;但是，当我切换成&lt;code&gt;Minimal&lt;/code&gt;之后，结果变成这样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%208.15.12%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，&lt;code&gt;searchBar.barTintColor = UIColor.yellowColor()&lt;/code&gt;没有生效。&lt;/p&gt;
&lt;p&gt;暂时不知道为什么，我猜是&lt;code&gt;Apple&lt;/code&gt;故意设置的不允许修改。&lt;/p&gt;
&lt;h3 id=&quot;默认的黑色边框&quot;&gt;&lt;a href=&quot;#默认的黑色边框&quot; class=&quot;headerlink&quot; title=&quot;默认的黑色边框&quot;&gt;&lt;/a&gt;默认的黑色边框&lt;/h3&gt;&lt;p&gt;当我把 search bar 背景颜色设置为我想要的浅灰色之后，又一个问题出现了。&lt;/p&gt;
&lt;p&gt;居然有默认的边框。而且我取色看了一下，在背景颜色不同时，边框颜色值还不一样……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%208.45.34%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%208.46.09%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我尝试设置&lt;code&gt;borderwidth&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，可是边框依旧显示。（不信你试试：D ）&lt;/p&gt;
&lt;p&gt;所以我猜这可能是，当 search bar 没有边框的时候自动添加的强制性边框，用于和其他元素区别吧。&lt;/p&gt;
&lt;p&gt;不过刚才已经找到修改边框颜色的方法了。所以用上面的方法修改即可，记得设置&lt;code&gt;borderWidth&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里也有一点要注意：&lt;/p&gt;
&lt;p&gt;因为上面我们并没有把每个&lt;code&gt;UIView&lt;/code&gt;单独拿出来进行操作，而是遍历子视图里的所有&lt;code&gt;UIView&lt;/code&gt;修改边框，这就导致包含的&lt;code&gt;textField&lt;/code&gt;边框也被修改为背景层的边框颜色。假如我们自定义的&lt;code&gt;textField&lt;/code&gt;边框颜色和背景层边框颜色不一样，那么这就不是我们想要的。记得在&lt;code&gt;if let bg = subsubView as? UIView&lt;/code&gt;后面再执行&lt;code&gt;if let textField = subsubView as? UITextField&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewWillAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for subView in searchBar.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(subView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for subsubView in subView.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                print(subsubView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if let bg = subsubView as? UIView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    bg.layer.borderColor = UIColor(red: 242/250, green: 242/250, blue: 242/250, alpha: 1).CGColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    bg.layer.borderWidth = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if let textField = subsubView as? UITextField &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    textField.layer.borderWidth = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        searchBar.barTintColor = UIColor(red: 242/250, green: 242/250, blue: 242/250, alpha: 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后附一张我的截图-D&quot;&gt;&lt;a href=&quot;#最后附一张我的截图-D&quot; class=&quot;headerlink&quot; title=&quot;最后附一张我的截图 : D&quot;&gt;&lt;/a&gt;最后附一张我的截图 : D&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7u2sl0.com1.z0.glb.clouddn.com/ios_Screen%20Shot%202016-03-19%20at%208.27.49%20PM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;如有错误，望指正。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如有更优方案，望赐教。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在模仿微博 iOS 客户端的时候，希望将首页上方的搜索框做成和它一样的&lt;strong&gt;整体浅灰色背景+输入框白色背景&lt;/strong&gt;，发现直接使用&lt;code&gt;IBOutlet&lt;/code&gt;建立连接修改&lt;code&gt;bordercolor&lt;/code&gt;或者&lt;code&gt;borderwidth&lt;/code&gt;没有用。所以研究了一下如何修改&lt;code&gt;UIsearchBar&lt;/code&gt;相关的颜色。&lt;/p&gt;
&lt;p&gt;另外：发现原来微博客户端首页上面的 search bar 大概就是一个图片按钮【白眼】。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为微博客户端首页上面的 search bar 高度很小，自己尝试修改没成功，于是 google 了一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/30858969/can-the-height-of-the-uisearchbar-textfield-be-modified&quot;&gt;《StackOverflow: Can the height of the UISearchbar TextField be modified?》&lt;/a&gt; 中提到一种方案：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override func viewDidAppear(animated: Bool) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidAppear(animated)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for subView in searchBar.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(subView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for subsubView in subView.subviews  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(subsubView)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if let textField = subsubView as? UITextField &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;								textField.font = UIFont.systemFontOfSize(20)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把这个函数放在&lt;code&gt;viewDidAppear&lt;/code&gt;会不会有点问题？是不是放在&lt;code&gt;viewWillAppear&lt;/code&gt;比较好？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;才发现 search bar 的结构很复杂。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://cheng-kang.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://cheng-kang.github.io/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://cheng-kang.github.io/tags/AutoLayout/"/>
    
      <category term="UISearchBar" scheme="http://cheng-kang.github.io/tags/UISearchBar/"/>
    
      <category term="color" scheme="http://cheng-kang.github.io/tags/color/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://cheng-kang.github.io/2016/03/18/hello-world/"/>
    <id>http://cheng-kang.github.io/2016/03/18/hello-world/</id>
    <published>2016-03-18T12:01:11.000Z</published>
    <updated>2016-03-18T12:01:11.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fire Blog 中文说明</title>
    <link href="http://cheng-kang.github.io/2016/03/18/Fire-Blog-%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E/"/>
    <id>http://cheng-kang.github.io/2016/03/18/Fire-Blog-中文说明/</id>
    <published>2016-03-18T04:51:29.000Z</published>
    <updated>2016-03-21T03:22:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Github&lt;/code&gt;提供了&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github Pages&lt;/a&gt;服务，相当于为你提供了服务器空间和还算比较好看的域名（如： &lt;a href=&quot;http://username.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://username.github.io&lt;/a&gt;, &lt;a href=&quot;http://username.github.com），你可以利用它建立一个静态博客。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://username.github.com），你可以利用它建立一个静态博客。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为简单免费而且访问速度快（比我自己的阿里云快多了【翻白眼】），所以越来越多的人使用&lt;code&gt;Github Pages&lt;/code&gt;搭建技术博客。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：也可以绑定自己的域名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个星期之前，自己才通过朋友的博客知道这个好东西。&lt;/p&gt;
&lt;p&gt;官方提供&lt;code&gt;Jekyll&lt;/code&gt;的支持,可以快速搭建不用到数据库的博客。用法是配置好之后，每次将写好的博客&lt;code&gt;markdown&lt;/code&gt;文件上&lt;code&gt;push&lt;/code&gt;到&lt;code&gt;github&lt;/code&gt;里面。&lt;/p&gt;
&lt;p&gt;不过当时也没过多在意，一是我自己有一个放在阿里云上的&lt;code&gt;wordpress&lt;/code&gt;博客，二是觉得每次还要上传文件嫌麻烦。&lt;/p&gt;
&lt;p&gt;直到有一天我在&lt;code&gt;Youtube&lt;/code&gt;上看相声视频的时候给我推送了一个广告（不得不说广告投得蛮准的，很多时候我都把广告看完了，尤其是那个参加空军的广告：）女王，我要当兵），是一个在线数据库服务，叫&lt;code&gt;firebase&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firebase&lt;/code&gt;提供免费的基础服务，可以通过&lt;code&gt;js&lt;/code&gt;进行数据库操作。&lt;/p&gt;
&lt;p&gt;我突然就想起来&lt;code&gt;Github Pages&lt;/code&gt;如果用上这个，不就有数据库了吗。&lt;/p&gt;
&lt;p&gt;于是决定用&lt;code&gt;angularjs&lt;/code&gt;+&lt;code&gt;firebase&lt;/code&gt;写一个博客框架，让不懂代码的朋友到时候只用&lt;code&gt;fork&lt;/code&gt;下项目代码，用自己的&lt;code&gt;github&lt;/code&gt;账号登录就可以创建好自己的博客。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;名字叫&lt;code&gt;Fire Blog&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;1 从&lt;a href=&quot;http://cheng-kang.github.com/fireblog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;项目主页&lt;/a&gt;&lt;code&gt;fork&lt;/code&gt;项目代码&lt;/p&gt;
&lt;p&gt;2 修改&lt;code&gt;fork&lt;/code&gt;下来的项目的项目名称为 &lt;code&gt;username.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3 等待一两分钟，访问刚刚设置的&lt;code&gt;https://username.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4 点击那个隐藏的后台登录入口&lt;/p&gt;
&lt;p&gt;5 使用&lt;code&gt;Github&lt;/code&gt;账号登录&lt;/p&gt;
&lt;p&gt;6 按要求修改配置文件&lt;/p&gt;
&lt;p&gt;7 &lt;code&gt;Tada！&lt;/code&gt;然后你的博客就创建好了！&lt;/p&gt;
&lt;h3 id=&quot;其他的话&quot;&gt;&lt;a href=&quot;#其他的话&quot; class=&quot;headerlink&quot; title=&quot;其他的话&quot;&gt;&lt;/a&gt;其他的话&lt;/h3&gt;&lt;p&gt;我自己还没跟开源项目挂上过勾。&lt;/p&gt;
&lt;p&gt;我想开源项目应该就是能够帮上别人，也希望有人一起来完善。&lt;/p&gt;
&lt;p&gt;这个项目的本意就是这样。&lt;/p&gt;
&lt;p&gt;希望&lt;code&gt;Fire Blog&lt;/code&gt;成为大家的一个选择，也希望其他程序员来添砖加瓦、建议指正。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Github&lt;/code&gt;提供了&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;服务，相当于为你提供了服务器空间和还算比较好看的域名（如： &lt;a href=&quot;http://username.github.io&quot;&gt;http://username.github.io&lt;/a&gt;, &lt;a href=&quot;http://username.github.com），你可以利用它建立一个静态博客。&quot;&gt;http://username.github.com），你可以利用它建立一个静态博客。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为简单免费而且访问速度快（比我自己的阿里云快多了【翻白眼】），所以越来越多的人使用&lt;code&gt;Github Pages&lt;/code&gt;搭建技术博客。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：也可以绑定自己的域名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个星期之前，自己才通过朋友的博客知道这个好东西。&lt;/p&gt;
&lt;p&gt;官方提供&lt;code&gt;Jekyll&lt;/code&gt;的支持,可以快速搭建不用到数据库的博客。用法是配置好之后，每次将写好的博客&lt;code&gt;markdown&lt;/code&gt;文件上&lt;code&gt;push&lt;/code&gt;到&lt;code&gt;github&lt;/code&gt;里面。&lt;/p&gt;
&lt;p&gt;不过当时也没过多在意，一是我自己有一个放在阿里云上的&lt;code&gt;wordpress&lt;/code&gt;博客，二是觉得每次还要上传文件嫌麻烦。&lt;/p&gt;
&lt;p&gt;直到有一天我在&lt;code&gt;Youtube&lt;/code&gt;上看相声视频的时候给我推送了一个广告（不得不说广告投得蛮准的，很多时候我都把广告看完了，尤其是那个参加空军的广告：）女王，我要当兵），是一个在线数据库服务，叫&lt;code&gt;firebase&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firebase&lt;/code&gt;提供免费的基础服务，可以通过&lt;code&gt;js&lt;/code&gt;进行数据库操作。&lt;/p&gt;
&lt;p&gt;我突然就想起来&lt;code&gt;Github Pages&lt;/code&gt;如果用上这个，不就有数据库了吗。&lt;/p&gt;
&lt;p&gt;于是决定用&lt;code&gt;angularjs&lt;/code&gt;+&lt;code&gt;firebase&lt;/code&gt;写一个博客框架，让不懂代码的朋友到时候只用&lt;code&gt;fork&lt;/code&gt;下项目代码，用自己的&lt;code&gt;github&lt;/code&gt;账号登录就可以创建好自己的博客。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://cheng-kang.github.io/categories/Tech/"/>
    
    
      <category term="fireblog" scheme="http://cheng-kang.github.io/tags/fireblog/"/>
    
  </entry>
  
  <entry>
    <title>FireBlog Instruction</title>
    <link href="http://cheng-kang.github.io/2016/03/18/FireBlog-Instruction/"/>
    <id>http://cheng-kang.github.io/2016/03/18/FireBlog-Instruction/</id>
    <published>2016-03-18T04:47:49.000Z</published>
    <updated>2016-03-21T03:22:54.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; offers the wonderful &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github Pages&lt;/a&gt; service. With it, you don’t need to worry about server or domain name(you can have customed domain name like: &lt;a href=&quot;http://username.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://username.github.io&lt;/a&gt;, &lt;a href=&quot;http://username.github.com）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://username.github.com）&lt;/a&gt;. It’s super convenient to set up a static blog based on the service.&lt;/p&gt;
&lt;p&gt;Since it’s easy, free and fast, more and more people start to use this service.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;P.S. You can also use your own domain name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Two weeks ago, I noticed the magic &lt;code&gt;Github Pages&lt;/code&gt; supprisingly.&lt;/p&gt;
&lt;p&gt;There is official support for &lt;code&gt;Jekyll&lt;/code&gt;, by which you could easily set up a blog without database. You need to push the markdown file of your blog to your git repository.&lt;/p&gt;
&lt;p&gt;I didn’t pay much attention to it though. After all I have my own &lt;code&gt;wordpress&lt;/code&gt; blog on Ali Cloud and hate the idea of manually pushing .md files everytime.&lt;/p&gt;
&lt;p&gt;Then one day I was pused a ad about &lt;code&gt;fireblog&lt;/code&gt; when I was watching video on &lt;code&gt;Youtube&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firebase&lt;/code&gt; offers a basic free service, by which you could operate on the database by &lt;code&gt;js&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And it suddenly came to me that I could combine this with &lt;code&gt;Github Pages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So I decided to write a blog framework based on &lt;code&gt;Github Pages&lt;/code&gt;, &lt;code&gt;AngularJS&lt;/code&gt; and &lt;code&gt;firebase&lt;/code&gt;. If I succeed, then people with no idea about programming will be able to set up their own blogs by just &lt;code&gt;forking&lt;/code&gt; the project and logging in with their &lt;code&gt;Github&lt;/code&gt; account.&lt;/p&gt;
&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;It’s named &lt;code&gt;Fire Blog&lt;/code&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;1 &lt;code&gt;fork&lt;/code&gt; the source code from &lt;a href=&quot;http://cheng-kang.github.com/fireblog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;the project home page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2 change the name of the project you’ve &lt;code&gt;forked&lt;/code&gt; to &lt;code&gt;username.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3 drink your coffee and visit &lt;code&gt;https://username.github.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4 click that ‘hidden’ login-page entry button&lt;/p&gt;
&lt;p&gt;5 log in with your &lt;code&gt;Github&lt;/code&gt; account&lt;/p&gt;
&lt;p&gt;6 edit the &lt;code&gt;config.js&lt;/code&gt; file as instructed&lt;/p&gt;
&lt;p&gt;7 &lt;code&gt;Tada！&lt;/code&gt; Here is your blog!&lt;/p&gt;
&lt;h3 id=&quot;From-the-author&quot;&gt;&lt;a href=&quot;#From-the-author&quot; class=&quot;headerlink&quot; title=&quot;From the author&quot;&gt;&lt;/a&gt;From the author&lt;/h3&gt;&lt;p&gt;I myself have never owned an open source project.&lt;/p&gt;
&lt;p&gt;A open source project must be one that helps those who need and gets help from those who are willing to share.&lt;/p&gt;
&lt;p&gt;And this is what I want to achieve with this project.&lt;/p&gt;
&lt;p&gt;I sincerely hope that &lt;code&gt;Fire Blog&lt;/code&gt; is a good choice for you, and that you are happy to refine or correct it.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why&quot;&gt;&lt;/a&gt;Why&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Github&lt;/code&gt; offers the wonderful &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt; service. With it, you don’t need to worry about server or domain name(you can have customed domain name like: &lt;a href=&quot;http://username.github.io&quot;&gt;http://username.github.io&lt;/a&gt;, &lt;a href=&quot;http://username.github.com）&quot;&gt;http://username.github.com）&lt;/a&gt;. It’s super convenient to set up a static blog based on the service.&lt;/p&gt;
&lt;p&gt;Since it’s easy, free and fast, more and more people start to use this service.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;P.S. You can also use your own domain name.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Two weeks ago, I noticed the magic &lt;code&gt;Github Pages&lt;/code&gt; supprisingly.&lt;/p&gt;
&lt;p&gt;There is official support for &lt;code&gt;Jekyll&lt;/code&gt;, by which you could easily set up a blog without database. You need to push the markdown file of your blog to your git repository.&lt;/p&gt;
&lt;p&gt;I didn’t pay much attention to it though. After all I have my own &lt;code&gt;wordpress&lt;/code&gt; blog on Ali Cloud and hate the idea of manually pushing .md files everytime.&lt;/p&gt;
&lt;p&gt;Then one day I was pused a ad about &lt;code&gt;fireblog&lt;/code&gt; when I was watching video on &lt;code&gt;Youtube&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firebase&lt;/code&gt; offers a basic free service, by which you could operate on the database by &lt;code&gt;js&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And it suddenly came to me that I could combine this with &lt;code&gt;Github Pages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So I decided to write a blog framework based on &lt;code&gt;Github Pages&lt;/code&gt;, &lt;code&gt;AngularJS&lt;/code&gt; and &lt;code&gt;firebase&lt;/code&gt;. If I succeed, then people with no idea about programming will be able to set up their own blogs by just &lt;code&gt;forking&lt;/code&gt; the project and logging in with their &lt;code&gt;Github&lt;/code&gt; account.&lt;/p&gt;
&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;It’s named &lt;code&gt;Fire Blog&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://cheng-kang.github.io/categories/Tech/"/>
    
    
      <category term="fireblog" scheme="http://cheng-kang.github.io/tags/fireblog/"/>
    
  </entry>
  
</feed>
