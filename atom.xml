<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHENG KANG</title>
  <subtitle>Hello World Anyway</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chengkang.me/"/>
  <updated>2017-12-27T00:36:13.378Z</updated>
  <id>http://chengkang.me/</id>
  
  <author>
    <name>程康·CHENGKANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to Wildfire</title>
    <link href="http://chengkang.me/2017/12/19/introduction-to-wildfire/"/>
    <id>http://chengkang.me/2017/12/19/introduction-to-wildfire/</id>
    <published>2017-12-19T00:34:07.000Z</published>
    <updated>2017-12-27T00:36:13.378Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><a href="https://www.npmjs.com/wildfire" target="_blank" rel="external"><img src="https://img.shields.io/npm/v/wildfire.svg?style=flat-square" alt=""></a><br></p>

<blockquote>
<p>A drop-in replacement for other comment systems.</p>
</blockquote>
<p><img src="https://cdn.rawgit.com/cheng-kang/wildfire/7d609949/resources/screenshots/home-page.png" alt=""></p>
<p><strong>Please visit the brand new <a href="https://wildfire.js.org" target="_blank" rel="external">Wildfire Home Page</a> (<a href="https://wildfire.js.org" target="_blank" rel="external">https://wildfire.js.org</a>). Detailed documentation is available.</strong></p>
<p><strong>Started using <code>wildfire</code>? Share your website with others: <a href="https://github.com/cheng-kang/wildfire/issues/9" target="_blank" rel="external">We are using Wildfire! </a>!</strong></p>
<p><strong>全新的 <a href="https://wildfire.js.org/#/zh-cn/" target="_blank" rel="external">Wildfire 主页</a> (<a href="https://wildfire.js.org/#/zh-cn/" target="_blank" rel="external">https://wildfire.js.org/#/zh-cn/</a>) 已经启用了，快去那儿看看详细的文档吧。</strong></p>
<p><em>点此查看 <a href="https://github.com/cheng-kang/wildfire/blob/master/README-ZH.md" target="_blank" rel="external">中文版 README.md</a>。</em></p>
<a id="more"></a>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p><code>wildfire</code> aims to be an <strong>it-just-works</strong> comment system for personal websites, like your <code>Hexo</code> blogs. It takes advantage of free real-time databases (<a href="https://firebase.google.com" target="_blank" rel="external">Firebase</a> and <a href="https://wilddog.com" target="_blank" rel="external">Wilddog</a>) to store your comments data, and provide you real-time communicating experience.</p>
<p>Continue reading <a href="https://wildfire.js.org/#/preface" target="_blank" rel="external">Get Started</a>, and start your journey with <code>wildfire</code>!</p>
<blockquote>
<p>If you are using <code>Wildfire</code>, please share your website here: <a href="https://github.com/cheng-kang/wildfire/issues/9" target="_blank" rel="external">We are using Wildfire!</a> :-D.</p>
</blockquote>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p><strong>For site owners:</strong></p>
<ul>
<li>Database Support: <ul>
<li><a href="https://firebase.google.com/" target="_blank" rel="external">Firebase</a></li>
<li><a href="https://www.wilddog.com/" target="_blank" rel="external">Wilddog</a>.</li>
</ul>
</li>
<li>Admin Function: <ul>
<li>Delete comment</li>
<li>Ban users by their IP/email</li>
<li><a href="admin-helpers.md#_1-reset-discussion-count-for-all-pages">Reset discussion count of all pages</a></li>
<li><a href="get-discussion-count.md">Get discussion count</a></li>
</ul>
</li>
</ul>
<p><strong>For all visitors (anonymous &amp; authorized):</strong></p>
<ul>
<li>Comment (with <code>Markdown</code> support)</li>
<li>Mention (@username)</li>
</ul>
<p><strong>For authorized visitors:</strong></p>
<ul>
<li>Like/dislike a comment</li>
<li>Delete own comments</li>
<li>Report inappropriate comments</li>
<li>Update user profile<ul>
<li>Display name</li>
<li>Avatar</li>
</ul>
</li>
<li>Personal Center:<ul>
<li>Notification</li>
</ul>
</li>
</ul>
<h2 id="Showcase"><a href="#Showcase" class="headerlink" title="Showcase"></a>Showcase</h2><p>A live <code>wildfire</code> is at the bottom of this page.</p>
<p>For more showcases, check this Wiki page: <a href="https://github.com/cheng-kang/wildfire/wiki/1.-%E8%BF%99%E4%BA%9B%E7%BD%91%E7%AB%99%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8-Wildfire-%E9%87%8E%E7%81%AB%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%81" target="_blank" rel="external">Who is using Wildfire?</a>.</p>
<h2 id="Donation"><a href="#Donation" class="headerlink" title="Donation"></a>Donation</h2><p>Buy us a cup of tea if you think <code>wildfire</code> does work! </p>
<blockquote>
<p>B.t.w., don’t worry, the donation will be shared with <a href="http://maliao.cn" target="_blank" rel="external">@mrliao</a> ;-D.</p>
</blockquote>
<h4 id="Paypal-Me"><a href="#Paypal-Me" class="headerlink" title="- Paypal Me"></a>- Paypal Me</h4><p align="center"><br>  <a href="https://www.paypal.me/chengkang" target="_blank"><img src="https://cdn.rawgit.com/cheng-kang/wildfire/5f5ee7b5/resources/donate/paypal-me.png" width="320"></a><br></p>

<h4 id="Alipay-amp-Wechat"><a href="#Alipay-amp-Wechat" class="headerlink" title="- Alipay &amp; Wechat"></a>- Alipay &amp; Wechat</h4><p align="center"><br>  <img src="https://cdn.rawgit.com/cheng-kang/wildfire/5f5ee7b5/resources/donate/alipay.jpg" width="160"><br>  <img src="https://cdn.rawgit.com/cheng-kang/wildfire/5f5ee7b5/resources/donate/wechat.jpg" width="160"><br> </p>

<p>We appreciate your kindness!</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="https://github.com/cheng-kang/wildfire/blob/master/LICENSE" target="_blank" rel="external">GNU General Public License v3.0</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align=center&gt;&lt;br&gt;&lt;a href=&quot;https://www.npmjs.com/wildfire&quot;&gt;&lt;img src=&quot;https://img.shields.io/npm/v/wildfire.svg?style=flat-square&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A drop-in replacement for other comment systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.rawgit.com/cheng-kang/wildfire/7d609949/resources/screenshots/home-page.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Please visit the brand new &lt;a href=&quot;https://wildfire.js.org&quot;&gt;Wildfire Home Page&lt;/a&gt; (&lt;a href=&quot;https://wildfire.js.org&quot;&gt;https://wildfire.js.org&lt;/a&gt;). Detailed documentation is available.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Started using &lt;code&gt;wildfire&lt;/code&gt;? Share your website with others: &lt;a href=&quot;https://github.com/cheng-kang/wildfire/issues/9&quot;&gt;We are using Wildfire! &lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全新的 &lt;a href=&quot;https://wildfire.js.org/#/zh-cn/&quot;&gt;Wildfire 主页&lt;/a&gt; (&lt;a href=&quot;https://wildfire.js.org/#/zh-cn/&quot;&gt;https://wildfire.js.org/#/zh-cn/&lt;/a&gt;) 已经启用了，快去那儿看看详细的文档吧。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;点此查看 &lt;a href=&quot;https://github.com/cheng-kang/wildfire/blob/master/README-ZH.md&quot;&gt;中文版 README.md&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="wildfire" scheme="http://chengkang.me/tags/wildfire/"/>
    
      <category term="comment system" scheme="http://chengkang.me/tags/comment-system/"/>
    
      <category term="firebase" scheme="http://chengkang.me/tags/firebase/"/>
    
      <category term="wilddog" scheme="http://chengkang.me/tags/wilddog/"/>
    
      <category term="hexo" scheme="http://chengkang.me/tags/hexo/"/>
    
      <category term="vue" scheme="http://chengkang.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Firebase 实时数据库开发最佳实践</title>
    <link href="http://chengkang.me/2017/10/14/best-practice-for-firebase-realtime-datebase-development/"/>
    <id>http://chengkang.me/2017/10/14/best-practice-for-firebase-realtime-datebase-development/</id>
    <published>2017-10-14T07:43:51.000Z</published>
    <updated>2017-10-14T15:44:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://medium.com/@CodeAndBiscuits/best-practices-for-firebase-realtime-database-development-14e8fd133d44" target="_blank" rel="external">Best Practices for Firebase Realtime Database Development</a></p>
<p>此文非全文翻译，一些可以省略的话就省略掉了。</p>
</blockquote>
<h2 id="读文档！"><a href="#读文档！" class="headerlink" title="读文档！"></a>读文档！</h2><p>Firebase 的文档和示例都非常友好易懂。有问题找文档。有空的话请通读全文。</p>
<p>另外还有一个很有用的博客，以下是其中几篇对我们很重要的文章：</p>
<ul>
<li><a href="https://firebase.googleblog.com/2016/10/group-security-in-firebase-database.html" target="_blank" rel="external">Group Security in the Firebase Database</a></li>
<li><a href="https://firebase.googleblog.com/2013/10/queries-part-1-common-sql-queries.html" target="_blank" rel="external">Queries, Part 1: Common SQL Queries Converted for Firebase</a></li>
<li><a href="https://firebase.googleblog.com/2014/04/best-practices-arrays-in-firebase.html" target="_blank" rel="external">Best Practices: Arrays in Firebase</a></li>
</ul>
<h2 id="推论：”无模式”（schema-less）不意味着无脑！"><a href="#推论：”无模式”（schema-less）不意味着无脑！" class="headerlink" title="推论：”无模式”（schema-less）不意味着无脑！"></a>推论：”无模式”（schema-less）不意味着无脑！</h2><p>有一个普遍的误解是面向文档的数据库对于数据结构不重视。恰恰相反，<strong>它们更需要注意数据结构</strong>。</p>
<p>好的规划能让所有的软件组件都有最好的性能，这已经没啥可多说的了。不过在 SQL 数据库中，通常是通过 <code>joining more tables</code>、<code>doing sub-queries</code> 或者 <code>doing bulk data updates</code> 来修复规划中的错误。由于 Firebase 中并不存在这些概念，因此还是花些时间来设计你的数据模型并提前处理好这些问题。你会庆幸自己这么做了的。</p>
<p>还有啊，记得读文档。</p>
<a id="more"></a>
<h2 id="Ref-和简单的查询都很“廉价”"><a href="#Ref-和简单的查询都很“廉价”" class="headerlink" title="Ref 和简单的查询都很“廉价”"></a>Ref 和简单的查询都很“廉价”</h2><p>在 Firebase 中，一个 “ref” 就像一个对数据的指针。你可能本能地就像将其缓存或者用其他方式管理好它们，但是在现有的 Firebase 客户端库中你没必要这么做。它们仅仅就是对数据对象的 URL 引用的包装而已，并且其提供的事件回调每个监听器也只能访问一次。如果你需要在两个不同的地方引用同一个对象，就用两个 ref 去引用。根本没有额外“花销”哦。</p>
<p>数据查询也是一样的。从 SQL 数据库转过来的假货已经习惯了用尽可能少的查询语句来查询更多的对象以减少来回的时间、查询成本。在扁平化数据结构里来说，就是把一些数据复制到多个位置以达到一次请求获取到所有所需数据的目的。</p>
<p>在 Firebase 中，这样就大错特错了。一是基于 key/ref 的查询被非常好地优化过了，并且 Firebase 为其提供了大规模的横向扩展。我们在性能测试中发现，Firebase 在有更多小型数据查询时性能更好。即使是移除一些不必要的查询字段都可以带来可观的性能提升。</p>
<p>Firebase 的大规模横向可扩展性是一个很重要的特性。它不是仅仅“有很好”。它应该作为你 app 设计中的一个重要工具。</p>
<h2 id="避免数组"><a href="#避免数组" class="headerlink" title="避免数组"></a>避免数组</h2><p>Firebase 文档里面已经提到了这个话题。完全正确。请避免它们。</p>
<h2 id="Firebase-没有时间数据类型"><a href="#Firebase-没有时间数据类型" class="headerlink" title="Firebase 没有时间数据类型"></a>Firebase 没有时间数据类型</h2><p>Firebase 没有时间数据类型，并且不支持倒序排序。你可以自己将时间转换成时间戳以数字形式存放，并且将其负数作为排序标识一同存储。利用这个排序标识值可以实现倒序查询。</p>
<h2 id="它并不是万能的"><a href="#它并不是万能的" class="headerlink" title="它并不是万能的"></a>它并不是万能的</h2><p>好好利用 Firebase 的长处。不要用它去解决每一个问题。以下是一些 Firebase 不能做的：</p>
<ul>
<li>作为搜索引擎。它有一些基本的操作比如前缀匹配，但也就这些了。如果你需要全功能的搜索，去用 ELK，Algolia 等等吧。</li>
<li>作为 API 栈。Firebase 的 Cloud Functions 看起来很棒，但它还处于 Beta 时期。如果你的 app 比 to-do list 应用复杂的话，还是规划规划如何做服务器端的可信任代码执行吧。</li>
<li>A reporting engine. You may still want to leverage a relational database when you need to slice/dice/filter/mutate/munge/etc your data.</li>
<li>用于全离线应用。它提供了离线功能，但始终还是需要先连上云。</li>
</ul>
<h2 id="Set-还是-Update"><a href="#Set-还是-Update" class="headerlink" title="Set 还是 Update"></a>Set 还是 Update</h2><p>SET 和 UPDATE 之间存在着巨大的差别。它影响着如果 key 还不存在时会发生什么，特别是在复杂对象里面的 key。请务必留意。</p>
<h2 id="FirebaseUI-超级棒！"><a href="#FirebaseUI-超级棒！" class="headerlink" title="FirebaseUI 超级棒！"></a>FirebaseUI 超级棒！</h2><p>噢，我必须要提到，针对各个平台都有一些 FirebaseUI 同类的项目。它们对于建立一个展示 Firebase 数据集中的对象列表的表格真是好用到爆。</p>
<p>去了解一下 FirebaseUI 吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://medium.com/@CodeAndBiscuits/best-practices-for-firebase-realtime-database-development-14e8fd133d44&quot;&gt;Best Practices for Firebase Realtime Database Development&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此文非全文翻译，一些可以省略的话就省略掉了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;读文档！&quot;&gt;&lt;a href=&quot;#读文档！&quot; class=&quot;headerlink&quot; title=&quot;读文档！&quot;&gt;&lt;/a&gt;读文档！&lt;/h2&gt;&lt;p&gt;Firebase 的文档和示例都非常友好易懂。有问题找文档。有空的话请通读全文。&lt;/p&gt;
&lt;p&gt;另外还有一个很有用的博客，以下是其中几篇对我们很重要的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://firebase.googleblog.com/2016/10/group-security-in-firebase-database.html&quot;&gt;Group Security in the Firebase Database&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://firebase.googleblog.com/2013/10/queries-part-1-common-sql-queries.html&quot;&gt;Queries, Part 1: Common SQL Queries Converted for Firebase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://firebase.googleblog.com/2014/04/best-practices-arrays-in-firebase.html&quot;&gt;Best Practices: Arrays in Firebase&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;推论：”无模式”（schema-less）不意味着无脑！&quot;&gt;&lt;a href=&quot;#推论：”无模式”（schema-less）不意味着无脑！&quot; class=&quot;headerlink&quot; title=&quot;推论：”无模式”（schema-less）不意味着无脑！&quot;&gt;&lt;/a&gt;推论：”无模式”（schema-less）不意味着无脑！&lt;/h2&gt;&lt;p&gt;有一个普遍的误解是面向文档的数据库对于数据结构不重视。恰恰相反，&lt;strong&gt;它们更需要注意数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;好的规划能让所有的软件组件都有最好的性能，这已经没啥可多说的了。不过在 SQL 数据库中，通常是通过 &lt;code&gt;joining more tables&lt;/code&gt;、&lt;code&gt;doing sub-queries&lt;/code&gt; 或者 &lt;code&gt;doing bulk data updates&lt;/code&gt; 来修复规划中的错误。由于 Firebase 中并不存在这些概念，因此还是花些时间来设计你的数据模型并提前处理好这些问题。你会庆幸自己这么做了的。&lt;/p&gt;
&lt;p&gt;还有啊，记得读文档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Firebase" scheme="http://chengkang.me/tags/Firebase/"/>
    
  </entry>
  
  <entry>
    <title>Firebase 安全与规则</title>
    <link href="http://chengkang.me/2017/09/30/firebase-security-rules/"/>
    <id>http://chengkang.me/2017/09/30/firebase-security-rules/</id>
    <published>2017-09-30T20:08:37.000Z</published>
    <updated>2017-09-30T13:09:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://howtofirebase.com/firebase-security-rules-88d94606ce4a" target="_blank" rel="external">Firebase Security &amp; Rules</a></p>
</blockquote>
<p>Firebase 是一个可以从任意建立连接了的客户端访问的云数据库。因为任意客户端都可以连接到任意 Firebase [数据库]，你<strong>必须</strong>制定安全规则来保护你的数据。写不好恰当的安全规则会让你暴露在攻击中。不过别着急！你马上就能学到帮你紧紧锁住你的数据的全部知识了。</p>
<p>保持安全规则简洁。安全规则可能变得过于复杂，并很快变得不受控制如果你的数据结构不够设计充分的话。这篇文章展示了一些“最佳”实践。估计你会讲其略作修改就用到你的生产应用中去……如果你选择采用这些模式，记得仔细想想背后的含义就行。确保在你开始搞事之前，读了整篇文章以及<a href="https://firebase.google.com/docs/database/security/" target="_blank" rel="external">安全规则文档</a>全文。</p>
<a id="more"></a>
<h2 id="安全规则是基于节点的"><a href="#安全规则是基于节点的" class="headerlink" title="安全规则是基于节点的"></a>安全规则是基于节点的</h2><p>安全规则由一个单独的 JSON 对象管理，你可以在你的实时数据库控制台编辑或者使用 Firebase CLI [来编辑]。还有一个额外惊喜，如果你的规则格式错误的话，控制台和 CLI 会给你警告。</p>
<p>规则对象开始是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> &quot;rules&quot;: </span><br><span class="line">  &#123; </span><br><span class="line">    &quot;.read&quot;: false,</span><br><span class="line">    &quot;.write&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 JSON 对象的根节点必须命名为 <code>rules</code>。<code>rules</code> 节点默认不可读写。上面的立即显式地设置了 <code>.read</code> 和 <code>.write</code> 为 <code>false</code>，但是留个空白的规则也会有同样的效果。</p>
<h2 id="级联规则"><a href="#级联规则" class="headerlink" title="级联规则"></a>级联规则</h2><p>Firebase 级联规则是这样的：授予一个父母节点读写权限会同时授予其所有子节点读写权限。</p>
<p>再说一遍。</p>
<p>Firebase 级联规则是这样的：授予一个父母节点读写权限会同时授予其所有子节点读写权限。</p>
<p>这里有个巨大的“坑”，即使是对于有经验的 Firebase 用户来说也是这样。让我们回顾一下为什么 Firebase 这样来处理，以及我们可以如何绕过这个限制。</p>
<p>首先，Firebase 本质上要求这样的一种行为。如果你在 Firebase 里面查询一个节点，你将得到其<em>所有</em>的子节点。Firebase 非常注重性能表现，它不会花时间来在每一个子节点上套用规则并且做出可能的从父母节点移除的动作。那样会大大影响其表现。</p>
<p>第二，你可以通过根据你的权限结构来结构化你的数据以轻易地避免这些级联规则的问题。将你的数据嵌套在这样命名的高级别的节点中，比如 “admin”、“userReadable”、“userWritable” 或者 “userOwned”。将有着类似安全需求的对象分组在高级别节点下会有效地降低你需要维护的安全规则数量。</p>
<p><strong>关于验证规则小窍门：</strong>我们之后会谈到验证规则。验证规则用于阻止用于父母节点写权限的用户写入其子节点。这样的话，当你授予了写权限给 <code>userOwned/preferences/{uid}</code>，你可以编写一条验证规则，比如说 <code>userOwned/preferences/{uid}/isAdmin</code>，这样就可以阻止用户更新 <code>isAdmin</code> 这个子节点。</p>
<p>这种方法会带来一些后果，基本上任何在 <code>userOwned/preferences/{uid}</code> 的 <code>ref.set()</code> 的操作都会失败，因为你不能重写 <code>isAdmin</code> 这个子节点…你需要使用 <code>ref.update()</code> 来单独更新每一个子节点。将 <code>isAdmin</code> 节点移到你的数据结构的其他本就是用户可读不可写的部分会比较轻松。你可以将其命名为 <code>userReadable/preferences/{uid}/isAdmin</code>。</p>
<h2 id="示例数据结构"><a href="#示例数据结构" class="headerlink" title="示例数据结构"></a>示例数据结构</h2><p>我们将使用以下数据结构来继续剩下的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;users&quot;: &#123;</span><br><span class="line">    &quot;kanyesUID&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Kanye West&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;kwest@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;taylorsUID&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Taylor Swift&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;tswift@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;seacrestsUID&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Ryan Seacrest&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;rseacrest@gmail.com&quot;,</span><br><span class="line">      &quot;isAdmin&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;userReadable&quot;: &#123;</span><br><span class="line">    &quot;tweets&quot;: &#123;</span><br><span class="line">      &quot;kanyesUID&quot;: &#123;</span><br><span class="line">        &quot;aPushKey&quot;: &#123;</span><br><span class="line">          &quot;text&quot;: &quot;Imma let you finish, but...&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;bPushKey&quot;: &#123;</span><br><span class="line">          &quot;text&quot;: &quot;Queen B shoulda received this award...&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;retweets&quot;: &#123;</span><br><span class="line">      &quot;taylorsUID&quot;: &#123;</span><br><span class="line">        &quot;cPushKey&quot;: &#123;</span><br><span class="line">          &quot;key&quot;: &quot;aPushKey&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;Imma let you finish, but...&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;dPushKey&quot;: &#123;</span><br><span class="line">          &quot;key&quot;: &quot;bPushKey&quot;,</span><br><span class="line">          &quot;text&quot;: &quot;Queen B shoulda received this award...&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;userWriteable&quot;: &#123;</span><br><span class="line">    &quot;tweetQueue&quot;: &#123;</span><br><span class="line">      &quot;taylorsUID&quot;: &#123;</span><br><span class="line">        &quot;text&quot;: &quot;I 💕 you all like Kanye 💕&apos;s Kanye&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;userOwned&quot;: &#123;</span><br><span class="line">    &quot;preferences&quot;: &#123;</span><br><span class="line">      &quot;kanyesUID&quot;: &#123;</span><br><span class="line">        &quot;loveKanye&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;taylorsUID&quot;: &#123;</span><br><span class="line">        &quot;listenToHaters&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些数据有四个顶级节点：</p>
<ol>
<li>users</li>
<li>userReadable</li>
<li>userWriteable</li>
<li>userOwned</li>
</ol>
<p>我们有两个用户：</p>
<ol>
<li>Kanye West</li>
<li>Taylor Swift</li>
</ol>
<p><code>users</code> 节点包含了基础的用户数据，在这个例子中就是邮箱地址。我们设想当 Kanye 登陆了我们的 app，他的 uid 是 <code>kanyesUID</code>。类似的，Taylor 得到了这个 uid <code>taylorsUID</code>。这些 UID 会组成我们安全模型的基础。</p>
<p>首先，来让每个用户数据<code>用户可读</code>…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;users&quot;: &#123;</span><br><span class="line">      &quot;$uid&quot;: &#123;</span><br><span class="line">        &quot;.read&quot;: &quot;auth.uid == $uid&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在根节点 <code>rules</code> 上加了一个 <code>users</code> 节点。任何直接写在 <code>users</code> 节点下面的规则会被应用到所有其子节点中…但是我们并不想在 <code>users</code> 节点上设置规则。我们希望给每一个独立的用户基于其 uid 设置规则，因此我们创建了一个通配节点，<code>$uid</code>。我们可以随意命名通配节点，只要其开始字符是 <code>$</code>。最佳实践是给他们命名一些描述性的东西，因此我们将这个通配节点命名为 <code>$uid</code>，因为每个用户都将保存在其 uid 下。</p>
<p>通配节点应用于所有其他没有明确指出的节点上。有点糊涂了？看看这个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;users&quot;: &#123;</span><br><span class="line">      &quot;$uid&quot;: &#123;</span><br><span class="line">        &quot;.read&quot;: &quot;auth.uid == $uid&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;taylorsUID&quot;: &#123;</span><br><span class="line">        &quot;.read&quot;: &quot;auth.uid == &apos;taylorsUID&apos;&quot;,</span><br><span class="line">        &quot;.write&quot;: &quot;auth.uid == &apos;taylorsUID&apos;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到我们干了啥吗？我们仅赋予了 <code>$uid</code> 节点 <code>.read</code> 权限，但是我们给了 Taylor 这个用户 <code>.read</code> 和 <code>.write</code> 权限。</p>
<p>你可能在想 <code>auth.uid == $uid</code> 是什么意思。当用户通过 Firebase Authentication 认证成功时，这个用户会从系统获得一个 uid，它可以通过 <code>auth.uid</code> 访问到。因此当 Kanye 在系统中认证时，他的 <code>auth.uid</code> 等于 <code>kanyesUID</code>。我们可以将 <code>auth.uid</code> 和 <code>$uid</code> 比较来授予用户对他们自己节点的读权限，但对其他节点无权限。也可以直接和字符串比较：<code>&quot;.read&quot;: &quot;auth.uid == &#39;taylorsUID&#39;&quot;</code>。</p>
<h2 id="索引子键来加快查询"><a href="#索引子键来加快查询" class="headerlink" title="索引子键来加快查询"></a>索引子键来加快查询</h2><p>设想我们的 app 在进行这样一个查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref.child(&apos;users&apos;).orderByChild(&apos;email&apos;).equalTo(&apos;kwest@gmail.com&apos;).once(&apos;value&apos;, callback);</span><br></pre></td></tr></table></figure>
<p>我们在要求 firebase 来从 <code>users</code> 节点中搜索一个 <code>email</code> 节点为 <code>kwest@gmail.com</code> 的子节点。根据我们数据库的大小，这可能是一个非常巨量且缓慢的查询，因此 Firebase 给我们提供了指定子节点的高性能索引。在这个例子中，我们希望 Firebase 通过 <code>email</code> 这个子节点索引所有用户。做法很简单，<code>&quot;.indexOn&quot;: &quot;email&quot;</code>。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;users&quot;: &#123;</span><br><span class="line">      &quot;$uid&quot;: &#123;</span><br><span class="line">        &quot;.read&quot;: &quot;auth.uid == $uid&quot;,</span><br><span class="line">        &quot;.indexOn&quot;: [</span><br><span class="line">          &quot;email&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们还要索引其他子节点，比如说 <code>users/{$user}/username</code>，我们的规则就这么写 <code>&quot;.indexOn&quot;: [&quot;email&quot;, &quot;username&quot;]</code>。</p>
<h2 id="遍历树以获取细节权限"><a href="#遍历树以获取细节权限" class="headerlink" title="遍历树以获取细节权限"></a>遍历树以获取细节权限</h2><p>让我们将这个设想的类似 twitter 的 app 的第三个用户称为： Ryan Seacrest。Ryan 的账号是管理员账号。注意到了他的用户账号里的 <code>&quot;isAdmin&quot;: true</code> 属性了吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;users&quot;: &#123;</span><br><span class="line">      &quot;$uid&quot;: &#123;</span><br><span class="line">        &quot;.read&quot;: &quot;auth.uid == $uid || root.child(&apos;users&apos;).child(auth.uid).child(&apos;isAdmin&apos;).val() == true&quot;,</span><br><span class="line">        &quot;.write&quot;: &quot;root.child(&apos;users&apos;).child(auth.uid).child(&apos;isAdmin&apos;).val() == true&quot;,</span><br><span class="line">        &quot;.indexOn&quot;: [</span><br><span class="line">          &quot;email&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户们仍然可以读取他们自己的账户数据，不过我们刚刚给所有有 <code>isAdmin</code> 标识的用户赋予了读写权限。用于检测这个标识的规则是 <code>root.child(‘users’).child(auth.uid).child(‘isAdmin’).val()</code>。<code>root</code> 对象代表我们的 Firebase 的根节点。接着我们调用 <code>.child(&#39;nodeName&#39;)</code> 来向下找到我们的认证过的用户的 <code>isAdmin</code> 节点。看到了是怎么使用 <code>auth.uid</code> 来深入到这个认证用户的吗？是，这样做很聪明。它同时也悄悄地让任何没有认证的用户访问失败，这样这些节点就安全了。</p>
<p>还有一点要注意：我们在一个节点上调用 <code>.val()</code> 来获取它的值。这让人想起我们是如何使用 Firebase JavaScript SDK 来处理数据快照，应该看起来很熟悉吧。</p>
<p>另外一点：还有别的遍历树的方式。我们可以调用 <code>data.parent().child(auth.uid).val()</code> 来从我们正在保护的节点往上走到 <code>users</code> 再往下走。这个方法会很实用，但是从 <code>root</code> 开始遍历会更可靠，因为 <code>root</code> 对于我们 app 的任何部分都是一样的。为了安全，还是用 <code>root</code> 吧。</p>
<h2 id="使用-Bolt-规则编译器来-streamline-你的规则"><a href="#使用-Bolt-规则编译器来-streamline-你的规则" class="headerlink" title="使用 Bolt 规则编译器来 streamline 你的规则"></a>使用 Bolt 规则编译器来 streamline 你的规则</h2><p>到目前我们一直在直接修改我们的规则 JSON 对象。这没有问题，但是它可能总是在重复复制粘贴操作。Firebase 团队也已经疲于复制粘贴，于是写了一个和 <a href="https://github.com/firebase/firebase-tools" target="_blank" rel="external">firebase-tools</a> CLI 结合来让规则更容易写的编译器。</p>
<p>你需要通过 <code>npm install -g firebase-bolt</code> 安装 Bolt 并且在你的项目根目录创建一个命名为类似 <code>security-rules.bolt</code> 的文件。然后你可以执行 <code>firebase-bolt sevurity-rules.bolt</code>，它会编译你的 Bolt 规则到一个新的文件并命名为 <code>firebase-rules.json</code>。生成的 JSON 可能会比我们之前写的 JSON 更啰嗦，但是 Bolt 语法很好用精炼。详见 <a href="https://github.com/firebase/bolt/blob/master/docs/language.md" target="_blank" rel="external">Bolt language reference</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function isUser (auth, userKey) &#123;</span><br><span class="line">  return uid == userKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isAdmin (auth) &#123;</span><br><span class="line">  return root.child(&apos;users&apos;).child(auth.uid).child(&apos;isAdmin&apos;).val() == true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path /users/&#123;uid&#125; &#123;</span><br><span class="line">  read() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">  write() &#123; isAdmin(auth) &#125;</span><br><span class="line">  index() &#123; [&quot;email&quot;] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path /userReadable/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line">  read() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">  write() &#123; isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path /userWriteable/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line">  read() &#123; isAdmin(auth) &#125;</span><br><span class="line">  write() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">path /userOwned/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line">  read() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">  write() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意我们是怎样写在顶部的两个方法的：<code>isUser(auth, uid)</code> 和 <code>isAdmin(auth)</code>。这些方法不是必须的，但是超级有用。它们让我们可以在我们的规则中重用一些逻辑。</p>
<p>下一个部分有一堆 <code>path</code> 块。使用 <code>/[nodeName]/</code> 来通配你的路径。这些通配值在这些 path 的范围内都是可用的，因此你可从 <code>/userReadable/objectType/uid</code> 获取 <code>uid</code>，并传给 <code>read() { isUser(auth, uid) || isAdmin(auth) }</code>。</p>
<h2 id="根据读写权限来结构化你的数据"><a href="#根据读写权限来结构化你的数据" class="headerlink" title="根据读写权限来结构化你的数据"></a>根据读写权限来结构化你的数据</h2><p>你可能注意到了有三个顶级节点被命名为：</p>
<ul>
<li>userReadable</li>
<li>userWriteable</li>
<li>userOwned</li>
</ul>
<p>上一节中我们授予了用户读权限给 <code>userReadable</code> 的子节点、写权限给 <code>userWriteable</code> 的子节点以及完整的读写权限给 <code>userOwned</code> 的子节点。</p>
<p>这是只一个随意的数据结构…我们可以将这三个节点命名为随便什么。不过命名为描述性的名字会更好。接着我们用了通配路径（<code>path/userReadable/objectType/uid</code>）来给一组一组的对象应用规则。</p>
<p>现在我们不需要给我们创建的每一类对象都编写规则。我们只需要将这些对象嵌套在恰当的权限节点下就好了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;</span><br><span class="line">    &quot;userOwned&quot;: &#123;</span><br><span class="line">      &quot;preferences&quot;: &#123;</span><br><span class="line">        &quot;kanyesUID&quot;: &#123;</span><br><span class="line">          &quot;loveKanye&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;taylorsUID&quot;: &#123;</span><br><span class="line">          &quot;listenToHaters&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>userOwned</code> 节点有对所有在匹配的用户 uid 下的对象的读写权限。因此只有 Kanye 可以访问 <code>/userOwned/preferences/kanyesUID</code>，并且 Kanye 有完整的读写权限。</p>
<p>要记得我们可以通过制定另一条匹配路径规则来重写统配规则，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">path /userOwned/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line"> read() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">  write() &#123; isUser(auth, uid) || isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br><span class="line">path /userOwned/grammyNominations/taylorsUID &#123;</span><br><span class="line">  read() &#123; true &#125;</span><br><span class="line">  write() &#123; uid == kanyesUID &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二条规则重写了 <code>/userOwned/{objectType}/uid</code> 并仅授予 Kanye 对于 Taylor’s Grammy Nominations 的写权限。同时也让这个列表全世界可读，因此任何网站或者用户都可以通过 <code>https://&lt;some firebase&gt;.firebaseio.com/userOwned/grammyNominations/taylorsUID.json</code> 来获取这个列表。</p>
<h2 id="保证安全性的同时验证你的数据"><a href="#保证安全性的同时验证你的数据" class="headerlink" title="保证安全性的同时验证你的数据"></a>保证安全性的同时验证你的数据</h2><p><code>read()</code>、<code>write()</code> 以及 <code>index()</code> 覆盖了大多数使用情况，但有时候你可能需要更多对于要写入的数据的更细节的控制。</p>
<p>Bolt 允许你创建可以在多节点间重用的数据类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path /userOwned/preferences/&#123;uid&#125; is Preferences;</span><br><span class="line">type Preferences &#123;</span><br><span class="line"> validate() &#123; this.excuse.length &lt; 20 &amp;&amp; this.respectRating &lt; 5 &#125;</span><br><span class="line">  useAutotune: Boolean,</span><br><span class="line">  excuse: String,</span><br><span class="line">  respectRating: Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们可以将验证规则和 <code>validate()</code> 混合在一起。</p>
<p>你也可以将类型和读写权限混合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">path /userOwned/preferences/&#123;uid&#125; is Preferences &#123;</span><br><span class="line"> read() &#123; isUser(auth, uid) &#125;</span><br><span class="line"> write() &#123; isUser(auth, uid) &#125;</span><br><span class="line">&#125;</span><br><span class="line">type Preferences &#123;</span><br><span class="line">  validate() &#123; this.excuse.length &lt; 20 &amp;&amp; this.respectRating &lt; 5 &#125;</span><br><span class="line">  useAutotune: Boolean,</span><br><span class="line">  excuse: String,</span><br><span class="line">  respectRating: Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="别名规则"><a href="#别名规则" class="headerlink" title="别名规则"></a>别名规则</h2><p>目前为止我们仅仅使用了 <code>read()</code>、<code>write()</code>、<code>index()</code> 和 <code>validate()</code>，但是 Bolt 支持其它三个功能：</p>
<ul>
<li>create()</li>
<li>update()</li>
<li>delete()</li>
</ul>
<p>这些方法都是 <code>write()</code> 的别名，因此他们不能和 <code>write()</code> 一起混合到同一个 <code>path</code> 块。它们创建了分别仅适用于新建、更新或者删除操作的 <code>write()</code> 规则。下面的示例是如果你想要给用户权限创建对象但是不能编辑或者删除，<code>create()</code> 会生成处理这种情况的 <code>write()</code> 规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">path /dropbox/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line"> create() &#123; isUser(auth, uid) &#125;</span><br><span class="line">  read() &#123; isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">path /editable/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line">  update() &#123; isUser(auth, uid) &#125;</span><br><span class="line">  read() &#123; isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">path /deleteable/&#123;objectType&#125;/&#123;uid&#125; &#123;</span><br><span class="line">  delete() &#123; isUser(auth, uid) &#125;</span><br><span class="line">  read() &#123; isAdmin(auth) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="部署你的规则"><a href="#部署你的规则" class="headerlink" title="部署你的规则"></a>部署你的规则</h2><p>有两种方式：</p>
<ol>
<li>执行 <code>firebase-bolt my-rules-file.bolt</code> 来创建 <code>my-rules-files.json</code>，然后你可以复制粘贴到你的实时数据库规则控制台。</li>
<li>执行 <code>firebase-tools init</code> 来创建你的 <code>firebase.json</code> 托管文件，然后在 <code>database.rules</code> 创建一个节点来指向你的 <code>.bolt</code> 或者 ‘.json’ 规则文件。接着运行 <code>firebase deploy --only rules</code> 来通过命令行部署你的规则。</li>
</ol>
<p>我们稍后会谈到 <code>firebase.json</code> 这个选项。现在，看看下面这个 <code>firebase.sjon</code> 例子并且留意 <code>database.rules</code> 这个节点。它指向了一个记录了我的 bolt 规则的叫做 <code>database.rules.bolt</code> 的文件。如果这个文件被命名为 <code>database.rules.json</code>，firebase 会知道我的规则是 JSON 格式，不过因为我命名了为 <code>.bolt</code>，它会在上传其到我的 Firebase 云上之前自动将其传给 <code>firebase-bolt</code> 编译器进行编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Eample firebase.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;database&quot;: &#123;</span><br><span class="line">    &quot;rules&quot;: &quot;database.rules.bolt&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hosting&quot;: &#123;</span><br><span class="line">    &quot;public&quot;: &quot;dist&quot;,</span><br><span class="line">    &quot;rewrites&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;source&quot;: &quot;/app/**/*&quot;,</span><br><span class="line">        &quot;destination&quot;: &quot;/index.html&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ignore&quot;: [</span><br><span class="line">      &quot;firebase.json&quot;,</span><br><span class="line">      &quot;**/.*&quot;,</span><br><span class="line">      &quot;**/node_modules/**&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;functions&quot;: &#123;</span><br><span class="line">    &quot;.source&quot;: &quot;functions&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>差不多就这样了。</p>
<p>具体练习见原文吧 ：D。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://howtofirebase.com/firebase-security-rules-88d94606ce4a&quot;&gt;Firebase Security &amp;amp; Rules&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Firebase 是一个可以从任意建立连接了的客户端访问的云数据库。因为任意客户端都可以连接到任意 Firebase [数据库]，你&lt;strong&gt;必须&lt;/strong&gt;制定安全规则来保护你的数据。写不好恰当的安全规则会让你暴露在攻击中。不过别着急！你马上就能学到帮你紧紧锁住你的数据的全部知识了。&lt;/p&gt;
&lt;p&gt;保持安全规则简洁。安全规则可能变得过于复杂，并很快变得不受控制如果你的数据结构不够设计充分的话。这篇文章展示了一些“最佳”实践。估计你会讲其略作修改就用到你的生产应用中去……如果你选择采用这些模式，记得仔细想想背后的含义就行。确保在你开始搞事之前，读了整篇文章以及&lt;a href=&quot;https://firebase.google.com/docs/database/security/&quot;&gt;安全规则文档&lt;/a&gt;全文。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Firebase" scheme="http://chengkang.me/tags/Firebase/"/>
    
  </entry>
  
  <entry>
    <title>《Learning AV Foundation》学习笔记，第一章：AV Foundation 基础</title>
    <link href="http://chengkang.me/2017/06/06/learning-av-foundation-1/"/>
    <id>http://chengkang.me/2017/06/06/learning-av-foundation-1/</id>
    <published>2017-06-06T18:20:16.000Z</published>
    <updated>2017-06-06T19:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列是我学习《Learning AV Foundation：A Hands-on Guide to Matering the AV Foundation Framework》的学习笔记。将以章为单位，对内容进行总结。</p>
</blockquote>
<h2 id="AV-Foundation"><a href="#AV-Foundation" class="headerlink" title="AV Foundation"></a>AV Foundation</h2><p>AV Foundation 处于上层框架（iOS：AVKit、UIKit，Mac OS：AVKit、AppKit）和底层框架（Core Audio、Core Video，Core Media 以及 Core Animation）之间，在 iOS 和 Mac OS 中通用。</p>
<p>其主要功能包括：</p>
<ul>
<li>音频播放和记录（Audio Playback and Recording）</li>
<li>媒体文件检查（Media Inspection）</li>
<li>视频播放（Video Playback）</li>
<li>媒体捕捉（Media Capture）</li>
<li>媒体编辑（Media Editing）</li>
<li>媒体处理（Media Processing）</li>
</ul>
<h2 id="数字媒体-（Digital-Media）"><a href="#数字媒体-（Digital-Media）" class="headerlink" title="数字媒体 （Digital Media）"></a>数字媒体 （Digital Media）</h2><p>现实中的信号是连续的，数字世界中的信号是离散的。为了储存并传输媒体信息，需要将将连续的<code>模拟信号</code>转换为离散的<code>数字信号</code>，这一过程称之为<code>采样（Sampling）</code>。</p>
<h3 id="采样的两种方式"><a href="#采样的两种方式" class="headerlink" title="采样的两种方式"></a>采样的两种方式</h3><ol>
<li>时间采样（Temporal Sampling）：捕捉一个信号在周期内的变化。</li>
<li>空间采样（Spatial Sampling)：对一幅图片在一定分辨率之下捕捉其亮度和色度，<br>进而创建由该图片的像素点数据所构成的数字化结果。</li>
</ol>
<blockquote>
<p>当对一段视频进行数字化时，这两种方式都可以使用，因为通常的视频信号既有空间属性又有时间属性。</p>
</blockquote>
<h3 id="音频采样"><a href="#音频采样" class="headerlink" title="音频采样"></a>音频采样</h3><p>如下两个音频正弦波图，分别是 1Hz （左）和 5Hz （右）。</p>
<p><img src="" alt=""></p>
<p>我们对信号的两个方面比较感兴趣。一个是<code>振幅</code>，它代表电压的强度或者对应信号的强度。另一个是<code>频率</code>（单位：赫兹 Hz），表示在一定周期内完成循环的次数。</p>
<blockquote>
<p>人类可听见的音频范围是 20Hz~20kHz。但具体范围也因人而异。</p>
</blockquote>
<p>音频数字化使用到一个编码方法，称为<code>线性脉冲编码调制（linear pulse-code madulation）</code>，也常被称为 <code>Linear PCM</code> 或者 <code>LPCM</code>。这个过程通过一个固定的周期率（<code>采样率（Sampling Rate）</code>）对音频信号进行采样。下图展示了在一秒内对信号进行 7 此采样及信号数字化的结果：</p>
<p><img src="" alt=""></p>
<p>显然低<code>采样率</code>的数字信号无法很好地表现原始数据。下图是提高<code>采样率</code>之后的结果：</p>
<p><img src="" alt=""></p>
<p>虽然无法完全准确表现原始信号，但是随着<code>采样率</code>的提高，我们可以找到一个能够生成足够好的数字呈现效果的<code>采样率</code>。这个<code>采样率</code>被称为<code>尼奎斯特率</code>。<strong>Harry Nyquist 发现：想要准确地捕捉一个特定频率，你需要用至少两倍于其最高频率的<code>采样率</code>进行采样。</strong></p>
<p>数字音频采样另一个重要的方面是我们捕捉每个样本的准确度。因为<code>振幅</code>是线性衡量的，因此也就有了<code>线性脉冲编码调制</code>这个术语。“用于保存样本值的字节数定义了在线性维度上可行的离散度，同时这个信息也被称为音频的<code>位元深度(Bit Depth)</code>。为每个样本的整体量化分配过少的位结果信息会导致数字音频信号产生噪声和扭曲。使用<code>位元深度</code>为8的方法可以提供 256 个离散级别的数据，对于一些音频资源来说，这个级别的<code>采样率</code>已经足够了，但对于大部分音频内容来说还不够高。CD音质的<code>位元深度</code>为 16，可以达到 65536 个离散级别。专业级别的音频录制环境的<code>位元深度</code>可以达到 24 或更高。”</p>
<h3 id="数字媒体压缩"><a href="#数字媒体压缩" class="headerlink" title="数字媒体压缩"></a>数字媒体压缩</h3><p>视频文件由一系列被称为<code>帧（frame）</code>的图片组成。视频文件一秒钟内所能展现的帧数称为视频的<code>帧率</code>，并用 <code>FPS(frames per second)</code> 作为单位进行测量。常见的帧率是24FPS、25FPS 和 30FPS。以下是不同色彩空间、分辨率及帧率下未压缩视频占用空间打下：</p>
<p><img src="" alt=""></p>
<p>显然，需要压缩。</p>
<p>视频数据通常用一个叫做 <code>Y&#39;CbCr</code> 的颜色模型进行加密，其方法是分离色彩通道（UV）和亮度通道（Y）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列是我学习《Learning AV Foundation：A Hands-on Guide to Matering the AV Foundation Framework》的学习笔记。将以章为单位，对内容进行总结。&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="AV Foundation" scheme="http://chengkang.me/tags/AV-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>Core Graphics 教程第一部分：开始</title>
    <link href="http://chengkang.me/2017/05/30/core-graphics-tutorial-part-1/"/>
    <id>http://chengkang.me/2017/05/30/core-graphics-tutorial-part-1/</id>
    <published>2017-05-30T11:20:08.000Z</published>
    <updated>2017-05-30T11:21:13.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics，第四部分：Path！Path！</title>
    <link href="http://chengkang.me/2017/05/29/core-graphics-part-4/"/>
    <id>http://chengkang.me/2017/05/29/core-graphics-part-4/</id>
    <published>2017-05-29T20:18:57.000Z</published>
    <updated>2017-05-29T20:20:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-4-a-path-a-path/" target="_blank" rel="external">Core Graphics, Part 4: A Path! A Path!</a><br>看看上一篇吧：<a href="http://chengkang.me/2017/05/23/core-graphics-part-3/">【译】Core Graphics，第三部分：线</a></p>
</blockquote>
<p>在 Core Graphics 中，一个 <code>path</code> 就是对某种形状的一步一步的描述。它可以是一个圆、一个正方形、一个桃心、一个字频柱状图或者可能是一个笑脸。它并不包含任何诸如像素颜色、线宽或渐变这样的信息。路径主要是用于绘制——将其用颜色填充或者描边——用颜色描出轮廓。你之前看到的各种 <a href="https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/" target="_blank" rel="external"><code>GState</code></a> 参数控制着 path 如何被绘制，包括例如 line join 和 dash pattern 在内的所有<a href="https://www.bignerdranch.com/blog/core-graphics-part-three-lines/" target="_blank" rel="external">线属性</a>。</p>
<p>这一次让你看看 path 是什么组成的。下一次你会看到一些用 path 能做的远非简单绘制的很酷的东西。</p>
<a id="more"></a>
<p>虽然一个 path 代表了一个理想图形的配方，它需要被渲染出来才能被人真正看到。每一个 Core Graphics context 都尽其可能将 path 渲染出来。当绘制一个位图时，任何曲线和斜线都是反锯齿化的。这意味着使用阴影来欺骗眼睛使其一位这个形状是平滑的即使它是由方形像素点组成的。当在打印机上绘制时，同样的事情发生着，不过用的是极其小的像素点。当绘制 PDF 时，path 大部分仅仅是原位防止，因为 Core Graphics 绘制模型和 PDF 绘制模型基本是一样的。PDF 引擎（例如 Preview 或者 Adobe Acrobat）会去渲染那些 PDF path 而非 Core Graphics 引擎。</p>
<p>你可以试试 <a href="https://github.com/markd2/grafdemo" target="_blank" rel="external">GrafDemo</a> 里面的 path。大多数这里的截图都来自 GrafDemo 里的 Path 部分、Arcs 以及 All The Parts 窗口。</p>
<h2 id="路径元素"><a href="#路径元素" class="headerlink" title="路径元素"></a>路径元素</h2><p>一个 path 就是由一些被称之为<em>元素</em>的原始形状（曲线、弧和直线）连接起来的一系列点。你可以想象每一个元素是给一个专门的拿着铅笔的机器人的一个指令。你告诉这个机器人要提起铅笔并移动到笛卡尔平面的一个点，但是不要留下任何 印记。你可以告诉这个机器人去把铅笔落下来然后从当前的点到一个新点间画点什么。有五种基本的路径元素：</p>
<p><em>Move to Point</em>——移动当前的点到一个新的位置但不画任何东西。机器人抬起铅笔并且移动它的手臂。</p>
<p><em>Add Line To Point</em>——从当前点到一个新点间添加一条线。机器人将铅笔落下来并画出一条直线。以下是一次<em>移动到点</em>（左下方）和其后的两次<em>添加线到点</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: nextPoint)</span><br><span class="line">path.addLine(to: endPoint)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-moveto---x----158-132x---.gif" alt=""></p>
<p><em>添加二次曲线到点 Add Quad Curve To Point</em>——通过一个控制点，从当前点到一个新点间添加一条二次曲线。机器人落下了铅笔并在绘制一条曲线。这条线并不是直接划到那个控制点——相反这个控制点影响着（线的）形状。控制点离曲线越远，形状就越极端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: firstPoint)</span><br><span class="line">path.addQuadCurve(to: endPoint, control: controlPoint)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-quadcurve---x----155-130x---.gif" alt=""></p>
<p><em>Add Curve To Point</em>——通过两个控制点，从当前点到新点添加一条三次<a href="https://vimeo.com/106757336" target="_blank" rel="external">贝塞尔曲线</a>。和二次曲线一样，控制点影响着这条线该如何画。二次曲线无法自身形成一个环，但是贝塞尔曲线可以。如果你曾在 Photoshop 或者 Illustrator 中使用过钢笔工具，你就和贝塞尔曲线打过交道了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: firstPoint)</span><br><span class="line">path.addCurve(to: endPoint,</span><br><span class="line">              control1: firstControl,</span><br><span class="line">              control2: secondControl)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-beziercurve---x----155-130x---.gif" alt=""></p>
<p><em>Close Subpath</em>——从当前点到路径的第一个点间添加一条直线。更确切地说，最近的那个 move-to-point （的点）。你会希望闭合一个路径而非添加一条线到起始位置。根据你如何计算这些点，累积的浮点化整可能使得计算出的终点和起始点不一样。以下（代码）可以绘制一个三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: nextPoint)</span><br><span class="line">path.addLine(to: endPoint)</span><br><span class="line">path.closeSubpath()</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-closed-path---x----145-132x---.gif" alt=""></p>
<p>注意这个名字是 <em>Close Subpath</em>。通过执行一次 move-to 操作，你可以创建一个包含分离部分的路径，例如这个在我们 <a href="https://www.bignerdranch.com/training/courses/advanced-ios-bootcamp/" target="_blank" rel="external">Advanced iOS bootcamp</a> 中新练习题里的一个柱状图。这些柱形都是用一个路径绘制的。这个路径被用来给它们上色，并且描出轮廓以清楚地区别各个柱形。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-infographic---x----462-298x---.png" alt=""></p>
<h2 id="那样做方便吗？"><a href="#那样做方便吗？" class="headerlink" title="那样做方便吗？"></a>那样做方便吗？</h2><p>简单的图形用那仅有的五个基本路径元素去生成的话（代码、过程）可能会变得很冗长。Core Graphics （或者说 CG）提供了一些简便方法来添加常见的形状，比如矩形、椭圆或者一个圆角矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let squarePath = CGPath(rect: rect1, transform: nil)</span><br><span class="line">let ovalpath = CGPath(ellipseIn: rect2, transform: nil)</span><br><span class="line">let roundedRectanglePath = CGPath(roundedRect: rect3,</span><br><span class="line">                                  cornerWidth: 10.0,</span><br><span class="line">                                  cornerHeight: 10.0,</span><br><span class="line">                                  transform: nil)</span><br></pre></td></tr></table></figure>
<p>这些方法使用了一个 <em>transform</em> 对象作为它们最后一个参数。你会在之后的文章中看到更多关于 transform 的东西，因此暂时只传个 nil 就行了。以上的方法（<code>CGPath(rect:tranform:)</code>、<code>CGPath(ellipseIn:transform:)</code>和<code>CGPath(roundedRect:cornerWidth:cornerHeight:transform:)</code>）生成了这些形状：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-conveniences---x----860-230x---.png" alt=""></p>
<p>同样也还有一些可以让你用一个就能创建更复杂的路径的方法，例如多个矩形或者多个椭圆、多个线段或者一整个别的路径。</p>
<h2 id="Noah-的-ARCtangent"><a href="#Noah-的-ARCtangent" class="headerlink" title="Noah 的 ARCtangent"></a>Noah 的 ARCtangent</h2><p>你也可以加一点弧在里面，就是一个圆形边的部分。用哪一个取决于你手上握着什么值。</p>
<p><em>Arc</em>——需要给定你想要的弧所在的那个圆的圆心、它的半径以及起始和终止角度（用弧度表示）。那个圆从起始角度到终止角度之间的那一段将会被绘制。弧的终点成为了当前点。以下代码绘制了左边的线，外加一个圆：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addArc(center: centerPoint,</span><br><span class="line">            radius: radius,</span><br><span class="line">            startAngle: startAngle,</span><br><span class="line">            endAngle: endAngle,</span><br><span class="line">            clockwise: clockwise)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-arc---x----217-262x---.gif" alt=""></p>
<p><em>Relative Arc</em>——这个与正常的弧类似。需要给定圆心、半径和起始角度。但并不是要给定一个终止角度，而是你要说明要从起始角度往前或者往后画多少个弧度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addRelativeArc(center: centerPoint,</span><br><span class="line">                    radius: radius,</span><br><span class="line">                    startAngle: startAngle,</span><br><span class="line">                    delta: deltaAngle)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-relative-arc---x----217-262x---.gif" alt=""></p>
<p><em>Arc to Point</em>——这个就有点奇怪了。你需要给定圆半径和两个控制点。在后台呢，当前的店会和第一个控制点连接，然后与第二个控制点形成一个角度。这些线接下来被用于构建一个有着给定半径并正切于这些线的圆。我将这种弧称作 “Arc to Point” 是因为其底层的 C API 名字叫 <code>CGContextAddArcToPoint</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addArc(tangent1End: tangent1Point,</span><br><span class="line">            tangent2End: tangent2Point,</span><br><span class="line">            radius: radius)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2017/02/apath-arc-to-point---x----217-192x---.gif" alt=""></p>
<p>我在试着想出一个这个方法的好的应用场景时，朋友 <a href="https://www.bignerdranch.com/about/the-team/jeremy-sherman/" target="_blank" rel="external">Jeremy W. Sherman</a> 想到一个很酷的应用：如果你想做一个曲面的交叉影线时可能比较有用，想想“给一把剑的顶部加一点阴影”——你可以重复同样的正切并且改变半径来画一些离顶部越来越远的弧。</p>
<p>你可能已经注意到了这些弧的方法可以用直线段来连接圆弧。用前两个弧方法来创建一个新的路径是不会创建这个连接用的线段的。Arc to point 可能会包含那个初始的部分。</p>
<h2 id="Path-vs-Context-操作"><a href="#Path-vs-Context-操作" class="headerlink" title="Path vs Context 操作"></a>Path vs Context 操作</h2><p>有两种在代码里创建路径的方法。第一种方式是告诉 context：“嘿，创建一个新的 path” 并开始累积 path 元素。这个 path 在你描边或者填充时就消失了。没了。拜拜了。这个 path 也并没有被保存或者可以在你保存恢复 GState 的时候恢复——它实际上并不是 GState 的一部分。每一个 context 只有一个在用状态的 path。</p>
<p>一下是当前 context 被用于构建和描边一个 path 时的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let context = UIGraphicsGetCurrentContext()</span><br><span class="line">context.beginPath()</span><br><span class="line">context.move(to: controlPoints[0])</span><br><span class="line">context.addQuadCurve(to: controlPoints[1], control: controlPoints[2])</span><br><span class="line">context.strokePath()</span><br></pre></td></tr></table></figure>
<p>这些对于那些一次性的只创建一次、用一次然后被遗忘的 path 非常棒。</p>
<p>你也可以创建一个新的 <code>CGMutablePath</code> path 对象（一个 <code>CGPath</code> 类型的 mutable 子类，与 <code>NSArray / NSMutableArray</code> 间的关系类似）并在其中累积 path 组件。这是一个你可以一直用的实例。要用一个 path 对象绘制的话，你要将这个 path 添加到 context 中然后执行描边与/或填充操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let path = CGMutablePath()</span><br><span class="line">path.move(to: controlPoints[0])</span><br><span class="line">path.addQuadCurve(to: controlPoints[1], control: controlPoints[2])</span><br><span class="line"></span><br><span class="line">context.addPath(path)</span><br><span class="line">context.strokePath()</span><br></pre></td></tr></table></figure>
<p>对于你常用的形状（比如卡片游戏里的那一套图标），你可能希望创建一个红心 path 和一个方片 path 一次然后用它们一次次绘制。</p>
<h2 id="如何创建？"><a href="#如何创建？" class="headerlink" title="如何创建？"></a>如何创建？</h2><p>那么你如何才能创建出有用又有趣的 path 呢，比如心形或者笑脸？一个方法是做好数学功课并计算出点、线、曲线和弧需要怎么走。</p>
<p>另一个方法就是用软件工具。有一些可以让你画形状的的应用，然后返回给你一堆可以直接粘贴到你的应用中的 CG 代码。同时也有一些可以将其他形式数据（例如来自 Illustrator的、PDF 或者 SVG）转换成 path 的库。我在给 <a href="https://www.bignerdranch.com/blog/protocols-part-2-delegation/" target="_blank" rel="external">Protocols part 2: Delegation</a> 准备的 world demo app 中的可点击地图中使用了 SVG。</p>
<h2 id="路径，结构"><a href="#路径，结构" class="headerlink" title="路径，结构"></a>路径，结构</h2><p>Core Graphics 路径是不透明数据类型。你先累积路径元素然后在 context 中渲染它。为了了解内部情况，使用 <code>CGPath</code> 的 <code>apply(info:function:)</code> 方法来遍历路径组件。你可以提供一个被每一个路径元素重复调用的方法（在 Swift 中你可以用闭包）。（你可以忽略 info 参数通过传 <code>nil</code>。这是在 Swift Core Graphics API 底下的 C API 的一个延续。在 C 里面你需要提供一个方法并传递任何你需要在里面使用到的对象。用闭包的话你就只需要用你需要的那些。）</p>
<p>也因为其对 C 的继承，这个传进来的方法或闭包是一个 <code>UnsafePointer&lt;CGPathElement&gt;</code>。这是一个指向内存中 <code>CGPathElement</code> 的指针。你需要通过 <code>pointee</code> 来引用那个指针以得到实际的 <code>CGPathElement</code>。这个 path 元素有一个用于表现其类型的枚举值，还有一个指向一个指针数组里的第一个 <code>CGPoint</code> 的 <code>UnsafeMutablePointer&lt;CGPoint&gt;</code>。你需要自己去搞清楚你可以从那个数组里面安全读取多少指针。</p>
<p>下面是一个 <code>CGPath</code> 扩展，它可以让一个 path 倾倒出其内容。你也可以从这个 <a href="https://gist.github.com/markd2/7bd2a5e2969b000f296828b3bcbf49f8" target="_blank" rel="external">gist</a> 中找到这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import CoreGraphics</span><br><span class="line"></span><br><span class="line">extension CGPath &#123;</span><br><span class="line">    func dump() &#123;</span><br><span class="line">        self.apply(info: nil) &#123; info, unsafeElement in</span><br><span class="line">            let element = unsafeElement.pointee</span><br><span class="line"></span><br><span class="line">            switch element.type &#123;</span><br><span class="line">            case .moveToPoint:</span><br><span class="line">                let point = element.points[0]</span><br><span class="line">                print(&quot;moveto - \(point)&quot;)</span><br><span class="line">            case .addLineToPoint:</span><br><span class="line">                let point = element.points[0]</span><br><span class="line">                print(&quot;lineto - \(point)&quot;)</span><br><span class="line">            case .addQuadCurveToPoint:</span><br><span class="line">                let control = element.points[0]</span><br><span class="line">                let point = element.points[1]</span><br><span class="line">                print(&quot;quadCurveTo - \(point) - \(control)&quot;)</span><br><span class="line">            case .addCurveToPoint:</span><br><span class="line">                let control1 = element.points[0]</span><br><span class="line">                let control2 = element.points[1]</span><br><span class="line">                let point = element.points[2]</span><br><span class="line">                print(&quot;curveTo - \(point) - \(control1) - \(control2)&quot;)</span><br><span class="line">            case .closeSubpath:</span><br><span class="line">                print(&quot;close&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出之前创建那个 arc to point 图片的 path 展示出这条弧是一系列 curveTo 操作及连接用的直线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.move(to: startPoint)</span><br><span class="line">path.addLine(to: firstSegmentPoint)</span><br><span class="line">path.addArc(tangent1End: tangent1Point,</span><br><span class="line">            tangent2End: tangent2Point,</span><br><span class="line">            radius: radius)</span><br><span class="line">path.addLine(to: secondSegmentPoint)</span><br><span class="line">path.addLine(to: endPoint)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">moveto - (5.0, 91.0)      // explicit code</span><br><span class="line">lineto - (72.3, 91.0)     // explicit code</span><br><span class="line">lineto - (71.6904767391754, 104.885702433811)   // added by addArc</span><br><span class="line">curveTo - (95.5075588575432, 131.015122621923)</span><br><span class="line">        - (71.0519422129889, 118.678048199439)</span><br><span class="line">        - (81.7152130919145, 130.376588095736)</span><br><span class="line">curveTo - (113.012569145714, 124.955236840146)</span><br><span class="line">        - (101.903264013406, 131.311220082842)</span><br><span class="line">        - (108.168814214539, 129.14221144167)</span><br><span class="line">lineto - (129.666666666667, 91.0) // explicit code</span><br><span class="line">lineto - (197.0, 91.0)   // explicit code</span><br></pre></td></tr></table></figure>
<p>即使是一个用 <code>CGPath(ellipseIn:transform:)</code> 创建的“简单的”椭圆也有些复杂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curveTo - (62.5, 107.0) - (110.0, 86.4050984922165) - (88.7335256169627, 107.0)</span><br><span class="line">curveTo - (15.0, 61.0) - (36.2664743830373, 107.0) - (15.0, 86.4050984922165)</span><br><span class="line">curveTo - (62.5, 15.0) - (15.0, 35.5949015077835) - (36.2664743830373, 15.0)</span><br><span class="line">curveTo - (110.0, 61.0) - (88.7335256169627, 15.0) - (110.0, 35.5949015077835)</span><br></pre></td></tr></table></figure>
<h2 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h2><p>这一次你看到了创建一个 path、绘制它以及其中发生的一切。还有很多你可以用 path 做的事情，下次继续。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-4-a-path-a-path/&quot;&gt;Core Graphics, Part 4: A Path! A Path!&lt;/a&gt;&lt;br&gt;看看上一篇吧：&lt;a href=&quot;http://chengkang.me/2017/05/23/core-graphics-part-3/&quot;&gt;【译】Core Graphics，第三部分：线&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Core Graphics 中，一个 &lt;code&gt;path&lt;/code&gt; 就是对某种形状的一步一步的描述。它可以是一个圆、一个正方形、一个桃心、一个字频柱状图或者可能是一个笑脸。它并不包含任何诸如像素颜色、线宽或渐变这样的信息。路径主要是用于绘制——将其用颜色填充或者描边——用颜色描出轮廓。你之前看到的各种 &lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/&quot;&gt;&lt;code&gt;GState&lt;/code&gt;&lt;/a&gt; 参数控制着 path 如何被绘制，包括例如 line join 和 dash pattern 在内的所有&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-three-lines/&quot;&gt;线属性&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这一次让你看看 path 是什么组成的。下一次你会看到一些用 path 能做的远非简单绘制的很酷的东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】哥们儿，我的方法哪儿去了？</title>
    <link href="http://chengkang.me/2017/05/25/dude-where-is-my-call/"/>
    <id>http://chengkang.me/2017/05/25/dude-where-is-my-call/</id>
    <published>2017-05-25T19:09:58.000Z</published>
    <updated>2017-05-25T19:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/dude-wheres-my-call/" target="_blank" rel="external">Dude, Where’s my Call?</a></p>
</blockquote>
<p>想象有一天你正在给 Swift 编译器喂一些看起来无害的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// xcrun -sdk macosx swiftc -emit-executable cg.swift</span><br><span class="line"></span><br><span class="line">import CoreGraphics</span><br><span class="line"></span><br><span class="line">let path = CGPathCreateMutable()</span><br><span class="line">CGPathMoveToPoint(path, nil, 0.0, 23.0)</span><br></pre></td></tr></table></figure>
<p>然后一个冲击波打来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cg.swift:7:12: error: &apos;CGPathCreateMutable()&apos; has been replaced by &apos;CGMutablePath.init()&apos;</span><br><span class="line">&lt;unknown&gt;:0: note: &apos;CGPathCreateMutable()&apos; has been explicitly marked unavailable here</span><br><span class="line">cg.swift:8:1: error: &apos;CGPathMoveToPoint&apos; has been replaced by instance method &apos;CGMutablePath.moveTo(_:x:y:)&apos;</span><br><span class="line">&lt;unknown&gt;:0: note: &apos;CGPathMoveToPoint&apos; has been explicitly marked unavailable here</span><br></pre></td></tr></table></figure>
<p>它们哪儿去了？被重命名了。</p>
<a id="more"></a>
<p>Swift 3 一个重大的特性就是由 Swift-Evolution 提议 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="external">SE-0005 (Better Translation of Objective-C APIs Into Swift)</a> 和 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md" target="_blank" rel="external">SE-0006 (Apply API Guidelines to the Standard Library)</a> 带来的”超级重命名“，这次超级重命名重命名了 C 和 Objective-C API 中的一些方法以给它们一种更 Swift 的感觉。Xcode 里面有一个移植器会将你的 Swift 2 代码转换成新的风格。它会执行很多机械的改变，给你留一些由于其他语言改变需要扫尾的工作，例如<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md" target="_blank" rel="external">移除 C 的 for 循环</a>。</p>
<p>有一些重命名相当轻微，比如 NSView 中的这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Swift 2</span><br><span class="line">let localPoint = someView.convertPoint(event.locationInWindow, fromView: nil)</span><br><span class="line"></span><br><span class="line">// Swift 3</span><br><span class="line">let localPoint = someView.convert(event.locationInWindow, from: nil)</span><br></pre></td></tr></table></figure>
<p>在这里 <code>Point</code> 从方法名里移除了。你知道自己正在处理一个 point，所以没必要重复这一事实。<code>fromView</code> 重命名为了 <code>from</code> 因为 <code>View</code> 只是提供了冗余的类型信息，并没有让这个调用更清楚。</p>
<p>其他的改变更大一些，比如 Core Graphics：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Swift 2 / (Objective-C)</span><br><span class="line">let path = CGPathCreateMutable()</span><br><span class="line">CGPathMoveToPoint (path, nil, points[i].x, points[i].y)</span><br><span class="line">CGPathAddLineToPoint (path, nil, points[i + 1].x, points[i + 1].y)</span><br><span class="line">CGContextAddPath (context, path)</span><br><span class="line">CGContextStrokePath (context)</span><br><span class="line"></span><br><span class="line">// Swift 3</span><br><span class="line">let path = CGMutablePath()</span><br><span class="line">path.move (to: points[i])</span><br><span class="line">path.addLine (to: points[i + 1])</span><br><span class="line"></span><br><span class="line">context.addPath (path)</span><br><span class="line">context.strokePath ()</span><br></pre></td></tr></table></figure>
<p>喔噢。这变化太大了。这个 API 现在看起来就是让人喜欢的 Swift 风格 API 而不是旧式的 C API。Apple 在 Swift 里面完全改变了 Core Graphics API （还有 GCD）以让它们更好用。你在 Swift 3 里不能再用老式的 CG C 风格的 API，因此你需要开始习惯新的风格。我已经将 GrafDemo （我这些 <a href="http://chengkang.me/2017/05/23/core-graphics-part-1/">Core Graphics</a> 博文的示例程序） 在自动翻译器中跑过（两次）了。你可以在这个 <a href="https://github.com/markd2/GrafDemo/pull/17/files" target="_blank" rel="external">pull</a> 请求中看到 Swift 3 第一个版本前后的变化，在这个 <a href="https://github.com/markd2/GrafDemo/pull/18/files" target="_blank" rel="external">pull</a> 请求中看到 Xcode8b6 的 Swift 3 版本前后变化。</p>
<h2 id="他们干什么了？"><a href="#他们干什么了？" class="headerlink" title="他们干什么了？"></a>他们干什么了？</h2><p>Core Graphics API 就是一堆全局变量和全局自由方法。就是说，方法并不是直接和某些比如说类或者结构体这样的实例绑定的。用 <code>CGContextAddArcToPoint</code> 来操作 <code>CGContext</code> 仅仅是一个传统，不过你传进去一个 <code>CGColor</code> 也不会有人拦着你。无非就是会在运行时爆炸而已。只是在 C 风格的面向对象你才有一个隐晦类型作为第一个参数传过去，作为某种神奇饼干。<code>CGContext*</code> 方法需要一个 <code>CGContextRef</code>。<code>CGColor*</code> 方法需要一个 <code>CGColorRef</code>。</p>
<p>通过一些编译器的魔法，Apple 将这些隐晦引用转成了类，并且添加了一些方法给这些类以将其映射到 C API。当编译器看到类似这样的东西时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let path = CGMutablePath()</span><br><span class="line">path.addLines(between: self.points)</span><br><span class="line">context.addPath(path)</span><br><span class="line">context.strokePath()</span><br></pre></td></tr></table></figure>
<p>实际上，在背后，正在发出这一系列调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let path = CGPathCreateMutable()</span><br><span class="line">CGPathAddLines(path, nil, self.points, self.points.count)</span><br><span class="line">CGContextAddPath(context, path)</span><br><span class="line">CGContextStrokePath(context)</span><br></pre></td></tr></table></figure>
<h2 id="“新的”类"><a href="#“新的”类" class="headerlink" title="“新的”类"></a>“新的”类</h2><p>以下是已经接受 Swift 3.0 治疗的常见的隐晦类型 （忽略了一些专用的类型比如 <code>CGDisplayMode</code> 或者 <code>CGEvent</code>），还有一两个作为代表的方法：</p>
<ul>
<li><code>CGAffineTransform - translateBy(x:30, y:50), rotate(by: CGFloat.pi / 2.0)</code></li>
<li><code>CGPath / CGMutablePath - contains(point, using: evenOdd), .addRelativeArc(center: x, radius: r, startAngle: sa, delta: deltaAngle)</code></li>
<li><code>CGContext - context.addPath(path), context.clip(to: cgrectArray)</code></li>
<li><code>CGBitmapContext (folded in to CGContext) - let c = CGContext(data: bytes, width: 30, height: 30, bitsPerComponent: 8, bytesPerRow: 120, space: colorspace, bitmapInfo: 0)</code></li>
<li><code>CGColor - let color = CGColor(red: 1.0, green: 0.5, blue: 0.333, alpha: 1.0)</code></li>
<li><code>CGFont - let font = CGFont(&quot;Helvetica&quot;), font.fullName</code></li>
<li><code>CGImage - image.masking(imageMask), image.cropping(to: rect)</code></li>
<li><code>CGLayer - let layer = GCLayer(context, size: size, auxilaryInfo: aux), layer.size</code></li>
<li><code>CGPDFContext (folded in to CGContext) / CGPDFDocument - context.beginPDFPage(pageInfo)</code></li>
</ul>
<p><code>CGRect</code> 和 <code>CGPoint</code> 在 Swift 3 之前早已有了一些很不错的扩展。</p>
<h2 id="怎么做到的？"><a href="#怎么做到的？" class="headerlink" title="怎么做到的？"></a>怎么做到的？</h2><p>编译器有一个内置的语法转换器，它将 Objective-C 的明明风格转换成更 Swift 些的形式。去掉重复的单词和那些仅仅是重复类型信息的单词。还去掉了一些之前是在方法调用左括号之前的单词并将它们移到括号里面作为参数标签。通过这样自动清理了一大堆调用方法。</p>
<p>当然，人类喜欢搞一些微妙复杂的言辞，因此在 Swift 编译器里有一个允许手动重写自动翻译器翻译的部分的机制。这是具体的实现了（别在输出产品时依靠他们），不过他们提供了深入了解用于让现存 API 出现在 Swift 中所做的那些工作的机会。</p>
<p>其中一个涉及到的机制是 ”overlay“，它是当你引入一个框架或者 C 库时编译器引用的第二个库。<a href="https://raw.githubusercontent.com/apple/swift/master/docs/Lexicon.rst" target="_blank" rel="external">Swift Lexicon</a> 将 overlay 形容为”当库在系统中不发被修改时在系统中增强和扩大这个库“。一些一直都存在很棒的 <code>CGRect</code> 和 <code>CGPoint</code> 扩展，例如<code>someRect.divide(30.0, fromEdge: .MinXEdge)</code>，怎么来的？他们来自 overlay。工具链想啊”噢，我看到你在链接 Core Graphics。让我再加点方便方法吧。“</p>
<p>还有另外一个机制，<a href="https://github.com/apple/swift/tree/master/apinotes" target="_blank" rel="external">apinotes</a>，特别是 <a href="https://github.com/apple/swift/blob/master/apinotes/CoreGraphics.apinotes" target="_blank" rel="external">CoreGraphics.apinotes</a>，一字一词地控制着 Core Graphics 中地命名和可见性。</p>
<p>例如，在 Swift 中像 <code>CGRectMake</code> 这样用来初始化基础结构体的调用没有作用，因为已经有它们的初始化方法了。所以就让这些调用方法不可用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># The below are inline functions that are irrelevant due to memberwise inits</span><br><span class="line">- Name: CGPointMake</span><br><span class="line">  Availability: nonswift</span><br><span class="line">- Name: CGSizeMake</span><br><span class="line">  Availability: nonswift</span><br><span class="line">- Name: CGVectorMake</span><br><span class="line">  Availability: nonswift</span><br><span class="line">- Name: CGRectMake</span><br><span class="line">  Availability: nonswift</span><br></pre></td></tr></table></figure>
<p>然后还有其他的映射——如果你在 Swift 中看到这个，那就调用那个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># The below are fixups that inference didn&apos;t quite do what we wanted, and are</span><br><span class="line"># pulled over from what used to be in the overlays</span><br><span class="line">- Name: CGRectIsNull</span><br><span class="line">  SwiftName: &quot;getter:CGRect.isNull(self:)&quot;</span><br><span class="line">- Name: CGRectIsEmpty</span><br><span class="line">  SwiftName: &quot;getter:CGRect.isEmpty(self:)&quot;</span><br></pre></td></tr></table></figure>
<p>如果编译器看到了比如 <code>rect.isEmpty()</code> 这样的东西，它会发送一个请求给 <code>CGRectIsEmpty</code>。</p>
<p>以下还是一些方法和功能的重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># The below are attempts at providing better names than inference</span><br><span class="line">- Name: CGPointApplyAffineTransform</span><br><span class="line">  SwiftName: CGPoint.applying(self:_:)</span><br><span class="line">- Name: CGSizeApplyAffineTransform</span><br><span class="line">  SwiftName: CGSize.applying(self:_:)</span><br><span class="line">- Name: CGRectApplyAffineTransform</span><br><span class="line">  SwiftName: CGRect.applying(self:_:)</span><br></pre></td></tr></table></figure>
<p>当编译器看到 <code>rect.applying(transform)</code>，它就知道调用 <code>CGRectApplyAffineTransform</code>。</p>
<p>编译器只能自动重命名 Objective-C API，因为其遵循良好的系统命名法。C API （比如 Core Graphics）需要通过 overlay 和 apinote 来实现。</p>
<h2 id="你能做什么"><a href="#你能做什么" class="headerlink" title="你能做什么"></a>你能做什么</h2><p>你可以通过 <code>NS_SWIFT_NAME</code> 做一些类似 apinote 机制的事情。你可以用这个宏来注释 C/Objective-C 头文件，表示在 Swift 里要用那个名字。编译器会对你的 <code>NS_SWIFT_NAME</code> 采用同样的替换（”如果看到 X，就调用 Y“）。</p>
<p>例如，这是一个 Intents(Siri) 框架中的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)resolveWorkoutNameForEndWorkout:(INEndWorkoutIntent *)intent</span><br><span class="line">                         withCompletion:(void (^)(INSpeakableStringResolutionResult *resolutionResult))completion</span><br><span class="line">     NS_SWIFT_NAME(resolveWorkoutName(forEndWorkout:with:));</span><br></pre></td></tr></table></figure>
<p>从 Objective-C 中调用它的话看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSObject&lt;INEndWorkoutIntentHandling&gt; *workout = ...;</span><br><span class="line"></span><br><span class="line">[workout resolveWorkoutNameForEndWorkout: intent  withCompletion: ^(INSpeakableStringResolutionResult) &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>而在 Swift 中是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let workout: INEndWorkoutIntentHandling = ...</span><br><span class="line">workout.resolveWorkoutName(forEndWorkout: workout) &#123;</span><br><span class="line">    response in</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NS_SWIFT_NAME</code>，和 Objective-C 中的轻量级泛型，nullability 注释，以及 Swift 编译器中的自动 Objective-C API 重命名一起，可以让你立刻有一种接口都回到 Swift 世界中的感觉。</p>
<p>使用自制的 overlay 和 apinote 是可以的，但那些原本是在 Swift 和 Apple 的 SDK 结合在一起时用的。你可以在你自己的框架中分发 apinote，但是 overlay 需要从 Swift 编译器树中编译。</p>
<p>为了自己创建更 Swift 的 API，你必须尽可能地做好头文件旁听（比如添加 nullability 注释和 NS_SWIFT_NAME），然后在你的项目中放一些 Swift 文件来伪造 overlay 以覆盖任何多余情况。这些 ”overlay” 文件在有 ABI 稳定性前都需要作为源文件传送。</p>
<p>轻掠过 iOS 10 头文件，看起来新的 API 喜欢用 <code>NS_SWIFT_NAME</code>，而老一点的更久远一些的 API 用 apinote。这样有一些道理因为这些头文件是在不同 Swift 版本中共享的，而给更久远的头文件可能添加新的 <code>NS_SWIFT_NAME</code> 可能会在编译器未改变的情况下破坏当前的代码。而且，apinote 可以由编译器团队或者社区成员添加，而头文件的改变需要拥有这个头文件的团队的注意。而那个团队可能已经准备好正要发布他们的功能了。</p>
<h2 id="它好吗？"><a href="#它好吗？" class="headerlink" title="它好吗？"></a>它好吗？</h2><p>Swift 3 版本的 Core Graphics 绝对是更优秀更加 Swift 化。老实说，我也想在 Objective-C 上这样用。你可能因此失掉一些可 Google 性，并且需要当你在 Stack Overflow 的文章或者网上的教程中看到现有的 CG 代码时做一些脑内转换。不过那也不必这些日子普通的 Swift 代码所需的脑力运动多多少。</p>
<p>有一些由于 CG 类似 OO 本质及其如何进入 Swift 中带来的 API 的不协调。在这个 <code>CoreGraphics.apinotes</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Name: CGBitmapContextGetWidth</span><br><span class="line">  SwiftName: getter:CGContext.width(self:)</span><br><span class="line">- Name: CGPDFContextBeginPage</span><br><span class="line">  SwiftName: CGContext.beginPDFPage(self:_:)</span><br></pre></td></tr></table></figure>
<p><code>CGBitmapContext</code> 和 <code>CGPDFContext</code> 方法都被 <code>CGContext</code> 偷去了。这意味着你可以对任何 <code>CGContext</code> 要它的宽度，或者叫它开始一个 PDF 页面。如果你找一个非位图 context 要它的宽，你会得到这样的运行时错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Error&gt;: CGBitmapContextGetWidth: invalid context 0x100e6c3c0.</span><br><span class="line">If you want to see the backtrace, please set CG_CONTEXT_SHOW_BACKTRACE environmental variable.</span><br></pre></td></tr></table></figure>
<p>因此即使这个 API 非常 Swift 化了，编译器并不能捕获某些类型的 API 错用。Xcode 会高高兴兴地给你其实实际上不合适的方法补全。某种意义上来说，C API 更安全一点，因为 <code>CGBitmapContextGetWidth</code> 很清楚地告诉你它要的是一个位图 context 即使第一个参数从技术上来说就还是一个 <code>CGContextRef</code>。我希望这仅仅是一个 bug （<a href="https://openradar.appspot.com/radar?id=6161102635270144" target="_blank" rel="external">rdar://27626070</a>）。</p>
<p>如果你想了解更多想超级重命名以及像 NS_SWIFT_NAME 这样的工具，看看这个吧 <a href="https://developer.apple.com/videos/play/wwdc2016/403/" target="_blank" rel="external">WWDC 2016 Session 403 - iOS API Design Guidelines</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/dude-wheres-my-call/&quot;&gt;Dude, Where’s my Call?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想象有一天你正在给 Swift 编译器喂一些看起来无害的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// xcrun -sdk macosx swiftc -emit-executable cg.swift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import CoreGraphics&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let path = CGPathCreateMutable()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGPathMoveToPoint(path, nil, 0.0, 23.0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后一个冲击波打来：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cg.swift:7:12: error: &amp;apos;CGPathCreateMutable()&amp;apos; has been replaced by &amp;apos;CGMutablePath.init()&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;unknown&amp;gt;:0: note: &amp;apos;CGPathCreateMutable()&amp;apos; has been explicitly marked unavailable here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cg.swift:8:1: error: &amp;apos;CGPathMoveToPoint&amp;apos; has been replaced by instance method &amp;apos;CGMutablePath.moveTo(_:x:y:)&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;unknown&amp;gt;:0: note: &amp;apos;CGPathMoveToPoint&amp;apos; has been explicitly marked unavailable here&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它们哪儿去了？被重命名了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics，第三部分：线</title>
    <link href="http://chengkang.me/2017/05/25/core-graphics-part-3/"/>
    <id>http://chengkang.me/2017/05/25/core-graphics-part-3/</id>
    <published>2017-05-24T23:23:05.000Z</published>
    <updated>2017-05-24T23:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-three-lines/" target="_blank" rel="external">Core Graphics, Part 2: Contextually Speaking</a><br>看看上一篇吧：<a href="http://chengkang.me/2017/05/23/core-graphics-part-2/">【译】Core Graphics, 第二部分：说说 context （上下文）</a></p>
</blockquote>
<p>设想这样一条简单的线：就是连接两点的一条直像素序列。有一些有名的算法你可以用来自己做绘制，但是近些日子，我们有了工具箱来帮忙做繁杂的工作。在 Core Graphics 中，一条线就只是一种路径。路径对于许多 Core Graphics 的特性来说都是中心，下一回你会得知很多路径的信息。不过现在，先把线想成被描出轮廓（而非填充）的一系列线的片段。有一大堆普遍的 <code>GState</code> 参数能影响线（的颜色、宽度、阴影及形变），同样也有 GState 的值与绘制线有关。</p>
<p>你在这看到的所有线的图片都是用 GrafDemo 创建的。你可以在 <a href="https://github.com/markd2/GrafDemo" target="_blank" rel="external">GitHub</a> 上找到源码，这里使用的版本为”Release cg-pt3“。</p>
<a id="more"></a>
<p>这就是 Lines 窗口的样子，左边是 Objective-C 的 NSView，右边是 Swift 的 NSView。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-grafdemo-window.png" alt=""></p>
<p>回想一下，CG path 只是形状的描述。它们并不实际包含任何像素点。<code>GState</code> 控制着 path 实际上如何被渲染，在 view 里面、image 里面或者 PDF 里面也好，无论是被填充或者是描边。有四个 <code>GState</code> 属性专属于 stroked lines：Join，Miter Limit，End Cap 和 Dash。</p>
<h2 id="Join-的阴暗面"><a href="#Join-的阴暗面" class="headerlink" title="Join 的阴暗面"></a>Join 的阴暗面</h2><p><code>line join</code> 这个属性控制着当线转角时发生的事情，并且通过以下枚举值来描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum CGLineJoin &#123;</span><br><span class="line">    kCGLineJoinMiter       // default</span><br><span class="line">    kCGLineJoinRound</span><br><span class="line">    kCGLineJoinBevel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过以下调用来设置它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineJoin (context, kCGLineJoinMiter)</span><br></pre></td></tr></table></figure>
<p><code>miter join</code> （斜角连接）有一个凸出来的点。<code>round join</code> （圆角连接） 在链接的”膝关节“处有一个半圆，而 <code>bevel join</code> （斜切连接） 则是一个平的样子。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-joinstyles.png" alt=""></p>
<p>那条中间的白线是给 Quartz 的那个理想的路径。蓝色部分是这个 path 在特定 <code>GState</code> 状态下被描的轮廓，<code>GState</code> 提供了轮廓颜色、线宽和线属性。</p>
<p>这个图有两个线段连接处。在一个 path 中的所有线段都是用同一个 <code>line join</code> 值，所以如果你想混搭 <code>join</code> 类型，你需要在 context 中设置 <code>line join</code>，然后画一组线，设置 <code>line join</code> 为另一个值，然后画另一组线。你无法在一个绘制操作中混搭。</p>
<h2 id="秘诀就是-Limit"><a href="#秘诀就是-Limit" class="headerlink" title="秘诀就是 Limit"></a>秘诀就是 Limit</h2><p>圆角连接和斜切连接有些无聊。端点就是个圆，或者拐角处被切掉了。不过，斜角连接是酷的。斜角连接画的那个突出的部分的长度是根据那两条线夹角变化的：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-miterlimit-1.gif" alt=""></p>
<p>不过还是有一个问题——如果两条线的夹角非常锐的话，突出端可能变得相当长。有另外一个 GState 参数可以控制这个：Miter Limit。这是一个 CGFloat 值，它告诉 CG 什么时候该画这个突出斜角的东西，又或是该把这个连接处变成斜切的。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-miterlimit-2.gif" alt=""></p>
<p>Miter Limit API 很简单，假设你知道这个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetMiterLimit (context, 5.0);</span><br></pre></td></tr></table></figure>
<p>当在决定是斜角还是斜切时，Quartz 用 GState 中的 line width 来除它准备绘制的斜角的长度。超过了 miter limit 就意味着”使用斜切连接“。因为斜角的长度与线宽成比例（线越宽斜角越长），miter limit 实际上就与线宽无关了——这个关系被解除了。只要你把你的绘制代码调整到有优秀的斜角/斜切行为，你就不用担心线宽变不变了。</p>
<h2 id="嘿，嘿，他刚说了”屁股“"><a href="#嘿，嘿，他刚说了”屁股“" class="headerlink" title="嘿，嘿，他刚说了”屁股“"></a>嘿，嘿，他刚说了”屁股“</h2><p>你不仅可以控制连接处怎么样，也可以控制线的开头和末端是如何。这里是三个 Line Cap 样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum CGLineCap &#123;</span><br><span class="line">    kCGLineCapButt    // default</span><br><span class="line">    kCGLineCapRound</span><br><span class="line">    kCGLineCapSquare</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个改变 cap 样式的调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetLineCap (context, kCGLineCapButt)</span><br></pre></td></tr></table></figure>
<p>butt cap 不在线的末端画任何额外的东西。round cap 加上了一个半圆，square cap 则有一个半正方形在末端。这个额外部分的大小是和线宽成比例的。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-capitation.png" alt=""></p>
<p>和 line join 样式一样，你不能在一条线上混搭 cap 样式。</p>
<h2 id="冲破大风雪"><a href="#冲破大风雪" class="headerlink" title="冲破大风雪"></a>冲破大风雪</h2><p>line join 和 line cap 是从 PostScript 中继承来的，另一个很酷的属性也是：line dash。</p>
<p>line dash 是通过一个由”标记空间“的浮点数值组成的数组组指定的一个重复图形。元素零是这条虚线第一个部分的长度。元素一是要留的空白的大小。元素二是另一个线的长度，元素三是另一个空白，如此下去。这个模式一直循环到 CG （或者 PostScript）用光了这个数组的元素。</p>
<p>下面是一组线的组成部分的长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGFloat lengths[] = &#123; 12.0, 8.0, 6.0, 14.0, 16.0, 7.0 &#125;;</span><br></pre></td></tr></table></figure>
<p>以及其相关的线的模式：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-1.png" alt=""></p>
<p>下面是用这个模式画的一条线：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-2.png" alt=""></p>
<p>这里使用了斜角连接样式。因此两个角都是斜角连接。那个消失的下方的连接处是虚线图形在原本连接处有一个空白区域造成的。</p>
<p>虚线图形在线的第一个点初固定了：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-3.gif" alt=""></p>
<p>每一个独立的图形区间都有末端 cap 属性在做用着，因此在有一个虚线图形以及 cap 或者 butt 末端 cap 时，cap 可能互相重叠而形成一条实线。</p>
<h2 id="Set-Phasers-to-Stun"><a href="#Set-Phasers-to-Stun" class="headerlink" title="Set Phasers to Stun"></a>Set Phasers to Stun</h2><p>下面是你如何设置 line phase：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void CGContextSetLineDash (CGContextRef c,</span><br><span class="line">                           CGFloat phase,</span><br><span class="line">                           const CGFloat lengths[], size_t count)</span><br></pre></td></tr></table></figure>
<p>你传入一个长度数组以及这个数组中元素的个数（并不是它的字节长度），同时还有一个 phase 值。这个 phase 值告诉 Quartz 从哪儿开始使用这个模式。你可以通过用不同的 phase 值调用 <code>SetLineDash</code> 让这个虚线动起来。</p>
<p>下面是同样一条线，仅仅是 phase 被改变时的样子：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-phase-4.gif" alt=""></p>
<h2 id="一个-Swift-化的分段星球"><a href="#一个-Swift-化的分段星球" class="headerlink" title="一个 Swift 化的分段星球"></a>一个 Swift 化的分段星球</h2><p>Swift 尤其便于制定线分段，你仅仅需要直接用一个 CGFloat 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let phase = CGFloat(linePhaseSlider.floatValue)</span><br><span class="line">let lengths = [</span><br><span class="line">    dash0Slider.floatValue, space0Slider.floatValue,</span><br><span class="line">    dash1Slider.floatValue, space1Slider.floatValue,</span><br><span class="line">    dash2Slider.floatValue, space2Slider.floatValue</span><br><span class="line">].map &#123; CGFloat($0) &#125;</span><br><span class="line">CGContextSetLineDash (context, phase, lengths, lengths.count)</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 这一边，你需要用一个 NSNumbers 数组并且手动取出浮点值，或者维护一个 CGFloat 的 buffer。</p>
<p>简单说明一下：那个 floatValue 和 map 在一起是干什么的？这个数组需要是 CGFloat 类型。 NSSlider 并没有一种将其返回值表达成 CGFloat 的方式。一种选择是给 NSSlider 写一个 extension，用以将一个现有的 slider 值方法转换成 CGFloat。那样挺烦人的，并且你在和其他项目共享这段代码时得记得将它一起拖过来。你也可以将每一个每一个 slider floatValue 都转换了，不过那样就在视觉上很扰目，很难看清楚是哪一个 slider 在贡献它的值。通过获取一个 floatsValues 数组然后映射它们到 CGFloat，它仍然可读，并且 <code>CGContextSetLineDash</code> 得到了它想要的浮点类型。</p>
<h2 id="Construction-Zone"><a href="#Construction-Zone" class="headerlink" title="Construction Zone"></a>Construction Zone</h2><p>Core Graphics 提供了一系列用于创建 line path 的调用方法。</p>
<p>及时我还没有谈到 path API，如果你曾用过 <code>NSBezierPath</code> 的话，第一种形式应该多少有点熟悉：移动到一个点，然后添加一个新点作为新线段的末端，组成一条连续的线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"></span><br><span class="line">CGPathMoveToPoint (path, NULL, self.points[0].x, self.points[0].y);</span><br><span class="line"></span><br><span class="line">for (NSInteger i = 1; i &lt; kPointCount; i++) &#123;</span><br><span class="line">    CGPathAddLineToPoint (path, NULL, self.points[i].x, self.points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path);</span><br><span class="line">CGContextStrokePath (context);</span><br></pre></td></tr></table></figure>
<p><code>self.points</code> 返回的是一个 CGFloat 指针指向一个包含四个 CGPoints 的 C 数组。</p>
<p>Swift 形式非常相似。<code>points</code> 是一个原生 Swift CGFloat 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let path = CGPathCreateMutable()</span><br><span class="line"></span><br><span class="line">CGPathMoveToPoint (path, nil, points[0].x, points[0].y)</span><br><span class="line"></span><br><span class="line">for i in 1 ..&lt; points.count &#123;</span><br><span class="line">    CGPathAddLineToPoint (path, nil, points[i].x, points[i].y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path)</span><br><span class="line">CGContextStrokePath (context)</span><br></pre></td></tr></table></figure>
<p>下一种形式用到资格 CGPoints 数组，并且在内部进行了如你所见过的相同类型的循环。这也得到一个 path。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"></span><br><span class="line">CGPathAddLines (path, NULL, self.points, kPointCount);</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path);</span><br><span class="line">CGContextStrokePath (context);</span><br></pre></td></tr></table></figure>
<p>Swift 实现也还是差不多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let path = CGPathCreateMutable()</span><br><span class="line"></span><br><span class="line">CGPathAddLines (path, nil, self.points, self.points.count)</span><br><span class="line"></span><br><span class="line">CGContextAddPath (context, path)</span><br><span class="line">CGContextStrokePath (context)</span><br></pre></td></tr></table></figure>
<p>第三种画线方法是分别画出每一条线段。每一条线段有其自己的 end-cap，并且有相应的 line dash 应用在上面。在连接处不会有斜角连接出现，因为对 CG 来说并没有连接在一起的线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i = 0; i &lt; kPointCount - 1; i++) &#123;</span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line"></span><br><span class="line">    CGPathMoveToPoint (path, NULL, self.points[i].x, self.points[i].y);</span><br><span class="line">    CGPathAddLineToPoint (path, NULL, self.points[i + 1].x, self.points[i + 1].y);</span><br><span class="line"></span><br><span class="line">    CGContextAddPath (context, path);</span><br><span class="line">    CGContextStrokePath (context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 当然也是几乎一模一样，除了循环结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ..&lt; points.count - 1 &#123;</span><br><span class="line">    let path = CGPathCreateMutable()</span><br><span class="line">    CGPathMoveToPoint (path, nil, points[i].x, points[i].y)</span><br><span class="line">    CGPathAddLineToPoint (path, nil, points[i + 1].x, points[i + 1].y)</span><br><span class="line"></span><br><span class="line">    CGContextAddPath (context, path)</span><br><span class="line">    CGContextStrokePath (context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种形式也是绘制单独的线段。<code>CGContextStrokeLineSegements</code> 用到一个点对数组，并且以偶数点 X 作为开始到 X+1 作为结束画线段。因此，对于包含三个线段的，它从 0-&gt;1，2-&gt;3 以及 4-&gt;5 画线。GrafDemo 的数据并不是一个渐变形势，因此有一些数据重排的工作需要做。</p>
<p>Objective-C 这一边使用了一个堆栈缓冲区来维持这些点。如果有可能其大小变得巨大的话，使用动态大小的堆栈缓冲区时要当心。如果你预期有大量的点，可能要想着动态分配一些内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGPoint segments[kPointCount * 2];</span><br><span class="line">CGPoint *scan = segments;</span><br><span class="line"></span><br><span class="line">for (NSInteger i = 0; i &lt; kPointCount - 1; i++) &#123;</span><br><span class="line">    *scan++ = self.points[i];</span><br><span class="line">    *scan++ = self.points[i + 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Strokes points 0-&gt;1 2-&gt;3 4-&gt;5</span><br><span class="line">CGContextStrokeLineSegments (context, segments, kPointCount * 2);</span><br></pre></td></tr></table></figure>
<p>Swift 很相似，不过免除了要注意堆栈缓冲区的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var segments: [CGPoint] = []</span><br><span class="line"></span><br><span class="line">for i in 0 ..&lt; points.count - 1 &#123;</span><br><span class="line">    segments += [points[i]]</span><br><span class="line">    segments += [points[i + 1]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Strokes points 0-&gt;1 2-&gt;3 4-&gt;5</span><br><span class="line">CGContextStrokeLineSegments (context, segments, segments.count)</span><br></pre></td></tr></table></figure>
<h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>在进行总结之前的最后一点。Core Graphics 可以相当快，但它有一个问题就是在一个 path 中重叠线段的计算开销很高。当 Quartz 渲染一个 path，它不可能就说，”好吧，画这个线段。现在画这个线段。“而不管其他进程。想想一下你在画一个绿色半透明的线。如果你盲目的将线段互相画在其它各自之上，你可能会因为有一些图层的半透明绿色”颜料“重叠而得到深一些的颜色。在画一个线段之前，Quartz 需要搞清楚重叠的部分在哪一集不要重复绘制。</p>
<p>下面是将一组线作为一个 path 绘制或者作为多个线段绘制的效果：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2015/05/cg3-overlap.png" alt=""></p>
<p>注意看看当你有一大堆互相重叠的线时的表现——重叠部分的计算成本（相对于所有其它 Quartz 的工作）是大于 O(N) 的并且当有大量线段是变得相当高昂。</p>
<h2 id="下一次"><a href="#下一次" class="headerlink" title="下一次"></a>下一次</h2><p>都是关于 path 的。Path！Path！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-three-lines/&quot;&gt;Core Graphics, Part 2: Contextually Speaking&lt;/a&gt;&lt;br&gt;看看上一篇吧：&lt;a href=&quot;http://chengkang.me/2017/05/23/core-graphics-part-2/&quot;&gt;【译】Core Graphics, 第二部分：说说 context （上下文）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设想这样一条简单的线：就是连接两点的一条直像素序列。有一些有名的算法你可以用来自己做绘制，但是近些日子，我们有了工具箱来帮忙做繁杂的工作。在 Core Graphics 中，一条线就只是一种路径。路径对于许多 Core Graphics 的特性来说都是中心，下一回你会得知很多路径的信息。不过现在，先把线想成被描出轮廓（而非填充）的一系列线的片段。有一大堆普遍的 &lt;code&gt;GState&lt;/code&gt; 参数能影响线（的颜色、宽度、阴影及形变），同样也有 GState 的值与绘制线有关。&lt;/p&gt;
&lt;p&gt;你在这看到的所有线的图片都是用 GrafDemo 创建的。你可以在 &lt;a href=&quot;https://github.com/markd2/GrafDemo&quot;&gt;GitHub&lt;/a&gt; 上找到源码，这里使用的版本为”Release cg-pt3“。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics, 第二部分：说说 context （上下文）</title>
    <link href="http://chengkang.me/2017/05/24/core-graphics-part-2/"/>
    <id>http://chengkang.me/2017/05/24/core-graphics-part-2/</id>
    <published>2017-05-24T15:20:19.000Z</published>
    <updated>2017-05-24T15:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/" target="_blank" rel="external">Core Graphics, Part 2: Contextually Speaking</a><br>看看上一篇吧：<a href="http://chengkang.me/2017/05/23/core-graphics-part-1/">【译】Core Graphics，第一部分：序章</a></p>
</blockquote>
<p>context （上下文）就是 Quartz 的核心：你需要按照某种规范来与当前的 Core Graphics context 交互以真正绘制东西，因此熟悉它、它做什么以及为什么它是这样的是有益处的。</p>
<p>Core Graphics 里面一个基础的操作是创建一个 path。Path 是形状的数学描述。一个 path 可以是一个矩形，或一个圆、一个牛仔帽，或者甚至是泰姬陵。Path 可以用颜色填充——就是说，这个 path 中的所有的点都被设置成特定的颜色。Path 也可以画出轮廓（outlined），或者说叫描边（stroked）。这就像是用一支美术钢笔在路径周围画出一个轮廓。下面分别是一个只画出了轮廓的、一个只填充颜色的和一个既填充了黄色由描蓝边的帽子：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/12/hat-path.png" alt=""></p>
<a id="more"></a>
<p>你可以看到，实际的轮廓可以变得非常复杂。它可以是一种特定的颜色。（轮廓）线也可以有虚线图案。可以用粗线条描边也可以用细线。线的末端可以是方的或圆的，等等等等。有很多种属性。</p>
<p>如果你仔细研读 Core Graphics API，你并不会看到某个方法调用使用了所有的这些设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGStrokePath (path, fillColor, strokeColor, lineWidth, dashPattern, bloodType, endCap)</span><br></pre></td></tr></table></figure>
<p>相反，仅仅是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CGContextStrokePath(CGContextRef c)</span><br></pre></td></tr></table></figure>
<p>那，那些额外的值从哪儿来的？它们就从 context 中来。</p>
<h2 id="一桶零碎"><a href="#一桶零碎" class="headerlink" title="一桶零碎"></a>一桶零碎</h2><p>Context 维持着一堆关于绘制的全局状态，它们是一堆独立的值：</p>
<ul>
<li>current path</li>
<li>current fill 和 stroke colors</li>
<li>line width 和 pattern</li>
<li>line cap 和 join (miter) styles</li>
<li>alpha (transparency), antialiasing 和 blend mode</li>
<li>shadows</li>
<li>transformation matrix</li>
<li>text atrributes （文字属性） (font, size, matrix)</li>
<li>一些冷僻的东西比如 line flatness 和 interpolation quality</li>
<li>以及更多</li>
</ul>
<p>有很多状态量。Core Graphics 维持的状态量的全集并没有被写入文档，因此可能还有更多的设置项。不同种类的 context （比如，图片与 PDF）可能包含额外种类的数据。</p>
<p>不管什么时候当 Core Graphics 被告知要绘制什么东西时，比如“填充一条路径（path），”它都从当前的 context 中去找需要的那部分数据。根据 context 中包含什么，同样的一个代码序列可以有完全不同的结果。一方面，这很强大。一段泛型的绘制代码可以通过 context 改变得到不同的结果。另一方面，context 是一大堆全局状态，而全局状态很容易被无意中搞得乱七八糟。</p>
<p>比如说有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw orange square:</span><br><span class="line">    set color to orange in the current context</span><br><span class="line">    fill a rectangle</span><br></pre></td></tr></table></figure>
<p>你将得到一个橙色正方形。现在假设你还要绘制一个桃心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw red valentine:</span><br><span class="line">    set color to red in the current context</span><br><span class="line">    fill a valentine</span><br></pre></td></tr></table></figure>
<p>耶！一个红心。现在比如说你把画桃心的代码加到你的第一个方法里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">draw orange square:</span><br><span class="line">    set color to orange in the current context</span><br><span class="line">    draw red valentine</span><br><span class="line">    fill a rectangle</span><br></pre></td></tr></table></figure>
<p>你的矩形会是红色而不是橙色。为什么呢？绘制桃心的代码抢占了当前的绘制颜色。你填充矩形的时候那个颜色本来是橙色，但是现在是红的了。如何避免这样的 bug 呢？</p>
<p>有两种方式。一种是在改变状态之前将状态保存起来——如果你要改变全局颜色，保存现在的颜色，改变颜色，绘制，然后恢复之前的颜色。这样只有一两个参数的时候还行，但是如果你要改变很多的时候这个方法并不能扩大规模。还有一些设置项因为一些副作用被改变，因此你也得考虑它们。噢，然后其实在 Core Graphics 里是没法这么做的，因为根本没有当前 context 的 getter。抱歉咯。</p>
<h2 id="这些桶的栈（context-栈）"><a href="#这些桶的栈（context-栈）" class="headerlink" title="这些桶的栈（context 栈）"></a>这些桶的栈（context 栈）</h2><p>另外一种方式是在改变任何东西前保存<em>完整</em>的 context。保存 context，改变颜色或者线宽，绘制，然后恢复完整的 context。Core Graphics API 提供了保存和恢复当前 context 设置的方法。这些设置叫做 graphics state，或者是 GState。事实上，它在背后维持着一个 GStates 栈。</p>
<p>当你保存了当前 context 的设置，它们被压入一个栈中。每一个 context 都有一个栈。当你恢复 graphics state，之前保存的 GState 从栈中弹出来并且编程 context 当前的值。将桃心绘制代码这样修改可以修复“橙色矩形是红色”的 bug：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">draw red valentine:</span><br><span class="line">    save graphics state</span><br><span class="line">    set color to red in the current context</span><br><span class="line">    fill a valentine</span><br><span class="line">    restore graphics state</span><br></pre></td></tr></table></figure>
<p>然后。完整的绘制调用序列是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set color to orange in the current context</span><br><span class="line">save graphics state</span><br><span class="line">set color to red in the current context</span><br><span class="line">fill a valentine</span><br><span class="line">restore graphics state</span><br><span class="line">fill a rectangle</span><br></pre></td></tr></table></figure>
<p>下面是 GState 的改变：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/12/gstates.png" alt=""></p>
<h2 id="Core-Graphics-API"><a href="#Core-Graphics-API" class="headerlink" title="Core Graphics API"></a>Core Graphics API</h2><p>好了，在抽象层面还行，但是这些东西在你实际看到它时是什么样呢？并不完全如你所想。Core Graphics 是一个 Core Foundation 味道的 API。有很多 Core Foundation 的传统影响着 Core Graphics。最主要的古怪点在于 Core Foundation 对于用指针声明东西有一种莫名其妙的恐惧。结果就是用 Objective-C 中的 “Ref” 类型，比如 <code>CGContextRef</code> 或者 <code>CGColorRef</code>。这些其实是类型重定义之后隐藏了那颗星的指针。</p>
<p>以下是正确的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef currentContext = ....; // 实际上是个指针</span><br></pre></td></tr></table></figure>
<p>以下不正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef *currentContext = ...; // 指向指针的指针</span><br></pre></td></tr></table></figure>
<p>你的绘制代码很少会创建它在其中绘制的 context，而是使用当前 context。你可以在 iOS 中这样获取当前 context：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = UIGraphicsGetCurrentContext ();</span><br></pre></td></tr></table></figure>
<p>在 Desktop Cocoa，OS X 10.10 之前，用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = [NSGraphicsContext.currentContext graphicsPort]</span><br></pre></td></tr></table></figure>
<p>在 10.10 之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = [NSGraphicsContext.currentContext CGContext]</span><br></pre></td></tr></table></figure>
<h2 id="画啊，朋友！"><a href="#画啊，朋友！" class="headerlink" title="画啊，朋友！"></a>画啊，朋友！</h2><p>因为 CG API 是一个面对对象的 C API，方法都是根据它们所操作的“对象”命名的（比如，<code>CGColor</code> 或者 <code>CGContext</code>），并且方法的第一个参数如同 Objective-C 中的 reveiver。因此就是那个“对象”被这些调用改变。</p>
<p>例如，下面是一个画矩形轮廓的 CGContext 调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef context = ...;  // 参照上方对应平台的调用</span><br><span class="line">CGRect bounds = someView.bounds;</span><br><span class="line">CGContextStrokeRect (context, bounds);</span><br></pre></td></tr></table></figure>
<p>（想了解更多关于矩形的东西？这有两篇 <a href="https://www.bignerdranch.com/blog/rectangles-part-1/" target="_blank" rel="external">Part 1</a>, <a href="https://www.bignerdranch.com/blog/rectangles-part-2/" target="_blank" rel="external">Part 2</a>关于它们的文章。）</p>
<p><code>CGContextStrokeRect</code> 取 <code>CGContextRef</code> 作为第一个参数。这个方法的目的是画出一个特定矩形的轮廓。如果 context 是 image context，或者是用来在屏幕上渲染图形的 context，一个矩形这么多的像素会被设置成 context 当前的颜色（当前的线宽，样式，等等）。如果当前的 context 是 PDF context，那一些指令会被记录下来，在这个 PDF 将来被渲染的时候最终绘制出一个矩形。</p>
<h2 id="清洁-Context"><a href="#清洁-Context" class="headerlink" title="清洁 Context"></a>清洁 Context</h2><p>是时候来点拟真代码了。GrafDemo 是一个将会包含越来越多涉及 CG 各方面 demo 的 app。你可以在 <a href="https://github.com/markd2/GrafDemo" target="_blank" rel="external">GitHub</a> 上找到源码。当前版本在这里 <a href="https://github.com/markd2/GrafDemo/releases/tag/release-cg-pt2" target="_blank" rel="external">Release cg-pt2</a>。</p>
<p>GrafDemo 包含一个绘制了一个在白色背景上由粗蓝线包围的绿色圆形的 NSView，整个 view 由细黑边包围。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/12/good-vs-sloppy-drawing.png" alt=""></p>
<p>这段代码有两个版本：一个有良好的清洁的 GState，另一个没有。请注意在那个 sloppy 版本，蓝色粗线泄露并污染了边界。如果你实际运行这个程序，你会看到这两个 view 并排在一起。一个是 Objective-C 版本；另一个是 Swift 版本。</p>
<p>这个 view 的子类有一个 convenience 方法用来获取当前 context。这应该会让其转移到 iOS 时更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGContextRef) currentContext &#123;</span><br><span class="line">    return [NSGraphicsContext.currentContext graphicsPort];</span><br><span class="line">&#125; // 挡墙 context</span><br></pre></td></tr></table></figure>
<p>这个 view 的 <code>drawRect</code> 实现单纯地设置了描边和填充颜色，期望他们能被背景和边缘绘制方法给用上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawSloppily &#123;</span><br><span class="line">    CGContextRef context = self.currentContext;</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBStrokeColor (context, 0.0, 0.0, 0.0, 1.0); // Black</span><br><span class="line">    CGContextSetRGBFillColor (context, 1.0, 1.0, 1.0, 1.0); // White</span><br><span class="line"></span><br><span class="line">    [self drawSloppyBackground];</span><br><span class="line">    [self drawSloppyContents];</span><br><span class="line">    [self drawSloppyBorder];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背景和边缘的方法非常直接明了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawSloppyBackground &#123;</span><br><span class="line">    CGContextFillRect (self.currentContext, self.bounds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) drawSloppyBorder &#123;</span><br><span class="line">    CGContextStrokeRect (self.currentContext, self.bounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他们都假设 context 是像 <code>drawRect</code> 设置的那样。但是！问题来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawSloppyContents &#123;</span><br><span class="line">    CGContextRef context = self.currentContext;</span><br><span class="line"></span><br><span class="line">    CGRect innerRect = CGRectInset (self.bounds, 20, 20);</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBFillColor (context, 0.0, 1.0, 0.0, 1.0); // Green</span><br><span class="line">    CGContextFillEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBStrokeColor (context, 0.0, 0.0, 1.0, 1.0); // Blue</span><br><span class="line">    CGContextSetLineWidth (context, 6.0);</span><br><span class="line">    CGContextStrokeEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意颜色和线宽的改变。context 保持的是一些全局的状态，因此当前的填充和描边颜色，以及当前的线宽都被污染了。</p>
<h2 id="把我压进去，把你弹出来"><a href="#把我压进去，把你弹出来" class="headerlink" title="把我压进去，把你弹出来"></a>把我压进去，把你弹出来</h2><p>修复这个问题的方法就是在绘制内容前将 graphics context 压入栈。<code>CGContextSaveGState</code> 将当前的 graphics context、 state 的一份拷贝压入栈中。<code>CGContextRestoreGState</code> 从栈顶弹出并替换当前的 context。</p>
<p>下面是会保存 graphics state 的好一点的版本的内容绘制（代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawNiceContents &#123;</span><br><span class="line">    CGContextRef context = self.currentContext;</span><br><span class="line"></span><br><span class="line">    CGContextSaveGState (context); &#123;</span><br><span class="line">        CGRect innerRect = CGRectInset (self.bounds, 20, 20);</span><br><span class="line"></span><br><span class="line">        CGContextSetLineWidth (context, 6.0);</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBFillColor (context, 0.0, 1.0, 0.0, 1.0); // Green</span><br><span class="line">        CGContextFillEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBStrokeColor (context, 0.0, 0.0, 1.0, 1.0); // Blue</span><br><span class="line">        CGContextStrokeEllipseInRect (context, innerRect);</span><br><span class="line"></span><br><span class="line">    &#125; CGContextRestoreGState (context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过简单地包裹保存、恢复就阻止了这个方法污染其他的方法。</p>
<p>一点关于花括号的事情：这是我个人在有一些平衡的调用时的假模假式，比如说在保存和恢复 GState，或者锁定和解锁互斥。这样非常清楚什么是处在保护中的，并且让它很清楚地能在一眼看下来时被发现有一个保护伞存在，这比一堆左对齐的代码容易看见得多。它们实际上并非 Core Graphics API 的一部分。</p>
<h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><p>好了，那 Swift 怎么样？GrafDemo 有平行的 Objective-C 实现和 Swift 实现，因此随便选择你要研读哪一段示例代码吧。</p>
<p>幸运的是，用 Swift 写的 CG 的代码和它在 Objective-C 中一样，只是没有了结尾的分号。下面是 sloppy 内容绘制在 Swift 中的样子。<code>currentContext</code> 是一个返回当前绘制 context 的属性（稍后更多细节）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func drawSloppyContents() &#123;</span><br><span class="line">    let innerRect = CGRectInset(bounds, 20.0, 20.0)</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBFillColor (currentContext, 0.0, 1.0, 0.0, 1.0) // Green</span><br><span class="line">    CGContextFillEllipseInRect (currentContext, innerRect)</span><br><span class="line"></span><br><span class="line">    CGContextSetRGBStrokeColor (currentContext, 0.0, 0.0, 1.0, 1.0) // Blue</span><br><span class="line">    CGContextSetLineWidth (currentContext, 6.0)</span><br><span class="line">    CGContextStrokeEllipseInRect (currentContext, innerRect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Scope-的把戏"><a href="#Scope-的把戏" class="headerlink" title="Scope 的把戏"></a>Scope 的把戏</h2><p>不幸的是，我的小把戏在 Swift 中不管用：未经修饰的花括号对变成了一个闭包并造成了语法错误。一种方法是通过创建一个包含这个闭包的函数，并且用它来包裹保存和恢复 context。这个方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private func saveGState(drawStuff: () -&gt; ()) -&gt; () &#123;</span><br><span class="line">    CGContextSaveGState (currentContext)</span><br><span class="line">    drawStuff()</span><br><span class="line">    CGContextRestoreGState (currentContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及相关的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func drawNiceContents() &#123;</span><br><span class="line">    saveGState &#123;</span><br><span class="line">        let innerRect = CGRectInset(self.bounds, 20.0, 20.0)</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBFillColor (self.currentContext, 0.0, 1.0, 0.0, 1.0) // Green</span><br><span class="line">        CGContextFillEllipseInRect (self.currentContext, innerRect)</span><br><span class="line"></span><br><span class="line">        CGContextSetRGBStrokeColor (self.currentContext, 0.0, 0.0, 1.0, 1.0) // Blue</span><br><span class="line">        CGContextSetLineWidth (self.currentContext, 6.0)</span><br><span class="line">        CGContextStrokeEllipseInRect (self.currentContext, innerRect)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的缺点就是你必须使用 <code>self</code> 来在那个块里引用东西。我还没有决定是否要一直使用这个方法。</p>
<h2 id="获取-Context"><a href="#获取-Context" class="headerlink" title="获取 Context"></a>获取 Context</h2><p>获取 <code>CGContext</code> 在 iOS 和 OS X 10.10（以及之后）中相当简单。谢天谢地，Swift 舍弃了类型中的 ”Ref“ 部分，因此你只需要 CGContext。下面是如何在 iOS 中获取当前 context：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let context = UIGraphicsGetCurrentContext()</span><br></pre></td></tr></table></figure>
<p><code>context</code> 是推断类型 CGContext？。它可以为 nil 因为有可能当前没有 context。Objective-C 中 <code>UIGraphicsGetCurrentContext()</code> 返回一个 <code>CGContextRef</code>，因此这个转换是非常容易的。</p>
<p>OS X 10.10 中给 <code>NSGraphicsContext</code> 添加了一个 <code>CGContext</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let context = NSGraphicsContext.currentContext?.CGContext</span><br></pre></td></tr></table></figure>
<p>OS X 10.9 就没这么幸运。<code>NSGraphicsContext -graphicsPort</code> 的调用返回一个 <code>void*</code>。Swift 并没有让改变指针类型变得简单。下面是一个解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private var currentContext : CGContext? &#123;</span><br><span class="line">    get &#123;</span><br><span class="line">        // The 10.10 SDK provides a CGContext on NSGraphicsContext, but</span><br><span class="line">        // that&apos;s not available to folks running 10.9, so perform this</span><br><span class="line">        // violence to get a context via a void*.</span><br><span class="line">        // iOS can just use UIGraphicsGetCurrentContext.</span><br><span class="line"></span><br><span class="line">        let unsafeContextPointer = NSGraphicsContext.currentContext()?.graphicsPort</span><br><span class="line"></span><br><span class="line">        if let contextPointer = unsafeContextPointer &#123;</span><br><span class="line">            let opaquePointer = COpaquePointer(contextPointer)</span><br><span class="line">            let context: CGContextRef = Unmanaged.fromOpaque(opaquePointer).takeUnretainedValue()</span><br><span class="line">            return context</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，<code>unsafeContextPointer</code> 是一个 <code>UnsafeMutablePointer&lt;Void&gt;?</code>。如果它不为 nil，用一个 <code>COpaquePointer</code> 将其包裹起来。这只是为了你可以将它传入 <code>Unmanaged</code>。<code>Unmanaged</code> 可以使用这个指针的值，并且因为 <code>CGContext</code> 像 <code>NSObject</code> 一样有引用计数，使用 unretain 的值就将生命周期所有权转交给 ARC 了。<code>takeUnretained</code> 是说”嘿 ARC，这个值你管着吧。它现在是 unretain 的状态，并且可能在 autorelease 池放干时跑不见了。你想办法让它在需要的时候一直在吧。“</p>
<h2 id="联盟中的-GState"><a href="#联盟中的-GState" class="headerlink" title="联盟中的 GState"></a>联盟中的 GState</h2><p>这一次，你遇见了 Core Graphics context，这是一筐筐绘制属性。context 是一个不透明的结构，因此你并不知道里面潜藏着什么。也因为这个全局状态，以及有一些 Core Graphics 调用有副作用的事实（之后会看到，当 path 重新出现的时候），几乎不可能在改变绘制属性之前保存它们。</p>
<p>Core Graphics 有 graphics state 栈的概念，这也存在于 PostScript 中。你可以用 <code>CGContextSaveGState</code> 来将当前 graphics state 的一份拷贝压入栈并且可以通过 <code>CGContextRestoreGState</code> 弹出保存的状态有效地撤销任何对 context 的改变。有一些会污染 context 导致后续绘制出错的代码？用 Save/Restore 包裹把它起来。</p>
<p>Core Graphics 的代码在 Objective-C 和 Swift 中几乎一模一样。在 iOS 和 OS X 上业绩会一模一样，因此 Core Graphics 代码是在相对 Apple 生态系统中的其他部分中移植性相当好的。Swift 中唯一真正困难的是在 Mavericks 系统中从 Cocoa 将 <code>void*</code> 装换成 <code>CGContext</code> （基本上只是从内存地址 A 到内存地址 B 复制 4-8 位），因为 Swift 试图让程序员远离那些底层细节。如果你针对的是 Yosemite 及之后的版本，这就不是个问题了。</p>
<p>下一次：Lines！（是 Lines-爽-耶-开心-好玩-时间，而非 Lines-隐式-未展开的-可选值。）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-2-contextually-speaking/&quot;&gt;Core Graphics, Part 2: Contextually Speaking&lt;/a&gt;&lt;br&gt;看看上一篇吧：&lt;a href=&quot;http://chengkang.me/2017/05/23/core-graphics-part-1/&quot;&gt;【译】Core Graphics，第一部分：序章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;context （上下文）就是 Quartz 的核心：你需要按照某种规范来与当前的 Core Graphics context 交互以真正绘制东西，因此熟悉它、它做什么以及为什么它是这样的是有益处的。&lt;/p&gt;
&lt;p&gt;Core Graphics 里面一个基础的操作是创建一个 path。Path 是形状的数学描述。一个 path 可以是一个矩形，或一个圆、一个牛仔帽，或者甚至是泰姬陵。Path 可以用颜色填充——就是说，这个 path 中的所有的点都被设置成特定的颜色。Path 也可以画出轮廓（outlined），或者说叫描边（stroked）。这就像是用一支美术钢笔在路径周围画出一个轮廓。下面分别是一个只画出了轮廓的、一个只填充颜色的和一个既填充了黄色由描蓝边的帽子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.bignerdranch.com/assets/img/blog/2014/12/hat-path.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>【译】Core Graphics，第一部分：序章</title>
    <link href="http://chengkang.me/2017/05/23/core-graphics-part-1/"/>
    <id>http://chengkang.me/2017/05/23/core-graphics-part-1/</id>
    <published>2017-05-23T21:20:01.000Z</published>
    <updated>2017-05-23T21:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.bignerdranch.com/blog/core-graphics-part-1-in-the-beginning/" target="_blank" rel="external">Core Graphics, Part 1: In the Beginning - Mark Dalrymple</a></p>
</blockquote>
<p>Mac 和 iOS 开发者有许多不同的让东西显示在屏幕上的编程接口。UIKit 和 AppKit 有各种各样的 image、color 和 path 类。Core Animation 让你可以移动 layer。OpenGL 让你可以在三维空间渲染东西。SpriteKit 让你可以做动画。AVFoundation 让你可以播放视频。</p>
<p>Core Graphics，或者它在市场中被人熟知的名字“Quartz”，是这个平台上最老的图形相关 API 之一。Quartz 构建了大多数二维的东西的基础。想要画些图形，给它们填充上渐变并且加上阴影？用 Core Graphics。想要在屏幕上合成图片？Core Graphics 能解决。想要创建 PDF？还是 Core Graphics。</p>
<a id="more"></a>
<p>CG 是一个相当大的 API，包括了从基本的几何数据结构（例如：点、大小、向量和矩形）和用于操作它们的方法、用于将像素渲染进图片或者屏幕的东西，一直到事件处理。你可以用 CG 来创建“events taps”，它能帮你监听和操作应用中的事件流（鼠标点击、屏幕点击、任意键盘按键）。</p>
<p>好吧。最后一项是有点奇怪。为什么一个 graphics API 要处理用户事件呢？这啊和别的一样，还得从历史说起。而且了解一点历史也可以帮助理解为什么 CG 是那样工作的。</p>
<h2 id="历史中的-PostScript"><a href="#历史中的-PostScript" class="headerlink" title="历史中的 PostScript"></a>历史中的 PostScript</h2><p>从时间的迷雾往回看（二十世纪八十年代，Duran Duran 还在上升期时），graphic API 相比今天还非常初级。你能做的只有从有限的色盘中挑选颜色、绘制独立的像素点、连线和画一些基本的图形比如矩形和椭圆。你可以设置剪切范围来告诉别人，“嘿，这儿不能画，”而且有时候你会有一些不受控的特性比如调整线有多宽。经常会有一些“像素位块传输”的功能用于将像素块到处复制。Mac 上的 QuickDraw 有一个很酷的功能叫做 <code>regions</code>，它能让你创建任意形状的区域然后使用它们来绘制、剪切、绘制轮廓或者 hit -test。不过基本上，当时的 API 都是面向像素的。</p>
<p>1985 年，Apple 发布了 LaserWriter，一个是其链接的计算机价格两倍的打印机。它包含一个比其链接的计算机更强劲的微处理器，以及一个 12 倍的 RAM。归功于一个叫做 PostScript 的技术，这款打印机（在当时）制作出了魅力惊人的打印制品。</p>
<p>PostScript 是一个来自 Adobe 的基于栈的计算机语言，与 FORTH 类似。PostScript， 这种技术，是为了创建矢量图（艺术的数学描述）而非基于像素。在 LaserWriter 中内嵌了一个 PostScript 解释器，因此当 Mac 上的程序想要打印什么东西的时候，这个程序（或者某个打印机驱动）将会生成一段程序代码，将其载入打印机并执行。</p>
<p>下面是一个 PostScript 代码的例子以及结果图像：</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/postscript-code.png" alt=""></p>
<p>你可以在 <a href="https://github.com/markd2/CGPS" target="_blank" rel="external">Github</a> 上找到这个项目。</p>
<p>将页面用代码形式来展现是一个非常重要的设计上的决策。这使得程序可以以算法的形式展现页面中的内容，因此用于执行这段程序的设备能够用其最大分辨率来绘制页面。对于当时大多数打印机，这个值是 300dpi。对于其他的，1200dpi。它们都是由同样的生成的程序绘制的。</p>
<p>除了渲染页面，PostScript 是图灵完备的，并且可以被当作通用编程语言。你甚至可以用它写 Web Server。</p>
<h2 id="Companion-CuBEs"><a href="#Companion-CuBEs" class="headerlink" title="Companion CuBEs"></a>Companion CuBEs</h2><p>NeXT 工程师在设计他们的系统时，他们选择了 PostScript 作为渲染模型。Display PostScript，简称 DPS，扩展了 PostScript 模型，使其能够在窗口化的计算机显示器工作。不过其核心仍是一个 PostScript 解释器。NeXT 的应用可以用 PostScript 代码实现其屏幕绘制，并且用同一段代码进行打印。你同样也可以用 C 函数来包裹 postScript （使用一个叫 pswrap 的程序）以从应用代码中调用。</p>
<p>Display PostScript 是用户交互的基础。事件（鼠标、键盘、更新等等）通过 DPS 系统然后被分发到应用中去。</p>
<p>NeXT 并非当时唯一使用 PostScript 的窗口化系统。Sun 的 NeWS（除了名字像之外，和 NeXT 没有一点关系）也有一个用于驱动系统中用户交互的内嵌 PostScript 解释器。</p>
<h2 id="说说-Quartz"><a href="#说说-Quartz" class="headerlink" title="说说 Quartz"></a>说说 Quartz</h2><p>为什么 OS X 和 iOS 不用 Display PostScript？基本上是钱的原因。Adobe 收取 Display PostScript 证书费用。同时，Apple 也是有名的想要尽可能有更多他们自有的技术栈。通过实现 PostScript 绘制模型，但并不真正使用 PostScript，他们既避免了付证书费也有了 Core Graphics 的代码。</p>
<p>有一种普遍的说法是 Quartz 是“基于” PDF 的，在某种意义上的确如此。PDF 就是没有任意编程功能的 PostScript 绘制模型。Quartz 被设计成其 API 的典型使用和 PDF 本身支持的非常接近，以至于在这个平台上创建 PDF 几乎不费吹灰之力。</p>
<p>哪怕 Display PostScript 被 Quartz 取代了，同样的基本原理被保留下来了，包括事件处理。看看 Cocoa 栈轨迹的 18 帧吧。DPS 仍在！</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/stack-trace.png" alt=""></p>
<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>我会在接下来的几周讲到更多 Quartz 细节的各个方面，但是有一个重点是用于“画东西”的那段代码被从实际图形渲染中抽象出来了。“渲染”可以是“让东西在 NSView 中显示”，或者“让东西显示在 UIImage 里面”，甚至是“让东西显示在 PDF 中”。</p>
<p>你所有的 CG 绘制都在一个“context（上下文）”中执行，它是数据结构和用于控制如何绘制的方法的指针的集合。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/output.png" alt=""></p>
<p>Context 有很多种，比如（在 Mac 上）有 NSWindowGraphicsContext。这一特定 context 获取你的代码安排的绘制指令，然后在你的应用的地址空间里中一块共享内存里绘制出像素。这一段内存也与窗口服务器共享。窗口服务器将所有正在运行的应用的窗口表面样子一起展示在屏幕上。</p>
<p>另一种 CG Context 是一种图片 context。任何你运行的绘制代码都会将像素布置在一个位图图片中。你可以使用这个图片来绘入其它 context 中或者作为 PNG 或 JPEG 保存在文件系统。同样也有一个 PDF context。运行的绘制代码不会变成像素，而是变成了 PDF 命令并被存进一个文件中。此后，PDF查看器可以使用那些 PDF 命令来渲染成某种可以查看的东西。</p>
<p><img src="https://www.bignerdranch.com/assets/img/blog/2014/10/different-results.png" alt=""></p>
<h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>下一次，更近距离来看看 context，以及一些 Core Graphics 中的便捷 API。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.bignerdranch.com/blog/core-graphics-part-1-in-the-beginning/&quot;&gt;Core Graphics, Part 1: In the Beginning - Mark Dalrymple&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mac 和 iOS 开发者有许多不同的让东西显示在屏幕上的编程接口。UIKit 和 AppKit 有各种各样的 image、color 和 path 类。Core Animation 让你可以移动 layer。OpenGL 让你可以在三维空间渲染东西。SpriteKit 让你可以做动画。AVFoundation 让你可以播放视频。&lt;/p&gt;
&lt;p&gt;Core Graphics，或者它在市场中被人熟知的名字“Quartz”，是这个平台上最老的图形相关 API 之一。Quartz 构建了大多数二维的东西的基础。想要画些图形，给它们填充上渐变并且加上阴影？用 Core Graphics。想要在屏幕上合成图片？Core Graphics 能解决。想要创建 PDF？还是 Core Graphics。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Core Graphics" scheme="http://chengkang.me/tags/Core-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>react-native-lahk-marquee-label（跑马灯文字组件）</title>
    <link href="http://chengkang.me/2017/04/11/react-native-lahk-marquee-label/"/>
    <id>http://chengkang.me/2017/04/11/react-native-lahk-marquee-label/</id>
    <published>2017-04-11T17:33:17.000Z</published>
    <updated>2017-04-14T21:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>A react-native marquee label component.</p>
<p>一个 react-native 跑马灯文字组件。</p>
</blockquote>
<p>If you need a vertical marquee label, please use <a href="https://github.com/cheng-kang/react-native-lahk-marquee-label-vertical" target="_blank" rel="external">react-native-lahk-marquee-label-vertical</a>.</p>
<p><a href="https://badge.fury.io/js/react-native-lahk-marquee-label" target="_blank" rel="external"><img src="https://badge.fury.io/js/react-native-lahk-marquee-label.svg" alt="npm version"></a></p>
<h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ol>
<li><a href="#desc">Desc</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#props">Props</a></li>
<li><a href="#中文介绍">中文介绍</a></li>
</ol>
<h2 id="Desc"><a href="#Desc" class="headerlink" title="Desc"></a>Desc</h2><p><a href="#install">Skip this part, go to <strong>#Install</strong></a></p>
<p>I needed a marquee label in one of my recent project and I didn’t find a good one online, so I decided to create my own marquee label component.</p>
<p>I intended to make it work well on both iOS and Android, still there remains one thing in iOS which I cannot fix. I found that in <strong>iOS</strong>, when you use <code>View</code> component to wrap child components and don’t explicitly set the parent <code>View</code> component width (e.g. use <code>flex</code>), the parent <code>View</code> component will have the same width as it’s child. </p>
<p>It becomes a problem in this custom component because I use a child <code>View</code> component to wrap <code>Text</code> component in order to make the text expand and show in one line. I <strong>set the text containner <code>View</code> component size to be bigger than the <code>Text</code> so that it will not have multiple lines nor have the overflow text replaced by ellipsis.</strong> The default value of text container width is 1000, which is usually larger than the actual label width. This results in the problem mentioned above, the wrapper <code>View</code> width becomes 1000 also.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View <span class="class"><span class="keyword">class</span></span>=<span class="string">"marquee-label"</span>&gt;</span><br><span class="line">  &lt;View class="marquee-label-text-container"&gt;</span><br><span class="line">    &lt;Text class="marquee-label-text"&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>In Andorid, you can use both <code>width</code> or <code>flex</code> to layout the view.</li>
<li>In iOS, use <code>width</code> to layout the view. <code>flex</code> layout is not supported.</li>
</ul>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native-lahk-marquee-label</span><br></pre></td></tr></table></figure>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol>
<li>Import</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MarqueeLabel <span class="keyword">from</span> <span class="string">'react-native-lahk-marquee-label'</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>Use</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarqueeLabel</span><br><span class="line">  duration=&#123;<span class="number">8000</span>&#125;</span><br><span class="line">  text=&#123;<span class="string">'This is a Marquee Label.'</span>&#125;</span><br><span class="line">  textStyle=&#123;&#123; fontSize: <span class="number">13</span>, color: <span class="string">'white'</span> &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;MarqueeLabel</span><br><span class="line">  speed=&#123;<span class="number">250</span>&#125;</span><br><span class="line">  textStyle=&#123;&#123; fontSize: <span class="number">13</span>, color: <span class="string">'white'</span> &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  This is a Marquee Label.</span><br><span class="line">&lt;<span class="regexp">/MarqueeLabel&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ul>
<li><code>children</code>: string, the text to show in the marquee. Alternative to <code>text</code>.</li>
<li><code>text</code>: string, the text to show in the marquee. Alternative to <code>children</code>.</li>
<li><code>duration</code>: number(unit: millisecond), the duration for the marquee to run one round. e.g. 6000 (for 6 seconds a round). Alternative to <code>speed</code>.</li>
<li><code>speed</code>: number(unit: px/s, px per second), the speed of the marquee. Alternative to <code>duration</code>.</li>
<li><code>bgViewStyle</code>: stylesheet object, background view component custom styles.</li>
<li><code>textStyle</code>: stylesheet object, text component custom styles.</li>
<li><code>textContainerWidth</code>: number, text container component width. If the text is not shown in one line, increase this value.</li>
<li><code>textContainerHeight</code>: number, text container component height. If the text is not shown in one line, increase this value.</li>
<li><code>textContainerStyle</code>: stylesheet object, not recommended to use, text containner component custom style.</li>
</ul>
<h2 id="中文介绍"><a href="#中文介绍" class="headerlink" title="中文介绍"></a>中文介绍</h2><p><a href="#install">跳转到 <strong>#install</strong></a></p>
<p>我在一个项目中需要用到跑马灯，但是在网上没找到好用的。所以我就自己写了一个跑马灯的组件。</p>
<p>本来打算让它可以在 iOS 和 Android 平台上都好用的，不过还是在 iOS 平台上存在一个问题没法解决。</p>
<p>我发现在 iOS 平台上，当使用 <code>View</code> 组件来包裹子组件的时候，如果没有显示设置父级 <code>View</code> 组件的宽度（width 样式）（比如用 <code>flex</code> 布局），那么父级 <code>View</code> 组件的宽度会被自动设置成子组件的宽度。（至少当子组件比父组件宽度大时是这样的，另外一种情况我没有做试验。）</p>
<p>我的跑马灯组件中的问题在于，我用了一个子级 <code>View</code> 组件来包裹 <code>Text</code> 组件以保证文字是在一行全部显示。<strong>通过将 text container 的宽度设置得比 <code>Text</code> 组件宽度大，保证了文字不会换行，也不会用省略号替换溢出文字。</strong> text container 默认宽度为 1000，这比一般的跑马灯标签实际宽度要大。而这也就导致了上述的问题，最外层的 <code>View</code> 的宽度也变成了 1000。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View <span class="class"><span class="keyword">class</span></span>=<span class="string">"marquee-label"</span>&gt;</span><br><span class="line">  &lt;View class="marquee-label-text-container"&gt;</span><br><span class="line">    &lt;Text class="marquee-label-text"&gt;&#123;text&#125;&lt;/Text&gt;</span><br><span class="line">  &lt;/View&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>因此要注意：</strong></p>
<ul>
<li>在 Android 平台上，通过 <code>width</code> 或者 <code>flex</code> 布局来设置最外层 <code>View</code> 的样式都没问题。</li>
<li>在 iOS 平台上，请使用并且只能使用 <code>width</code> 来设置样式。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A react-native marquee label component.&lt;/p&gt;
&lt;p&gt;一个 react-native 跑马灯文字组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you need a vertical marquee 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DoubanFMPlayer, A mimic of Douban.fm player</title>
    <link href="http://chengkang.me/2017/02/03/DoubanFMPlayer,%20A%20mimic%20of%20Douban.fm%20player/"/>
    <id>http://chengkang.me/2017/02/03/DoubanFMPlayer, A mimic of Douban.fm player/</id>
    <published>2017-02-03T22:31:30.000Z</published>
    <updated>2017-02-12T19:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Project Page: <a href="https://github.com/cheng-kang/DoubanFMPlayer" target="_blank" rel="external">https://github.com/cheng-kang/DoubanFMPlayer</a></p>
</blockquote>
<p>A mimic of Douban.fm player on <a href="https://douban.fm/" target="_blank" rel="external">Douban.fm</a>. <em>Also a Flex practice project.</em></p>
<p>You can use it on your website or <strong>embed it in your Hexo theme</strong>.</p>
<h2 id="Showcase"><a href="#Showcase" class="headerlink" title="Showcase"></a>Showcase</h2><p>Click <a href="http://chengkang.me/DoubanFMPlayer/">here</a> to check live demo.</p>
<h3 id="Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page"><a href="#Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page" class="headerlink" title="Dark Theme (the color of the player is dark, used in light color web page)"></a>Dark Theme (the color of the player is dark, used in light color web page)</h3><p><img src="https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-1.gif" alt=""></p>
<h3 id="Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page"><a href="#Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page" class="headerlink" title="Light Theme (the color of the player is light, used in dark color web page)"></a>Light Theme (the color of the player is light, used in dark color web page)</h3><p><img src="https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-2.gif" alt=""></p>
<a id="more"></a>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>Feel free to download source code from <code>/src</code> folder.</p>
<p>Alternatively, use the cdn I’ve set up:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbfmplayer.js: http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js</span><br><span class="line">dbfmplayer.css: http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.css</span><br></pre></td></tr></table></figure></p>
<h3 id="1-Use-it-on-your-website"><a href="#1-Use-it-on-your-website" class="headerlink" title="1. Use it on your website"></a>1. Use it on your website</h3><ol>
<li><p>Add any numbers of <code>dbfmplayer</code> tag to your HTML file.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dbfmplayer </span><br><span class="line">    title=&quot;茜さす 帰路照らされど…&quot; </span><br><span class="line">    singer=&quot;椎名林檎&quot;</span><br><span class="line">    album=&quot;https://img1.doubanio.com/lpic/s2722629.jpg&quot;</span><br><span class="line">    music=&quot;http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4&quot;</span><br><span class="line">&gt;&lt;/dbfmplayer&gt;</span><br></pre></td></tr></table></figure>
<p> You <strong>must</strong> set <code>title</code>, <code>singer</code>, <code>album</code> and <code>music</code> attributes of your <code>dbfmplayer</code> tags.</p>
<ul>
<li><code>title</code>: name of the music</li>
<li><code>singer</code>: name of the singer/musician</li>
<li><code>album</code>: URL of a picture related to this music (both absolute URL or relative URL)</li>
<li><p><code>music</code>: URL of the music (both absolute URL or relative URL)</p>
<p><strong>Optional</strong> attributes are <code>theme</code> and <code>loop</code>.</p>
</li>
<li><p><code>theme</code>: “dark” or “light”. Default theme is “dark”, which is suitable for light color background web pages; theme “light” is suitable for dark color background web pages.</p>
</li>
<li><code>loop</code>: “true” or “false”. Default value is “false”. If <code>loop</code> is set to “true”, the music will loop after it ends.</li>
<li><p><code>autoplay</code>: “true” or “false”. Default value is “false”. If <code>autoplay</code> is set to “true”, the music will automatically start when it’s loaded.</p>
<p>You can set <code>loop</code> and <code>autoplay</code> to “true” in a convenient way:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dbfmplayer </span><br><span class="line">    title=&quot;茜さす 帰路照らされど…&quot; </span><br><span class="line">    singer=&quot;椎名林檎&quot;</span><br><span class="line">    album=&quot;https://img1.doubanio.com/lpic/s2722629.jpg&quot;</span><br><span class="line">    music=&quot;http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4&quot;</span><br><span class="line">    loop</span><br><span class="line">    autoplay</span><br><span class="line">&gt;&lt;/dbfmplayer&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Add the following script to your HTML file.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123; // DON&apos;T EDIT BELOW THIS LINE</span><br><span class="line">    var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = &apos;http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js&apos;;</span><br><span class="line">    (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-Embed-it-in-your-Hexo-theme"><a href="#2-Embed-it-in-your-Hexo-theme" class="headerlink" title="2. Embed it in your Hexo theme"></a>2. Embed it in your Hexo theme</h3><ol>
<li><p>Add the following script to your layout file for <strong>Post</strong> (or anywhere else you want):</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123; // DON&apos;T EDIT BELOW THIS LINE</span><br><span class="line">    var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">    s.src = &apos;http://7u2sl0.com1.z0.glb.clouddn.com/dbfmplayer.js&apos;;</span><br><span class="line">    (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now users can add music to their page by adding the <code>dbfmplayer</code> tag to their articles (markdown files) by following <a href="#1-use-it-on-your-website">1.1 Add any numbers of <code>dbfmplayer</code> tag to your HTML file.</a>. </p>
</li>
</ol>
<h2 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h2><p>Most SVG icons come from <a href="https://icomoon.io/" target="_blank" rel="external">Iconmoon.io</a>.</p>
<p>Designed by <a href="https://douban.fm" target="_blank" rel="external">Douban.fm</a>.</p>
<h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p><strong>All copyright of the design belongs to who creates it.</strong> </p>
<p>Any copyright issue, please contact <a href="mailto:hi@chengkang.me">hi@chengkang.me</a>.</p>
<dbfmplayer title="茜さす 帰路照らされど…" singer="椎名林檎" album="https://img1.doubanio.com/lpic/s2722629.jpg" music="http://mr3.doubanio.com/ff7730a714d4e3ecbf3f5854f6154532/0/fm/song/p1033017_128k.mp4" theme="dark" loop autoplay></dbfmplayer>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Project Page: &lt;a href=&quot;https://github.com/cheng-kang/DoubanFMPlayer&quot;&gt;https://github.com/cheng-kang/DoubanFMPlayer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A mimic of Douban.fm player on &lt;a href=&quot;https://douban.fm/&quot;&gt;Douban.fm&lt;/a&gt;. &lt;em&gt;Also a Flex practice project.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You can use it on your website or &lt;strong&gt;embed it in your Hexo theme&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Showcase&quot;&gt;&lt;a href=&quot;#Showcase&quot; class=&quot;headerlink&quot; title=&quot;Showcase&quot;&gt;&lt;/a&gt;Showcase&lt;/h2&gt;&lt;p&gt;Click &lt;a href=&quot;http://chengkang.me/DoubanFMPlayer/&quot;&gt;here&lt;/a&gt; to check live demo.&lt;/p&gt;
&lt;h3 id=&quot;Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page&quot;&gt;&lt;a href=&quot;#Dark-Theme-the-color-of-the-player-is-dark-used-in-light-color-web-page&quot; class=&quot;headerlink&quot; title=&quot;Dark Theme (the color of the player is dark, used in light color web page)&quot;&gt;&lt;/a&gt;Dark Theme (the color of the player is dark, used in light color web page)&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page&quot;&gt;&lt;a href=&quot;#Light-Theme-the-color-of-the-player-is-light-used-in-dark-color-web-page&quot; class=&quot;headerlink&quot; title=&quot;Light Theme (the color of the player is light, used in dark color web page)&quot;&gt;&lt;/a&gt;Light Theme (the color of the player is light, used in dark color web page)&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/DoubanFMPlayer/master/DBFMPlayer-2.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Examples to understand how to find Nash equilibrium by eliminating “dominated strategies”</title>
    <link href="http://chengkang.me/2017/01/18/Examples%20to%20understand%20how%20to%20find%20Nash%20equilibrium%20by%20eliminating%20%E2%80%9Cdominated%20strategies%E2%80%9D/"/>
    <id>http://chengkang.me/2017/01/18/Examples to understand how to find Nash equilibrium by eliminating “dominated strategies”/</id>
    <published>2017-01-18T17:14:22.000Z</published>
    <updated>2017-01-18T17:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>This is a summarization of contents from two different sources. It aims at helping people (at least myself) to understand what <code>dominated strategies</code> are and especially what <strong>weakly dominated strategy</strong> is.</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Suppose <em>si</em> and <em>s’i</em> are two strategies for player <em>i</em> in a normal form game.</p>
<p>We say <em>s’i</em> is <strong>strictly dominated</strong> by <em>si</em> if, for every choice of strategies of the other players, <em>i</em>’s payoff from choosing <em>si</em> is <code>strictly greater than</code> <em>i</em>’s payoff from choosing <em>s’i</em>.</p>
<p>We call <em>s’i</em> dominated strategy and <em>si</em> dominant strategy.</p>
<p>We say <em>s’i</em> is <strong>weakly dominated</strong> by <em>si</em> if, for every choice of strategies of the other players, <em>i</em>’s payoff from chossing <em>si</em> is <code>at least as great as</code> <em>i</em>’s payoff from choosing <em>s’i</em>.</p>
<a id="more"></a>
<h2 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h2><ol>
<li>If a unique strategy remains for the player, we call this the player’s dominant strategy.</li>
<li>If a unique strategy remains for all players, we call this strategy profile a dominant<br>strategy equilibrium.</li>
<li>A dominant strategy equilibrium is a Nash equilibrium. And we can eliminate<br>dominated strategies without losing any Nash equilibria.</li>
<li>If the iterated elimination of weakly dominated strategies leaves exactly one strategy<br>for each player, the resulting strategy profile is a Nash equilibrium. <strong>However some Nash equilibria can be discarded this way.</strong></li>
</ol>
<h2 id="Example-of-eliminating-strictly-dominated-strategies"><a href="#Example-of-eliminating-strictly-dominated-strategies" class="headerlink" title="Example of eliminating strictly dominated strategies"></a>Example of eliminating strictly dominated strategies</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">Agent2</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">L</td>
<td style="text-align:center">C</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center"><strong>Agent1</strong></td>
<td style="text-align:center">T</td>
<td style="text-align:center">73, 25</td>
<td style="text-align:center">57, 42</td>
<td style="text-align:center">66,32</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">80, 26</td>
<td style="text-align:center">35, 12</td>
<td style="text-align:center">32,54</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:center">28, 27</td>
<td style="text-align:center">63, 31</td>
<td style="text-align:center">54,29</td>
</tr>
</tbody>
</table>
<p>L can be eliminated since it is strictly dominated by R, and then M can be eliminated since it is strictly dominated by both T and B, and then R can be eliminated since it is strictly dominated by C. Now Agent1 will choose B, which will result in a payoff of <strong>63, 31</strong>.</p>
<h2 id="Example-of-eliminating-weakly-dominated-strategies"><a href="#Example-of-eliminating-weakly-dominated-strategies" class="headerlink" title="Example of eliminating weakly dominated strategies"></a>Example of eliminating weakly dominated strategies</h2><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">Agent2</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">L</td>
<td style="text-align:center">R</td>
</tr>
<tr>
<td style="text-align:center"><strong>Agent1</strong></td>
<td style="text-align:center">T</td>
<td style="text-align:center">1, 1</td>
<td style="text-align:center">0, 0</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">M</td>
<td style="text-align:center">1, 1</td>
<td style="text-align:center">2, 1</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">B</td>
<td style="text-align:center">0, 0</td>
<td style="text-align:center">2, 1</td>
</tr>
</tbody>
</table>
<p>This example illustrates the difficulties that may occur when eliminating weakly dominated strategies.</p>
<p>The actions that survive iterated elimination of weakly dominated strategiescan depend on the order in which the actions are eliminated.</p>
<ol>
<li><p>For example, T can be eliminated since it is weakly dominated by M,and then L can be eliminated since it is weakly dominated by R. Now, agent2 will choose action R, which will result in a payoff of <strong>(2, 1)</strong> for which ever action agent 1 selects.</p>
</li>
<li><p>On the other hand, action B could have been eliminated first since it is weakly dominated by M, and then R could have been eliminated since it is weakly dominated by L. Now, the payoff is <strong>(1, 1)</strong> for which ever action agent 1 selects.</p>
</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1]<a href="http://tuvalu.santafe.edu/~jkchoi/ch2_a.pdf" target="_blank" rel="external">Leading fromStrength: Eliminating Dominated Strategies</a></p>
<p>[2]<a href="https://cs.uwaterloo.ca/~klarson/teaching/F08-886/WeaklyDominatedStrats.pdf" target="_blank" rel="external">Weakly Dominated Strategies</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This is a summarization of contents from two different sources. It aims at helping people (at least myself) to understand what &lt;code&gt;dominated strategies&lt;/code&gt; are and especially what &lt;strong&gt;weakly dominated strategy&lt;/strong&gt; is.&lt;/p&gt;
&lt;h2 id=&quot;Definition&quot;&gt;&lt;a href=&quot;#Definition&quot; class=&quot;headerlink&quot; title=&quot;Definition&quot;&gt;&lt;/a&gt;Definition&lt;/h2&gt;&lt;p&gt;Suppose &lt;em&gt;si&lt;/em&gt; and &lt;em&gt;s’i&lt;/em&gt; are two strategies for player &lt;em&gt;i&lt;/em&gt; in a normal form game.&lt;/p&gt;
&lt;p&gt;We say &lt;em&gt;s’i&lt;/em&gt; is &lt;strong&gt;strictly dominated&lt;/strong&gt; by &lt;em&gt;si&lt;/em&gt; if, for every choice of strategies of the other players, &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;si&lt;/em&gt; is &lt;code&gt;strictly greater than&lt;/code&gt; &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;s’i&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We call &lt;em&gt;s’i&lt;/em&gt; dominated strategy and &lt;em&gt;si&lt;/em&gt; dominant strategy.&lt;/p&gt;
&lt;p&gt;We say &lt;em&gt;s’i&lt;/em&gt; is &lt;strong&gt;weakly dominated&lt;/strong&gt; by &lt;em&gt;si&lt;/em&gt; if, for every choice of strategies of the other players, &lt;em&gt;i&lt;/em&gt;’s payoff from chossing &lt;em&gt;si&lt;/em&gt; is &lt;code&gt;at least as great as&lt;/code&gt; &lt;em&gt;i&lt;/em&gt;’s payoff from choosing &lt;em&gt;s’i&lt;/em&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Game Theory" scheme="http://chengkang.me/tags/Game-Theory/"/>
    
      <category term="Dominated Strategies" scheme="http://chengkang.me/tags/Dominated-Strategies/"/>
    
  </entry>
  
  <entry>
    <title>QnA，一个 Hexo FAQ 主题</title>
    <link href="http://chengkang.me/2017/01/14/QnA%EF%BC%8C%E4%B8%80%E4%B8%AA%20Hexo%20FAQ%20%E4%B8%BB%E9%A2%98/"/>
    <id>http://chengkang.me/2017/01/14/QnA，一个 Hexo FAQ 主题/</id>
    <published>2017-01-14T11:47:03.000Z</published>
    <updated>2017-01-14T12:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前在 Gitbook 上创建了一个 FAQ 网站，但是 Gitbook 使用起来偏麻烦，而且主题不好看。预期创建一个 Gitbook 主题，不如创建一个 Hexo 主题，然后将网站部署到 Github 上。于是我便动手制作了这个主题。</p>
<p>这个主题的最初目的是为了服务这个网站 <a href="http://chengkang.me/Swift-Newbie/">Swift Newbie: 给 Swift 新手的知识库</a>，对 Swift 学习感兴趣的同学可以点开看看，有意贡献的同学可以联系我 <code>hi@chengkang.me</code>。</p>
<p>项目主页：<a href="https://github.com/cheng-kang/hexo-theme-qna" target="_blank" rel="external">《Theme QnA for Hexo》</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cheng-kang/hexo-theme-qna/master/QnA.png" alt=""></p>
<p>为 Hexo 设计的『知识库』类主题。</p>
<a id="more"></a>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="./Documentation.md">Documentation English Version</a></li>
</ul>
<h2 id="展示"><a href="#展示" class="headerlink" title="展示:"></a>展示:</h2><ul>
<li><a href="http://chengkang.me/hexo-theme-qna/">预览</a></li>
<li><a href="http://chengkang.me/Swift-Newbie/">Swift Newbie: 给 Swift 新手的知识库</a></li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/cheng-kang/hexo-theme-qna.git themes/QnA</span><br></pre></td></tr></table></figure>
<h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3><p>修改根目录中 <code>_config.yml</code> 的 <code>theme</code> 为 <code>QnA。</code></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/QnA</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="发布到-Github"><a href="#发布到-Github" class="headerlink" title="发布到 Github"></a>发布到 Github</h3><p>安装 Hexo 插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>编辑你 Hexo 博客根目录中的 <code>_config.yml</code> 文件。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> git</span><br><span class="line"><span class="attr">  repo:</span> &lt;repository url&gt; <span class="comment"># https://github.com/cheng-kang/hexo-theme-qna.git</span></span><br><span class="line"><span class="attr">  branch:</span> [branch] <span class="comment"># master</span></span><br></pre></td></tr></table></figure>
<h3 id="启用中文站内搜索"><a href="#启用中文站内搜索" class="headerlink" title="启用中文站内搜索"></a>启用中文站内搜索</h3><blockquote>
<p>QnA 默认只支持英文站内搜索。</p>
</blockquote>
<p>安装 Hexo 插件 <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="external">hexo-generator-search</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<h3 id="添加新页面"><a href="#添加新页面" class="headerlink" title="添加新页面"></a>添加新页面</h3><ol>
<li><p>添加一个新页面，例如：about 页面。改变页面内容请修改根目录下 source/about/index.md 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page about</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 theme/QnA 中的 <code>_config.yml</code>。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> /</span><br><span class="line"><span class="attr">  Archive:</span> /archives</span><br><span class="line">  <span class="comment"># Add new page config here</span></span><br><span class="line">  <span class="comment"># Page Dispay Name: /pagename</span></span><br><span class="line">  <span class="comment"># e.g.</span></span><br><span class="line"><span class="attr">  About:</span> /about</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前在 Gitbook 上创建了一个 FAQ 网站，但是 Gitbook 使用起来偏麻烦，而且主题不好看。预期创建一个 Gitbook 主题，不如创建一个 Hexo 主题，然后将网站部署到 Github 上。于是我便动手制作了这个主题。&lt;/p&gt;
&lt;p&gt;这个主题的最初目的是为了服务这个网站 &lt;a href=&quot;http://chengkang.me/Swift-Newbie/&quot;&gt;Swift Newbie: 给 Swift 新手的知识库&lt;/a&gt;，对 Swift 学习感兴趣的同学可以点开看看，有意贡献的同学可以联系我 &lt;code&gt;hi@chengkang.me&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/cheng-kang/hexo-theme-qna&quot;&gt;《Theme QnA for Hexo》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/hexo-theme-qna/master/QnA.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为 Hexo 设计的『知识库』类主题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DanmuManager 一个简单的弹幕工具</title>
    <link href="http://chengkang.me/2017/01/05/DanmuManager%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%B9%E5%B9%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://chengkang.me/2017/01/05/DanmuManager 一个简单的弹幕工具/</id>
    <published>2017-01-05T18:14:32.000Z</published>
    <updated>2017-01-05T13:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目首页： <a href="https://github.com/cheng-kang/DanmuManager" target="_blank" rel="external">DanmuManager Github Repository</a></p>
</blockquote>
<h2 id="使用方法-Usage"><a href="#使用方法-Usage" class="headerlink" title="使用方法 Usage"></a>使用方法 Usage</h2><p><code>DanmuManager</code> 和 <code>VideoDanmuManager</code> 有不同的应用场景，后者用于视频弹幕。</p>
<p>你可以运行项目中的测试，来了解二者的使用方法。<br><a id="more"></a></p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-1.gif" width="200"><br><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-2.gif" width="200"><br><img src="https://raw.githubusercontent.com/cheng-kang/DanmuManager/master/DanmuManager-3.gif" width="200"></p>
<h3 id="DanmuManager"><a href="#DanmuManager" class="headerlink" title="DanmuManager"></a>DanmuManager</h3><ol>
<li><p>创建 DanmuManager</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let dm = DanmuManager(with: self.view)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>初始化 `init` 方法允许自定义： 

- `top`、`bottom`弹幕显示在 `view` 中的上下位置范围;
- `speed` 弹幕的速度;
- `customFont` 弹幕字体（`UIFont`, 包括字体家族和大小，默认为系统字体，字号 20）。
</code></pre><ol>
<li><p>添加一条弹幕 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dm.add(with: “Wow so cool!!!”, at: 4)</span><br></pre></td></tr></table></figure>
<p> 添加弹幕 <code>add</code> 方法有两个必传参数，<code>text</code>（弹幕文字） 和 <code>line</code>（弹幕所在行）;可选参数 <code>hasBorder</code> 用于设置该条弹幕是否有边框（默认 borderColor = UIColor.black.cgColor，borderWidth = 1）,默认值为 false;可选参数 <code>isAdvance</code> 用于设置该条弹幕是否开启高级功能（目前支持修改 文字颜色 和 背景颜色），默认值为 false。</p>
<p> 如果需要弹幕出现在随机行，可以使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func addRandom(with text: String = &quot;This is a test Danmu.&quot;, at line: Int = 0, hasBorder: Bool = false, isAdvanced: Bool = false)`。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>暂停/继续 弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dm.pause()</span><br><span class="line">dm.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以使用 `dm.toggle()` 来快捷切换 暂停/继续。
</code></pre><h3 id="VideoDanmuManager"><a href="#VideoDanmuManager" class="headerlink" title="VideoDanmuManager"></a>VideoDanmuManager</h3><ol>
<li><p>创建 VideoDanmuManager</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let vdm = VideoDanmuManager(view: self.view,</span><br><span class="line">                               videoLength: 10,</span><br><span class="line">                               danmuData: [</span><br><span class="line">                                   (3.4, &quot;3.4 Wowowowowowow!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 SOOOO COOOOOOOOOOL!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 Amazing!!!!&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 I love you~&quot;),</span><br><span class="line">                                   (3.4, &quot;3.4 MY BABY!!!!&quot;),</span><br><span class="line">                                   (1.1, &quot;1.1 This is a test Danmu!!!&quot;),</span><br><span class="line">                                   (2.0, &quot;2.0 Another test Danmu.&quot;),</span><br><span class="line">                                   (4.1, &quot;4.1 Amazing!!!!&quot;),</span><br><span class="line">                                   (6.1, &quot;6.1 Test!!!!&quot;),</span><br><span class="line">                                   (8.1, &quot;8.1 Test!!!!&quot;),</span><br><span class="line">                                   (9.1, &quot;9.1 Test!!!!&quot;),</span><br><span class="line">                                   (10, &quot;10 Test!!!!&quot;),</span><br><span class="line">           ],</span><br><span class="line">                               isSorted: false</span><br><span class="line">       )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>`VideoDanmuManager` 的创建有三个必选参数，`view`（显示弹幕的视图），`videoLength`（视频时长，精确到 0.1 秒）和 `danmuData`（已经存在的弹幕列表）。

可选参数 `videoCurrent` 默认为 0，即开始时刻；你可以通过传入不同的时间值来设置显示弹幕的初始时间（比如在视频从 1 分 15 秒开始播放，则应设置 `videoCurrent` 为 75）。
可选参数 `isSorted` 默认为 true，即默认数据集已经按照弹幕显示时间从先到后排序；如传入 false，则将自动调用 `func sort()` 对数据进行排序。

可选参数 `top` 和 `bottom` 同 `DanmuManager`。
</code></pre><ol>
<li><p>开启弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.start()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你需要在视频开始播放的同时，手动开启弹幕。
</code></pre><ol>
<li><p>暂停/继续 弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vdm.pause()</span><br><span class="line">vdm.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以使用 `vdm.toggle()` 来快捷切换 暂停/继续。
</code></pre><ol>
<li><p>中止弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.stop()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>重新开始弹幕</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.restart()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>你也可以在指定时间点重新开始弹幕：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdm.restart(at: 75)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p><code>DanmuManager</code> 通过设置的字体大小计算文本显示高度 <code>lineHeight</code>，通过 <code>numberOfLines = Int(floor((bottom - top) / lineHeight))</code> 得到可以显示的弹幕行数；使用 <code>inUsingLines</code>，<code>enteringTimers</code> 和 <code>waitingQueues</code> 来分别记录 正在使用的行（有尾部还没有完全进入视图的弹幕的行），正在进入视图的弹幕的计时器 和 正在等待进入的弹幕队列。</p>
<p>为了防止弹幕重叠，只有当 当前行中前一条弹幕尾部进入视图 时（之后），下一条弹幕才可以发射。</p>
<p><code>enteringTimers</code> 中每一个 Timer 都对应一条正在进入视图的弹幕，当计时器结束时，通过 NotificationCenter 发通知将该弹幕所在的行的状态更改为 false。</p>
<p>因为弹幕存在暂停状态，如果弹幕对应的 Timer 不同时暂停，将导致 弹幕所在行状态 提前更改为 false。为了解决这个问题，我参考他人的想法并改进后创建了 PauseableTimer，并在本项目中使用上了。我的另外一篇博客更详细地介绍了 <a href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/">《PauseableTimer》</a>。</p>
<p>为了避免手动发射弹幕和自动发射队列中的弹幕出现冲突（弹幕重叠），所有弹幕通过 <code>taskTimer</code> 定时任务统一调度。</p>
<h2 id="下一步-Next-Step"><a href="#下一步-Next-Step" class="headerlink" title="下一步 Next Step"></a>下一步 Next Step</h2><p>现在流行的弹幕功能越来越复杂、高级，DanmuManager 只是完成了最基础的滚动文字弹幕功能。未来可能会学习常见的弹幕，添加一些更高级的功能，比如 对滚动弹幕的操作，居中弹幕 等。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目首页： &lt;a href=&quot;https://github.com/cheng-kang/DanmuManager&quot;&gt;DanmuManager Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用方法-Usage&quot;&gt;&lt;a href=&quot;#使用方法-Usage&quot; class=&quot;headerlink&quot; title=&quot;使用方法 Usage&quot;&gt;&lt;/a&gt;使用方法 Usage&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DanmuManager&lt;/code&gt; 和 &lt;code&gt;VideoDanmuManager&lt;/code&gt; 有不同的应用场景，后者用于视频弹幕。&lt;/p&gt;
&lt;p&gt;你可以运行项目中的测试，来了解二者的使用方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Pauseable Timer 一个可暂停的计时器</title>
    <link href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    <id>http://chengkang.me/2017/01/05/PauseableTimer 一个可暂停的计时器/</id>
    <published>2017-01-05T15:31:35.000Z</published>
    <updated>2017-01-05T13:58:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>项目主页: <a href="https://github.com/cheng-kang/PauseableTimer" target="_blank" rel="external">PauseableTimer Github Repository</a><br>英文介绍： <a href="http://chengkang.me/2017/01/04/Pauseable%20Timer/">Pauseable Timer</a></p>
</blockquote>
<p>PauseableTimer 是一个用 Swift 写的可暂停的计时器。</p>
<p>有时候我们需要暂停计时器，但是这个功能在 Timer(Swift3) 中并没有被实现。因此，经过一些失败的尝试，我创建了这个可以暂停的计时器，希望对你也有用。</p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif" alt=""></p>
<a id="more"></a>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol>
<li><p>创建一个计时器 Timer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let timer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: aSelector, userInfo: nil, repeats: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个可暂停的计时器 PauseableTimer，并将之前创建的 Timer 作为参数传入 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let pauseableTimer = PauseableTimer(timer: timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停 然后 重新开始！</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">pauseableTimer.pause()</span><br><span class="line">pauseableTimer.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>如果用于初始化 PauseableTimer 的 Timer 不是通过 scheduledTimer 方法初始化的或没有被加入到 RunLoop 中，那么你需要手动将它加入到 RunLoop 中。你可以这样做，<code>RunLoop.current.add(timer, forMode: .commonModes)</code>。</li>
<li>如果你需要操作用于初始化 PauseableTimer 的 Timer 或者需要获取它的属性，请使用 PauseableTimer 的 <code>timer</code> 属性。就像这样，<code>pauseableTimer.timer.firedate = Date()</code>。</li>
<li><code>invalidate()</code> 方法是为便于手动让 timer 失效而创建的。</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PauseableTimer 并没有重新实现 Swift 中的 Timer，而是将 Timer 作为一个属性然后在它的帮助下实现了 暂停 的功能。</p>
<p>这个功能的原理受到 <a href="http://www.jianshu.com/p/e554a164d0da" target="_blank" rel="external">NSTimer 总结1(包括计时器不准的解决)</a> 的启发。 </p>
<p>主要思想是 <code>当你需要暂停的时候，将 Timer 的 firedate 设置为一个无法达到的日期（这样计时器会一直等待，感觉起来就像是暂停了 :D）；当你需要重新开始的时候，将 firedate 设置回原来的时间（这样计时器就可以『照常』触发）</code>。 </p>
<p>简单聪明！</p>
<p>你可能注意到了加了引号的『照常』。事实上，这个方法可能无法达到你的期望，因为</p>
<ol>
<li><p>Firedate 过期了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">现在的时间是 2017.01.04 10:25。</span><br><span class="line">原本的 firedate 是 2017.01.04 10:30。</span><br><span class="line">你现在暂停了这个计时器，并且在十分钟后（2017.01.04 10:35）重新开始。这时，计时器已经错过了它预计的 firedate（2017.01.04 10:30）。</span><br><span class="line">然而，如果这个计时器已经在 RunLoop 当中的话，当你在 2017.01.04 10:35 将 firedate 设置回 2017.01.04 10:30 时，计时器会立即触发一次。</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们希望计时器继续等待剩下的等待时间。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">现在的时间是 2017.01.04 10:25:00。</span><br><span class="line">计时器的 timeInterval 是 60 秒。现在计时器被加入到 RunLoop，它应该在 60 秒后触发，也就是在 2017.01.04 10:26:00。</span><br><span class="line">然后你因为某种原因在 10 秒后暂停了它，也就是在 2017.01.04 10:25:10。你在 2017.01.04 10:25:50 的时候重新开始了计时器。</span><br><span class="line">不过，你仍然希望它是在设置好后，等待 60 秒再触发，不管暂停的那段时间。所以它应该再等待 50 秒，然后在 2017.01.04 10:26:40 触发。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完美的解决方案应该是满足以上所述三种情况的（另一种情况是我们不在乎原始 firedate 是否过期）。不过，这个项目目前只解决了第二个情况，因为这是我在其他项目中所遇到的需要解决的问题。</p>
<p>未来我可能会继续这个小项目，然后将每一种情况的解决方案都完善起来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/cheng-kang/PauseableTimer&quot;&gt;PauseableTimer Github Repository&lt;/a&gt;&lt;br&gt;英文介绍： &lt;a href=&quot;http://chengkang.me/2017/01/04/Pauseable%20Timer/&quot;&gt;Pauseable Timer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PauseableTimer 是一个用 Swift 写的可暂停的计时器。&lt;/p&gt;
&lt;p&gt;有时候我们需要暂停计时器，但是这个功能在 Timer(Swift3) 中并没有被实现。因此，经过一些失败的尝试，我创建了这个可以暂停的计时器，希望对你也有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Pauseable Timer</title>
    <link href="http://chengkang.me/2017/01/04/Pauseable%20Timer/"/>
    <id>http://chengkang.me/2017/01/04/Pauseable Timer/</id>
    <published>2017-01-04T22:58:48.000Z</published>
    <updated>2017-01-05T13:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Project Page: <a href="https://github.com/cheng-kang/PauseableTimer" target="_blank" rel="external">PauseableTimer Github Repository</a></p>
<p>Chinese Version: <a href="http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/">《Pauseable Timer 一个可暂停的计时器》</a></p>
</blockquote>
<p>Pauseable Timer is a pause-able timer written in Swift.</p>
<p>There are occassions when we need timers to pause, however, this feature is not implemented in Timer(Swift3). Thus, after some failed attempts, I create this pause-able timer which hopefully could be useful to you.</p>
<p><img src="https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif" alt=""></p>
<a id="more"></a>
<h2 id="How-to-Use"><a href="#How-to-Use" class="headerlink" title="How to Use"></a>How to Use</h2><ol>
<li><p>Create a Timer</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let timer = Timer.scheduledTimer(timeInterval: 10, target: self, selector: aSelector, userInfo: nil, repeats: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a Pauseable Timer and pass the timer as an argument.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">let pauseableTimer = PauseableTimer(timer: timer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Pause and Resume!</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">pauseableTimer.pause()</span><br><span class="line">pauseableTimer.resume()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>Notice</strong></p>
<ul>
<li>If the timer you use to initialize a PauseableTimer is not scheduled (or added to RunLoop) already, you need to manually schedule it (ro add it to RunLoop). You can do it by <code>RunLoop.current.add(timer, forMode: .commonModes)</code>. </li>
<li>Use <code>timer</code> property of PauseableTimer if you need to manipulate the timer or get it’s properties. Like this <code>pauseableTimer.timer.firedate = Date()</code>.</li>
<li>A convinient method <code>invalidate()</code> is created to invalidate the timer.</li>
</ul>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Pauseable Timer does not re-implement Timer in Swift, but takes a Timer as a property and implement ‘Pause’ feature with the help of it.</p>
<p>The concept of this feature is inspired by <a href="http://www.jianshu.com/p/e554a164d0da" target="_blank" rel="external">NSTimer 总结1(包括计时器不准的解决)</a>. </p>
<p>The main idea is <code>set the firedate of Timer to a un-reachable date when you want it pause (the timer will wait until forever and you can take it as pausing :D), and set it back to its original firedate when you want it resume (and the timer will fire &quot;as expected&quot;).</code></p>
<p>Simple and Excellent!</p>
<p>You might have noticed the double qouted “as expected”. Acctually, this might fail your expectation because</p>
<ol>
<li><p>The firedate is expried.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">The current time is 2017.01.04 10:25.</span><br><span class="line">The original firedate is 2017.01.04 10:30.</span><br><span class="line">You pause the timer at this moment and resume it 10 mins after which is 2017.01.04 10:35. So the timer has missed it&apos;s expected firedate. </span><br><span class="line">However it will fire once you set the firedate back to 2017.01.04 10:30 at 2017.01.04 10:35, if the timer is already added to RunLoop.</span><br></pre></td></tr></table></figure>
</li>
<li><p>The timer is expected to wait for the remaining waiting time.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">The current time is 2017.01.04 10:25:00.</span><br><span class="line">The timeInterval of the timer is 60 seconds. It&apos;s scheduled at this moment, and should fire 60 seconds later at 2017.01.04 10:26:00.</span><br><span class="line">And for some reason you pause it 10 seconds after, which is 2017.01.04 10:25:10. And you resume the timer at 2017.01.04 10:25:50.</span><br><span class="line">However, you still want it to fire 60 seconds after it&apos;s scheduled, regardless the pausing part. So it should wait for 50 seconds more and fire at 2017.01.04 10:26:40.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>An ideal solution should be one that fits all 3 conditions (another one is the condition that someone doesn’t care if the original firedate is expired or not) discussed above. However, this project only deals with condition 2 because that is the problem I encountered with.</p>
<p>Hopefully, I will continue this small project in the future and complete it with solutions to every condition.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Project Page: &lt;a href=&quot;https://github.com/cheng-kang/PauseableTimer&quot;&gt;PauseableTimer Github Repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Chinese Version: &lt;a href=&quot;http://chengkang.me/2017/01/05/PauseableTimer%20%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%9A%82%E5%81%9C%E7%9A%84%E8%AE%A1%E6%97%B6%E5%99%A8/&quot;&gt;《Pauseable Timer 一个可暂停的计时器》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pauseable Timer is a pause-able timer written in Swift.&lt;/p&gt;
&lt;p&gt;There are occassions when we need timers to pause, however, this feature is not implemented in Timer(Swift3). Thus, after some failed attempts, I create this pause-able timer which hopefully could be useful to you.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cheng-kang/PauseableTimer/master/PauseableTimer-1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chengkang.me/tags/iOS/"/>
    
      <category term="Swift" scheme="http://chengkang.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>【译】我最喜欢的 JavaScript 设计模式</title>
    <link href="http://chengkang.me/2016/07/02/my-favorite-javascript-pattern/"/>
    <id>http://chengkang.me/2016/07/02/my-favorite-javascript-pattern/</id>
    <published>2016-07-02T09:50:25.000Z</published>
    <updated>2016-07-02T02:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.sitepoint.com/my-favorite-javascript-design-pattern/" target="_blank" rel="external">My Favorite JavaScript Design Pattern</a></p>
</blockquote>
<h1 id="我最喜欢的-JavaScript-设计模式"><a href="#我最喜欢的-JavaScript-设计模式" class="headerlink" title="我最喜欢的 JavaScript 设计模式"></a>我最喜欢的 JavaScript 设计模式</h1><p>我觉得聊一下我爱用的 JavaScript 设计模式应该很有意思。我是一步一步才定下来的，经过一段时间从各种来源吸收和适应直到达到一个能提供我所需的灵活性的模式。</p>
<p>让我给你看看概览，然后再来看它是怎么形成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function MyScript()&#123;&#125;</span><br><span class="line">(function()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  var THIS = this;</span><br><span class="line"></span><br><span class="line">  function defined(x)</span><br><span class="line">  &#123;</span><br><span class="line">    return typeof x != &apos;undefined&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.ready = false;</span><br><span class="line"></span><br><span class="line">  this.init = function(</span><br><span class="line">  &#123;</span><br><span class="line">    this.ready = true;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.doSomething = function()</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;;   </span><br><span class="line"></span><br><span class="line">  var options = &#123;</span><br><span class="line">      x : 123,</span><br><span class="line">      y : &apos;abc&apos;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  this.define = function(key, value)</span><br><span class="line">  &#123;</span><br><span class="line">    if(defined(options[key]))</span><br><span class="line">    &#123;</span><br><span class="line">      options[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;).apply(MyScript);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如你在实例代码中看到的，整体框架是一个函数直接量（function literal）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>函数直接量基本上就是一个自执行域，相当于定义一个有名的函数然后立即调用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure>
<p>我最初开始使用函数直接量是为了<code>封装</code>——任何格式的任何脚本都可以被封装在那个闭包里，并且它有效地将它<code>密封</code>在私有域中，从而保护它不会与同一个域里的其它脚本或者数据冲突。在最后面的那一对括号就是在执行这个域，就像其它函数一样调用它。</p>
<p>但是如果，这个域通过使用 <code>Function.apply</code> 来执行而不是全局调用，这可以让它在一个可被外界引用的<em>特定命名</em>的域中执行。</p>
<p>因此通过结合二者——创建一个命名函数，然后在这个命名函数的域内执行一个函数直接量——我们就得到了一个一次性的可以构成任何脚本的基础的对象，它模拟了类似面向对象类的继承性质。</p>
<h2 id="内在之美"><a href="#内在之美" class="headerlink" title="内在之美"></a>内在之美</h2><p>看看第一个代码示例，你就能看到封闭域结构提供了什么样的灵活性。当然，这些你都可以在任何方法中做到，但是通过用这种方式包装起来，我们就有了一个可以和任何命名域联系起来的结构体。</p>
<p>我们可以创建多个这样的结构体，然后将它们和同一个域联系起来，这样它们之间全部可以共享它们的公开数据。</p>
<p>不过在共享公开数据的同事，每一个（结构体）也可以定义它自己的私有数据。下面是一个例子，在脚本的最上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var THIS = this;</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个叫做 <code>THIS</code> 的私有变量，它指向这个函数域，并且可以在私有方法中使用——和用 <code>self = this</code> 来创建内部域是一样的招数。</p>
<p>通过同样方式声明的其他私有变量，如果他们定义常量数据的话，可以使用大写传统（不过用 <code>const</code> 而不是 <code>var</code> 来做声明的方式应该被避免，因为对它的支持不是很好）。</p>
<p>私有方法可以用来提供内部功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function defined(x)</span><br><span class="line">&#123;</span><br><span class="line">  return typeof x != &apos;undefined&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以创建其他实例或者外界可以访问的公开方法和属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.ready = false;</span><br><span class="line"></span><br><span class="line">this.init = function()</span><br><span class="line">&#123;</span><br><span class="line">  this.ready = true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">this.doSomething = function()</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以创建特殊的值——私有但是可以公开定义，在这个例子中是通过公开的 <code>define</code> 方法；它的参数可以根据数据需要再进行验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">  x : 123,</span><br><span class="line">  y : &apos;abc&apos;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">this.define = function(key, value)</span><br><span class="line">&#123;</span><br><span class="line">  if(defined(options[key]))</span><br><span class="line">  &#123;</span><br><span class="line">    options[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="封装起来！"><a href="#封装起来！" class="headerlink" title="封装起来！"></a>封装起来！</h2><p>所有的这些特点让这个结构体对我非常有用。并且它封装在一个整洁、自我执行的单例中——一个容易引用、整合和使用的一次性对象。</p>
<p>所以你怎么想？这个模式眼熟吗，或者你有什么其他喜欢用的？</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.sitepoint.com/my-favorite-javascript-design-pattern/&quot;&gt;My Favorite JavaScript Design Pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;我最喜欢的-JavaScript-设计模式&quot;&gt;&lt;a href=&quot;#我最喜欢的-JavaScript-设计模式&quot; class=&quot;headerlink&quot; title=&quot;我最喜欢的 JavaScript 设计模式&quot;&gt;&lt;/a&gt;我最喜欢的 JavaScript 设计模式&lt;/h1&gt;&lt;p&gt;我觉得聊一下我爱用的 JavaScript 设计模式应该很有意思。我是一步一步才定下来的，经过一段时间从各种来源吸收和适应直到达到一个能提供我所需的灵活性的模式。&lt;/p&gt;
&lt;p&gt;让我给你看看概览，然后再来看它是怎么形成的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function MyScript()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(function()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var THIS = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function defined(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return typeof x != &amp;apos;undefined&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.ready = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.init = function(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.ready = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.doSomething = function()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      x : 123,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      y : &amp;apos;abc&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.define = function(key, value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(defined(options[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      options[key] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).apply(MyScript);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Design Pattern" scheme="http://chengkang.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript 命名空间</title>
    <link href="http://chengkang.me/2016/06/28/javascript-namespace-by-michaux/"/>
    <id>http://chengkang.me/2016/06/28/javascript-namespace-by-michaux/</id>
    <published>2016-06-28T15:07:58.000Z</published>
    <updated>2016-06-28T08:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="http://peter.michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">《JavaScript Namespacing》</a></p>
</blockquote>
<h1 id="JavaScript-命名空间"><a href="#JavaScript-命名空间" class="headerlink" title="JavaScript 命名空间"></a>JavaScript 命名空间</h1><p>JavaScript 中有很多可以给你的对象安全分配命名空间的方法。这篇文章讨论我见过的普遍的实践。</p>
<h2 id="前缀命名空间"><a href="#前缀命名空间" class="headerlink" title="前缀命名空间"></a>前缀命名空间</h2><p>如果命名空间的目的是避免冲突的话。下面这个系统，只要我们知道全局变量名前缀 <em>myApp_</em> 是唯一的，可以像其他系统一样避免命名空间冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// add uniquely named global properties</span><br><span class="line">var myApp_sayHello = function() &#123;</span><br><span class="line">  alert(&apos;hello&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">var myApp_sayGoodbye = function() &#123;</span><br><span class="line">  alert(&apos;goodbye&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// use the namespace properties</span><br><span class="line">myApp_sayHello();</span><br></pre></td></tr></table></figure>
<p>C 语言程序经常使用前缀命名空间。在 JavaScript 的世界中，你可能会碰见 Macromedia 的 MM_ 方法，例如 MM_showHideLayers。</p>
<p>我认为前缀命名空间是 JavaScript 中最清楚明白的命名空间系统。（下面的对象命名空间策略在加入了 <code>this</code> 关键字后会导致困惑。）</p>
<p>前缀命名空间的确创建了很多全局对象。这对于前缀用来避免的命名空间冲突并不是什么问题。前缀命名空间的问题是，有些网页浏览器（例如 IE6）在有很多全局对象时表现很糟糕，就我所听说。我做了一些测试并且发现有一个 comp.lang.javascript 的小线程，不过我没有就这个话题研究彻底。</p>
<a id="more"></a>
<h2 id="单对象命名空间"><a href="#单对象命名空间" class="headerlink" title="单对象命名空间"></a>单对象命名空间</h2><p>当下，最流行的 JavaScript 命名空间实践是使用一个全局变量来引用一个对象。这个被引用的对象引用你的『真正的业务』，并且因为你的全局对象的命名独一无二，你的代码和其他人的代码就可以一起嗨皮地运行。</p>
<p>如果你确定这个世界上没有任何人用了这个全局变量名 <em>myApp</em>，那么你可以有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// define the namespace object</span><br><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// add properties to the namespace object</span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(&apos;hello&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">myApp.sayGoodbye = function() &#123;</span><br><span class="line">  alert(&apos;goodbye&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// use the namespace properties</span><br><span class="line">myApp.sayHello();</span><br></pre></td></tr></table></figure>
<p>当上面代码的最后一行执行时，JavaScript 解释器首先找到 <em>myApp</em> 对象，然后找到并调用这个对象的 <em>syaHello</em> 属性。</p>
<p>对象命名空间的一个问题是它会导致与面向对象消息传递混淆。这两者之间并没有明显的句法差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">namespace.prop();</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">receiver.message();</span><br></pre></td></tr></table></figure>
<p>更仔细地研究这个混淆，我们得出下面的命名空间想法。假设我们有以下库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.message = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(myApp.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个库的代码可以随意进行写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.sayHello(); // works</span><br><span class="line">  </span><br><span class="line">var importedfn = myApp.sayHello;</span><br><span class="line"></span><br><span class="line">importedfn(); // works</span><br></pre></td></tr></table></figure>
<p>将这个和那个令人混淆的使用 <code>this</code> 的消息传递版本比较一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myApp.message = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">myApp.sayHello = function() &#123;</span><br><span class="line">  alert(this.message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用这个库的代码可以随意进行写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myApp.sayHello() // works because &quot;this&quot; refers to myApp object.</span><br><span class="line"></span><br><span class="line">var importedfn = myApp.sayHello;</span><br><span class="line"></span><br><span class="line">importedfn(); // error because &quot;this&quot; refers to global object.</span><br></pre></td></tr></table></figure>
<p>这里面的要上的一课是，<code>this</code> 永远不能引用一个被作为命名空间的对象因为它肯能导致关于从命名空间引入标识符的混淆。这个问题是 <code>this</code> 在我的 <a href="http://peter.michaux.ca/article/7933" target="_blank" rel="external">JavaScript Warning Words</a> 列表中的原因之一。</p>
<p>（这也表明了库的 API 属性应该指向用一个方法，这样这些方法可以被导入其他命名空间。这个问题是在我的文章 <a href="http://peter.michaux.ca/article/3556" target="_blank" rel="external">Lazy Function Definition Pattern</a> 的评论中被指出的。懒惰方法定义可以在被隐藏在库中并且不是 API 的部分时安全使用。）</p>
<h2 id="嵌套对象命名空间"><a href="#嵌套对象命名空间" class="headerlink" title="嵌套对象命名空间"></a>嵌套对象命名空间</h2><p>嵌套对象命名空间是另一个普遍的实践，它扩展了对象命名空间的想法。你可能见过类似如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO.util.Event.addListener(/*...*/)</span><br></pre></td></tr></table></figure>
<p>解决上面的代码需要解释器首先找到全聚德 <em>YAHOO</em> 对象，然后它的 <em>util</em> 对象，然后它的 <em>Event</em> 对象，然后找到并调用它的 <em>addListener</em> 属性。这样的话每次事件处理器绑定到一个 DOM 元素上花的功夫太多了，因此导入的概念开始被采用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var yue = YAHOO.util.Event;</span><br><span class="line">  yue.addListener(/*...*/);</span><br><span class="line">  yue.addListener(/*...*/);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果你清楚 <em>YAHOO.util.Event.addListener</em> 方法不会用 <code>this</code> 关键字并且永远引用同一个方法，那么导入可以变得更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  var yuea = YAHOO.util.Event.addEventListener;</span><br><span class="line">  yuea(/*...*/);</span><br><span class="line">  yuea(/*...*/);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我觉得当目的只是避免标识符冲突时，嵌套对象命名空间的复杂是不必要的。难道 Yahoo! 还觉得这些全局标识符 YAHOO_util_Event 和 YAHOO_util_Event_addEventListener 不够独特吗？</p>
<p>我认为使用嵌套对象命名空间的动机是要看起来和 Java 包命名传统一样，这在 Java 中开销不大。例如，在 Java 中你可能看到如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package mytools.text;</span><br><span class="line"></span><br><span class="line">class TextComponent &#123;</span><br><span class="line">  /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个这个类的完全合格的引用应该是 <code>mytools.text.TextComponent</code>。</p>
<p>下面是 Niemeyer 和 Knudsen （写）的 <em>Learning Java</em> 中包命名的描述：</p>
<blockquote>
<p>包名是按层级构成的，使用点分隔的命名传统。包名组成成分给编译器和运行系统构成了独一无二的定位文件的路径。然而，它们并没在包之间创建其他的关系。并没有什么『subpackage』的说法，事实上，包命名空间是直接的，而非层级的。在包层级关系特定部分的包仅仅是因为习惯而有关联。比如，如果我们穿件了另一个叫做 <em>mytools.text.poetry</em> 的包（假设是为了跟诗有关的一些文字类），这些类并不是 <em>mytools.text</em> 包的一部分；它们没有包成员的访问权限。</p>
</blockquote>
<p>嵌套命名空间的幻觉在 Perl 中也存在。在 Perl 中，嵌套包名由双冒号分隔开。你可以看到如下 Perl 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package Red::Blue;</span><br><span class="line">our $var = &apos;foo&apos;;</span><br></pre></td></tr></table></figure>
<p>一个完全合格的上述变量引用应该是 <em>$Red::Blue::var</em>。</p>
<p>在 Perl 中，就像 Java，命名空间层级的主意只是方便程序员，而不是语言本身要求。Wall，Christiansen 和 Orwant 的 <em>Programming Perl</em> 解释道：</p>
<blockquote>
<p>双冒号可被用于链接在包名 <em>$Red::Blue::var</em> 中标识符。这意味着 <em>$var</em> 属于包 <em>Red::Blue</em>。包 <em>Red::Blue</em> 跟可能存在的 <em>Red</em> 包或 <em>Blue</em> 包一点关系都没有。只是说，<em>Red::Blue</em> 和 <em>Red</em> 或者 <em>Blue</em> 之间的关系可能对于写代码或者使用这个程序的人有什么意义，但跟 Perl 没关系。（好吧，除了在现在的实现中，符号表 <em>Red::Blue</em> 刚好存在符号表 <em>Red</em> 中。但是 Perl 语言并没有直接利用过它。）</p>
</blockquote>
<p>上述引用中最后备注暗示了 Perl 可能有和在 JavaScript 中使用嵌套命名空间对象一样的标识符冲突开销。如果 Perl 的实现改变了，这个开销就会消失。在 JavaScript 中，我肯定嵌套对象命名空间的开销永远不会消失因为 JavaScript 使用延迟绑定。</p>
<p>我并不认为 JavaScript 中的嵌套对象命名空间提供了任何大好处，不过如果不使用导入的话在运行时可能会开销非常大。</p>
<h2 id="一个折中方案"><a href="#一个折中方案" class="headerlink" title="一个折中方案"></a>一个折中方案</h2><p>如果单纯地前缀命名空间在某些浏览器中真的很慢，而嵌套命名空间的概念帮助在开发者脑中保持各事务的有序，那我认为上述 Yahoo! 的例子也可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO.util_Event_addListener</span><br></pre></td></tr></table></figure>
<p>或者用更多的全局名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAHOO_util_Event.addListener</span><br></pre></td></tr></table></figure>
<h2 id="哪个维度的命名空间？"><a href="#哪个维度的命名空间？" class="headerlink" title="哪个维度的命名空间？"></a>哪个维度的命名空间？</h2><p>Perl 的 CPAN 模块是基于他们所做的事情进行命名空间管理的。例如，我写了一个这个命名空间里的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript::Minifier</span><br></pre></td></tr></table></figure>
<p>如果别人用同样的名字写他自己的模块，并且他不自知地通过某些模块依赖通过同一个名字使用 CPAN 模块，那么就会有冲突。</p>
<p>Java 程序员采用最冗长但当然也是最安全的方法。（Java 程序员似乎都想着在大型系统上运行的代码。）在 Java 中，包经常是基于<strong>谁写的</strong>和<strong>做什么的</strong>来命名。（<em>myFunc</em>风格的规范化。）『谁写的』部分甚至使用开发者自己的相对可以保证唯一性的名字。如果我写一个 Java 的 minifier，因为我有 michaux.ca 的域名，我可能用以下命名空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca.michaux.javascript.minifier</span><br></pre></td></tr></table></figure>
<p>在 JavaScript 中，经过这次讨论，可能这样写效率更高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca_michaux_javascript_minifier</span><br></pre></td></tr></table></figure>
<p>因为 JavaScript 是以文本的形式服务的，这样的命名空间可能开销太大，因为增加了下载时间。Gzip 压缩会找到公共的字符串并用短字符串替换它们。如果 gzip 不可用的话那么就可以考虑使用导入了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ca_michaux_javascript_minifier = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(function() &#123;</span><br><span class="line">  var cmjm = ca_michaux_javascript_minifier;</span><br><span class="line">  </span><br><span class="line">  // refer to cmjm inside this module pattern</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我并不是说这些长的命名空间是绝对必须的，不过他们一定是避免命名空间冲突的最安全方法。</p>
<h2 id="其他命名空间问题"><a href="#其他命名空间问题" class="headerlink" title="其他命名空间问题"></a>其他命名空间问题</h2><p>标识符不仅在 JavaScript 资源中创建。一个表单的 name 属性也被加在 <em>document.forms</em> 对象上。像 <em><form name="myCompany_login"></form></em> 这样命名是有意义的。</p>
<p>命名空间类名属性，比如 <em>&lt;div class=”myCompany_story”&gt;</em>，可以在减少 CSS 命名空间冲突以及当 JavaScript 代码在通过类名搜索 DOM 元素时很有价值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人认为，任何像 <em>YAHOO.util.Event.addListener</em> 这样有点或者下划线的东西都是被冲突吓傻了的。它可以就是 <em>YUI.on</em>。Dojo 通过同样功能的 dojo.connect 提供了足够的保护，因为它有效地涵盖了命名空间『谁』和『做什么』的维度。没有人会在他们的右脑中会这样想并在 dojo 命名空间下写一个 JavaScript 库。Dojo 的开发人员也不会忘记他们已经有了一个 connect 方法并写另外一个。</p>
<p>如果我们能有一个网站来让程序员们保存他们的 JavaScript 全局标识符和下划线前缀，并且当 ECMAScipt4 发布了的时候也包括他们的包名，就好了：『JavaScript 命名空间登记处』。</p>
<p>JavaScript 是一个最小概念集的强大语言。即使 JavaScript 并没有专门为避免命名空间冲突设计的语言级支持，还是有很多解决问题的方法。并没有一个『正确』的答案。选一个你最喜欢的。</p>
<p>不过，无论你做什么，请记住别弄一个另外的全局 $ 标识符。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="http://groups.google.com/group/comp.lang.javascript/browse_frm/thread/494e1757fa51fe3f" target="_blank" rel="external">comp.lang.javascript discussion on namespacing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://peter.michaux.ca/articles/javascript-namespacing&quot;&gt;《JavaScript Namespacing》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 命名空间&quot;&gt;&lt;/a&gt;JavaScript 命名空间&lt;/h1&gt;&lt;p&gt;JavaScript 中有很多可以给你的对象安全分配命名空间的方法。这篇文章讨论我见过的普遍的实践。&lt;/p&gt;
&lt;h2 id=&quot;前缀命名空间&quot;&gt;&lt;a href=&quot;#前缀命名空间&quot; class=&quot;headerlink&quot; title=&quot;前缀命名空间&quot;&gt;&lt;/a&gt;前缀命名空间&lt;/h2&gt;&lt;p&gt;如果命名空间的目的是避免冲突的话。下面这个系统，只要我们知道全局变量名前缀 &lt;em&gt;myApp_&lt;/em&gt; 是唯一的，可以像其他系统一样避免命名空间冲突。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// add uniquely named global properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myApp_sayHello = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(&amp;apos;hello&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var myApp_sayGoodbye = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  alert(&amp;apos;goodbye&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// use the namespace properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myApp_sayHello();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;C 语言程序经常使用前缀命名空间。在 JavaScript 的世界中，你可能会碰见 Macromedia 的 MM_ 方法，例如 MM_showHideLayers。&lt;/p&gt;
&lt;p&gt;我认为前缀命名空间是 JavaScript 中最清楚明白的命名空间系统。（下面的对象命名空间策略在加入了 &lt;code&gt;this&lt;/code&gt; 关键字后会导致困惑。）&lt;/p&gt;
&lt;p&gt;前缀命名空间的确创建了很多全局对象。这对于前缀用来避免的命名空间冲突并不是什么问题。前缀命名空间的问题是，有些网页浏览器（例如 IE6）在有很多全局对象时表现很糟糕，就我所听说。我做了一些测试并且发现有一个 comp.lang.javascript 的小线程，不过我没有就这个话题研究彻底。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://chengkang.me/tags/Namespacing/"/>
    
      <category term="Namespace" scheme="http://chengkang.me/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>【译】JavaScript 中的命名空间</title>
    <link href="http://chengkang.me/2016/06/21/Namespacing%20in%20JavaScript/"/>
    <id>http://chengkang.me/2016/06/21/Namespacing in JavaScript/</id>
    <published>2016-06-21T20:59:30.000Z</published>
    <updated>2016-06-28T08:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文链接： <a href="https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/" target="_blank" rel="external">Namespacing in JavaScript</a></p>
</blockquote>
<h1 id="JavaScript-中的命名空间"><a href="#JavaScript-中的命名空间" class="headerlink" title="JavaScript 中的命名空间"></a>JavaScript 中的命名空间</h1><p>全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。</p>
<p>不过，恩，这些你早都知道了……</p>
<p>所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 <a href="http://www.brothercake.com/" target="_blank" rel="external">James Edwards</a> 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。<br><a id="more"></a></p>
<h2 id="静态命名空间"><a href="#静态命名空间" class="headerlink" title="静态命名空间"></a>静态命名空间</h2><p>我用<code>静态命名空间</code>作为那些命名空间标签实际上硬编码的解决方案的涵盖性术语。是的，你可以将一个命名空间重新分配给另一个，不过新的命名空间将会引用和旧的那一个同样的对象。</p>
<h3 id="1-通过直接分配"><a href="#1-通过直接分配" class="headerlink" title="1.通过直接分配"></a>1.通过直接分配</h3><p>最基础的方法。这样非常冗长，并且如果你还想重命名这些命名空间，你就有得活儿干了。不过它是安全和清楚明白的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;</span><br><span class="line">myApp.id = 0;</span><br><span class="line">myApp.next = function() &#123;</span><br><span class="line">    return myApp.id++;  </span><br><span class="line">&#125;</span><br><span class="line">myApp.reset = function() &#123;</span><br><span class="line">    myApp.id = 0;   </span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>你也可以通过使用<code>this</code>引用兄弟属性来使将来的维护更轻松一些，不过这有一点冒险因为没有什么能阻止你的那些命名空间里的方法被重新分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;</span><br><span class="line">myApp.id = 0;</span><br><span class="line">myApp.next = function() &#123;</span><br><span class="line">    return this.id++;   </span><br><span class="line">&#125;</span><br><span class="line">myApp.reset = function() &#123;</span><br><span class="line">    this.id = 0;    </span><br><span class="line">&#125;</span><br><span class="line">myApp.next(); //0</span><br><span class="line">myApp.next(); //1</span><br><span class="line">var getNextId = myApp.next;</span><br><span class="line">getNextId(); //NaN whoops!</span><br></pre></td></tr></table></figure>
<h3 id="2-使用对象字面量"><a href="#2-使用对象字面量" class="headerlink" title="2.使用对象字面量"></a>2.使用对象字面量</h3><p>现在我们只需要引用命名空间名一次，因此之后改变名字更简单了一些（假设你还没反复引用这个命名空间）。仍有一个危险是<code>this</code>的值可能会抛出一个『惊喜』 - 不过假设在一个对象字面结构里定义的对象不会被重新分配相对安全一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;</span><br><span class="line">    id: 0,</span><br><span class="line">    next: function() &#123;</span><br><span class="line">        return this.id++;   </span><br><span class="line">    &#125;,</span><br><span class="line">    reset: function() &#123;</span><br><span class="line">        this.id = 0;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<h3 id="3-模块模式"><a href="#3-模块模式" class="headerlink" title="3.模块模式"></a>3.模块模式</h3><p>我发现自己最近用<code>模块模式</code>更多。逻辑被一个方法包装从全局域隔离开了（通常是自调用的），它返回一个代表这个模块公开接口的对象。通过立即调用这个方法并分配结果给一个命名空间变量，我们就锁住了这个命名变量中模块的 API。此外，任何没有包括在返回值中的变量将永远保持私有，只对引用他们的公开方法可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myApp = (function() &#123;</span><br><span class="line">    var id= 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        next: function() &#123;</span><br><span class="line">            return id++;    </span><br><span class="line">        &#125;,</span><br><span class="line">        reset: function() &#123;</span><br><span class="line">            id = 0;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;)();   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>如上对象字面量例子，命名空间名字可以轻易更换，不过还有额外优势：对象字面量是四班的 - 它全是关于属性分配，没有支持逻辑的空间。此外，所有属性必须被初始化，并且属性值无法轻易跨对象引用（因此，比如，内部闭包就不可能使用了）。模块模式没有任何上述约束，并且给我们额外的隐私福利。</p>
<h2 id="动态命名空间"><a href="#动态命名空间" class="headerlink" title="动态命名空间"></a>动态命名空间</h2><p>我们也可以将这一节称为<code>命名空间注入</code>。命名空间由一个直接引用方法包装<code>内部</code>的代理代表 - 这意味着我们不再需要打包分配给命名空间的返回值。这让命名空间定义变得更灵活并且让拥有多个存在于独立命名空间中（或者甚至在全局上下文中）的模块的独立实例。动态命名空间支持模块模式的全部特征并附加直观和可读性强的优势。</p>
<h3 id="4-提供命名空间参数"><a href="#4-提供命名空间参数" class="headerlink" title="4.提供命名空间参数"></a>4.提供命名空间参数</h3><p>在这里我们只是将命名空间作为参数传给自调用方法。变量<code>id</code>是私有的，因为他并没有被分配给<code>context</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id = 0;</span><br><span class="line">    context.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    context.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(myApp);  </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>我们甚至可以把<code>context</code>设置给全局对象（通过一个字的改变！）。这是库主们的巨大财富 - 他们可以将他们的特性包装在一个自调用函数中，然后让用户来决定它们是不是全局的（John Resig 在他写 JQuery 时就是一个这个理论的早期采用者）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function(context) &#123; </span><br><span class="line">    var id = 0;</span><br><span class="line">    context.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    context.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this);   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<h3 id="5-用this作为命名空间代理"><a href="#5-用this作为命名空间代理" class="headerlink" title="5.用this作为命名空间代理"></a>5.用<code>this</code>作为命名空间代理</h3><p><a href="http://www.brothercake.com/" target="_blank" rel="external">James Edwads</a> 最近发布的一篇文章激起了我的兴趣。<a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/" target="_blank" rel="external">《My Favorite JavaScript Design Patter》</a> 显然被很多评论者误解了，他们认为他可能也是借助于模块模式。这篇文章宣传了多种技术（可能导致了读者的迷惑），但是在它的核心部分是一点我已经修改并呈现为一个命名空间工具的很天才的东西。</p>
<p>这个模式的美就在于它仅仅是按照这个语言被设计的方式使用 - 不多不少、不投机也不取巧。此外因为命名空间是通过<code>this</code>关键字（它在给定的执行上下文中是不变的）注入的，它不可能被意外修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var myApp = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var id = 0;</span><br><span class="line"> </span><br><span class="line">    this.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).apply(myApp);    </span><br><span class="line"> </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.next(),</span><br><span class="line">    myApp.reset(),</span><br><span class="line">    myApp.next()</span><br><span class="line">); //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>更棒的是，<code>apply</code>（以及<code>call</code>） API 提供了与上下文和参数天然的隔离 - 因此给模块创建者传递附加参数非常干净。下面的例子表明了这一点，并且展示了如何独立于多个命名空间来运行模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var subsys1 = &#123;&#125;, subsys2 = &#123;&#125;;</span><br><span class="line">var nextIdMod = function(startId) &#123;</span><br><span class="line">    var id = startId || 0;</span><br><span class="line">    this.next = function() &#123;</span><br><span class="line">        return id++;    </span><br><span class="line">    &#125;;</span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">        id = 0;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">nextIdMod.call(subsys1);    </span><br><span class="line">nextIdMod.call(subsys2,1000);   </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys1.next(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.reset(),</span><br><span class="line">    subsys2.next(),</span><br><span class="line">    subsys1.next()</span><br><span class="line">) //0, 1, 1000, undefined, 1001, 0</span><br></pre></td></tr></table></figure>
<p>当然如果我们如果我们需要一个全局 id 生成器，非常简单……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nextIdMod();    </span><br><span class="line">window.console &amp;&amp; console.log(</span><br><span class="line">    next(),</span><br><span class="line">    next(),</span><br><span class="line">    reset(),</span><br><span class="line">    next()</span><br><span class="line">) //0, 1, undefined, 0</span><br></pre></td></tr></table></figure>
<p>这个我们作为例子使用的 id 生成器工具并没有表现出这个模式的全部潜力。通过包裹一整个库和使用<code>this</code>关键字作为命名空间的替身，我们使得用户在任何他们选择的上下文中运行这个库很轻松（包括全局上下文）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//library code</span><br><span class="line">var protoQueryMooJo = function() &#123;  </span><br><span class="line">    //everything</span><br><span class="line">&#125;</span><br><span class="line">//user code</span><br><span class="line">var thirdParty = &#123;&#125;;</span><br><span class="line">protoQueryMooJo.apply(thirdParty);</span><br></pre></td></tr></table></figure>
<h2 id="其他的考虑"><a href="#其他的考虑" class="headerlink" title="其他的考虑"></a>其他的考虑</h2><p>我希望避免命名空间嵌套。它们很难追踪（对人和电脑都是）并且它们会让你的代码因为一些乱七八糟的东西变得很多。如 <a href="http://michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">Peter Michaux</a> 指出的，深度嵌套的命名空间可能是那些视图重新创建他们熟悉和热爱的长包链的老派 Java 开发者的遗产。</p>
<p>通过 .js 文件来固定一个单独的命名空间也是可以的（虽然只能通过命名空间注入或者直接分配每一个变量），不过你应该对依赖谨慎些。此外将命名空间绑定到文件上可以帮助读者更轻易弄清整个代码。</p>
<p>因为 JavaScript 并没有正式的命名空间结构，所以有很多自然形成的方法。这个调查只详细说明了其中的一部分，可能有更好的技术我没有发现。我很乐意知道它们。</p>
<h2 id="更多文章"><a href="#更多文章" class="headerlink" title="更多文章"></a>更多文章</h2><p>James Edwards： <a href="http://blogs.sitepoint.com/2010/11/30/my-favorite-javascript-design-pattern/" target="_blank" rel="external">My Favorite JavaScript Design Pattern</a><br>Peter Michaux: <a href="http://michaux.ca/articles/javascript-namespacing" target="_blank" rel="external">JavaScript Namespacing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/&quot;&gt;Namespacing in JavaScript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;JavaScript-中的命名空间&quot;&gt;&lt;a href=&quot;#JavaScript-中的命名空间&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的命名空间&quot;&gt;&lt;/a&gt;JavaScript 中的命名空间&lt;/h1&gt;&lt;p&gt;全局变量应该由有系统范围相关性的对象们保留，并且它们的命名应该避免含糊并尽量减少命名冲突的风险。在实践中，这意味着你应该避免创建全局对象，除非它们是绝对必须的。&lt;/p&gt;
&lt;p&gt;不过，恩，这些你早都知道了……&lt;/p&gt;
&lt;p&gt;所以你对此是怎么做的？传统方法告诉我们，最好的消除全局策略是创建少数作为潜在模块和子系统的实际命名空间的全局对象。我将探索几种有关命名空间的方式，并以我基于 &lt;a href=&quot;http://www.brothercake.com/&quot;&gt;James Edwards&lt;/a&gt; 最近的一篇文章得到的一个优雅、安全和灵活的解决方案结束。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://chengkang.me/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://chengkang.me/tags/JavaScript/"/>
    
      <category term="Namespacing" scheme="http://chengkang.me/tags/Namespacing/"/>
    
      <category term="Namespace" scheme="http://chengkang.me/tags/Namespace/"/>
    
  </entry>
  
</feed>
