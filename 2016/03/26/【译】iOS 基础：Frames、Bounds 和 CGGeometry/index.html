<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【译】iOS 基础：Frames、Bounds 和 CGGeometry · CHENG KANG</title><meta name="description" content="【译】iOS 基础：Frames、Bounds 和 CGGeometry - 程康·Ant"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/progrant" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/cheng-kang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">【译】iOS 基础：Frames、Bounds 和 CGGeometry</h1><div class="post-time">Mar 26, 2016</div><div class="post-content"><blockquote>
<p>原文：<a href="http://code.tutsplus.com/tutorials/ios-fundamentals-frames-bounds-and-cggeometry--cms-21196" target="_blank" rel="external">《iOS Fundamentals: Frames, Bounds, and CGGeometry》</a><br>程康，2016 年 3 月 26 日</p>
</blockquote>
<p>如果你习惯支持点语法的语言，要搞清楚<code>CGPoint</code>、<code>CGSize</code>和<code>CGRect</code>并不难。不过编程式定位视图或者编写绘图代码一般都很长，因此变得很难读明白。</p>
<p>在这个教程里，我希望能澄清一些对 frames 和 bounds 的误解，并且介绍一下<strong>CGGeometry</strong>，它是一个结构体、常量和功能的集合，能让你更轻松地运用<code>CGPoint</code>，<code>CGSize</code>和<code>CGRect</code>。</p>
<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>如果你刚开始接触 iOS 或者 OS X 开发，你可能会想<code>CGPoint</code>、<code>CGSize</code>和<code>CGRect</code>到底是什么。CGGeometry Reference 定义了一系列几何图元（geometric primitives）或者说结构，我们现在关注的是其中的<code>CGPoint</code>、<code>CGSize</code>和<code>CGRect</code>。</p>
<p>大多数人应该知道，<code>CGPoint</code>是定义了坐标系中一个点的 C 结构体。这个坐标系的原点在 iOS 的左上方以及 OS X 的左下方。换句话说，纵轴方向在 iOS 和 OS X 上不一样。</p>
<p><code>CGSize</code>是另一个简单的 C 结构体，它定义了一个宽度值（width）和高度值（height）。<code>CGRect</code>包含一个<code>origin</code>（原点）字段、一个<code>CGPoint</code>和一个<code>size</code>（大小）字段，即一个<code>CGSize</code>。<code>origin</code>（原点）和<code>size</code>（大小）字段一起决定了一个矩形的位置和大小。</p>
<p>CGGeometry Reference 也定义了其他类型，例如<code>CGFloat</code>和<code>CGVector</code>。<code>CGFloat</code>就是一个<code>float</code>（单精度浮点型）或者<code>double</code>(双精度浮点型)的<code>typedef</code>（类型重定义），是哪一种取决于应用运行的机器结构是 32 位还是 64 位。<br><a id="more"></a></p>
<h3 id="2-Frames-和-Bounds"><a href="#2-Frames-和-Bounds" class="headerlink" title="2.Frames 和 Bounds"></a>2.Frames 和 Bounds</h3><p>第一个要搞清楚的是一个视图的<code>frame</code>和<code>bounds</code>之间的区别，因为这困扰着很多 iOS 入门开发者。不过这个区别也不复杂。</p>
<p>在 iOS 和 OS X 中，一个应用有多个坐标系。比如，在 iOS 中应用窗口定位在屏幕的坐标系，而窗口的每一个子视图定位在窗口的坐标系。换句话说，一个视图的子视图总是定位在该视图的坐标系中。</p>
<p><strong>Frames</strong></p>
<p>如文档中说的，视图的<code>frame</code>是一个结构体，即一个<code>CGRect</code>,它定义了这个视图的大小和它在父视图中的位置，或者说父视图坐标系中的位置。看看下面的图应该就能明白了。</p>
<p><img src="https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-1.jpg" alt=""></p>
<p><strong>Bounds</strong></p>
<p>视图的<code>bounds</code>属性定义了这个视图的大小和它在自身坐标系中的位置。这意味着大多数情况下一个视图的 bounds 的原点都是<code>{0,0}</code>，如下图。视图的<code>bounds</code>对于绘制这个视图很重要。</p>
<p><img src="https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-2.jpg" alt=""></p>
<p>当视图的<code>frame</code>属性被修改时，视图的<code>center</code>和<code>bounds</code>属性二者或者其一也同时被改变。</p>
<h3 id="CGGeometry-Reference"><a href="#CGGeometry-Reference" class="headerlink" title="CGGeometry Reference"></a>CGGeometry Reference</h3><p><strong>方便的取值方法</strong><br>之前提到过，CGGeometry Reference 是一个让运用坐标和矩形更方便的结构体、常量和方法的集合。你可能碰到过类似的下面的代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGPoint point = CGPonitMake(self.view.frame.origin.x + self.view.frame.size.width, self.view.frame.origin.y + self.view.frame.size.height);</span><br></pre></td></tr></table></figure></p>
<p>这样的片段不尽难阅读，而且过于冗长。我们可以用在 CGGeometry Reference 中定义的两个方便的方法重写这段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.view.frame;</span><br><span class="line">CGPoint point = CGPointMake(CGRectGetMaxX(frame), CGRectGetMaxY(frame));</span><br></pre></td></tr></table></figure></p>
<p>为了简化之前那段代码，我们把视图的<code>frame</code>储存到一个叫<code>frame</code>的变量中，并且使用了<code>CGRectGetMaxX</code>和<code>CGRectGetMaxY</code>两个方法。这两个方法的方法名解释了自己的功能。</p>
<p>CGGeometry Reference 定义了返回一个矩形 x 轴坐标、y 轴坐标最小和最大值以及这个矩形中心坐标的方法。另外两个方便的取之方法是<code>CGRectGetWidth</code>和<code>CGRectGetHeight</code>。</p>
<p><strong>创建结构体</strong></p>
<p>当要创建<code>CGPoint</code>、<code>CGSize</code>和<code>CGRect</code>时，大多数人都用<code>CGPointMake</code>或者类似的方法。这些方法也被定义在 CGGeometry Reference 中。虽然它们的实现非常简单，它们特别有用并且让你少写一些代码。例如，<code>CGRectMake</code>是这样实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)</span><br><span class="line">&#123;</span><br><span class="line">	CGRect rect;</span><br><span class="line">	rect.origin.x = x; rect.origin.y = y;</span><br><span class="line">	rect.size.width = width; rect.size.height = height;</span><br><span class="line">	return rect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>修改矩形</strong></p>
<p>以上提到过的方法都是 iOS 开发者熟知的，它们减少了我们的代码量并且让它们可读性增加。不过，CGGeometry Reference 也定义了一切其他大家不太了解的方法。比如 CGGeometry Reference 定义了一堆修改<code>CGRect</code>结构的方法。让我们来看看其中一些。</p>
<p><strong><code>CGRectUnion</code></strong><br><code>CGRectUnion</code>接受两个<code>CGRect</code>结构体作为参数并且返回一个能够包含这两个矩形的最小矩形。听起来可能没什么，我相信你也可以用几行代码轻松实现这个功能，不过 CGGeometry 做的是给你提供一些方法让你的代码更干净、可读性更强。</p>
<p>如果你把下面代码片段加到一个 view controller 的<code>viewDidLoad</code>方法中，你将在模拟器中看到如下结果。那个灰色的矩形就是使用<code>CGRectUnion</code>的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CGRectUnion</span><br><span class="line">CGRect frame1 = CGRectMake(80.0, 100.0, 150.0, 240.0);</span><br><span class="line">CGRect frame2 = CGRectMake(140.0, 240.0, 120.0, 120.0);</span><br><span class="line">CGRect frame3 = CGRectUnion(frame1, frame2);</span><br><span class="line"> </span><br><span class="line">UIView *view1 = [[UIView alloc] initWithFrame:frame1];</span><br><span class="line">[view1 setBackgroundColor:[UIColor redColor]];</span><br><span class="line"> </span><br><span class="line">UIView *view2 = [[UIView alloc] initWithFrame:frame2];</span><br><span class="line">[view2 setBackgroundColor:[UIColor orangeColor]];</span><br><span class="line"> </span><br><span class="line">UIView *view3 = [[UIView alloc] initWithFrame:frame3];</span><br><span class="line">[view3 setBackgroundColor:[UIColor grayColor]];</span><br><span class="line"> </span><br><span class="line">[self.view addSubview:view3];</span><br><span class="line">[self.view addSubview:view2];</span><br><span class="line">[self.view addSubview:view1];</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-3.jpg" alt=""></p>
<p><strong><code>CGRectDivide</code></strong></p>
<p>另一个有用的方法是<code>CGRectDivide</code>，它帮你把一个给定矩形分割成两个。看看下面的代码和截图来了解它是怎么运作的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// CGRectDivide</span><br><span class="line">CGRect frame = CGRectMake(10.0, 50.0, 300.0, 300.0);</span><br><span class="line">CGRect part1;</span><br><span class="line">CGRect part2;</span><br><span class="line">CGRectDivide(frame, &amp;part1, &amp;part2, 100.0, CGRectMaxYEdge);</span><br><span class="line"> </span><br><span class="line">UIView *view1 = [[UIView alloc] initWithFrame:frame];</span><br><span class="line">[view1 setBackgroundColor:[UIColor grayColor]];</span><br><span class="line"> </span><br><span class="line">UIView *view2 = [[UIView alloc] initWithFrame:part1];</span><br><span class="line">[view2 setBackgroundColor:[UIColor orangeColor]];</span><br><span class="line"> </span><br><span class="line">UIView *view3 = [[UIView alloc] initWithFrame:part2];</span><br><span class="line">[view3 setBackgroundColor:[UIColor redColor]];</span><br><span class="line"> </span><br><span class="line">[self.view addSubview:view1];</span><br><span class="line">[self.view addSubview:view2];</span><br><span class="line">[self.view addSubview:view3];</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-4.jpg" alt=""></p>
<p>如果你不使用<code>CGRectDivide</code>来计算红色和橙色矩形的话，你可能要多谢几十行代码。不信你就试试。</p>
<p><strong>比较和包含</strong></p>
<p>用下面六个方法来比较几何结构和检查包含关系非常简单。</p>
<ul>
<li><code>CGPointEqualToPoint</code></li>
<li><code>CGSizeEqualToSize</code></li>
<li><code>CGRectEqualToRect</code></li>
<li><code>CGRectIntersectsRect</code></li>
<li><code>CGRectContainsPoint</code></li>
<li><code>CGRectContainsRect</code></li>
</ul>
<p>CGGeometry Reference 还有一些其他宝贝，比如<code>CGPointCreateDictionaryRepresentation</code>可以用来将一个 CGPoint 结构体转换为一个 <code>CGDictionaryRef</code>，<code>CGRectIsEmpty</code>可以用来检查一个矩形的宽高是否都为零。更多详情请看<a href="">《CGGeometry Reference 文档》</a>。</p>
<h3 id="4-福利：打印日志"><a href="#4-福利：打印日志" class="headerlink" title="4.福利：打印日志"></a>4.福利：打印日志</h3><p>在 Xcode 控制台打印日志如果没有一些辅助方法的话很麻烦。幸运的是，UIKit 框架定义了一些让它变得很方便的方法。我天天用它们。看看下面的代码片段来了解它们是如何工作。并没有什么奇特的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGPoint point = CGPointMake(10.0, 25.0);</span><br><span class="line">CGSize size = CGSizeMake(103.0, 223.0);</span><br><span class="line">CGRect frame = CGRectMake(point.x, point.y, size.width, size.height);</span><br><span class="line">NSLog(@&quot;\n%@\n%@\n%@&quot;, NSStringFromCGPoint(point), NSStringFromCGSize(size), NSStringFromCGRect(frame));</span><br></pre></td></tr></table></figure></p>
<p>还有一些方便打印仿射变换（affine transforms）（<code>NSStringFromCGAffineTransform</code>）、边缘插入（<code>NSStringFromUIEdgeInsets</code>）、偏移（<code>NSStringFromUIOffset</code>）等的日志的方便方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS SDK 包含了大量开发者们不了解的宝贝。我希望我给你们讲明白了 CGGeometry Reference 的实用性。一旦你开始使用它的那些方法，你就会开始问自己，以前没用它怎么活过来的。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/30/仿微博 iOS 客户端 TabBar 中间按钮/" class="prev">PRVE</a><a href="/2016/03/20/AutoLayout：constraint priority 约束优先级（九宫格续，一个更优方案）/" class="next">NEXT</a></div><div data-thread-key="2016/03/26/【译】iOS 基础：Frames、Bounds 和 CGGeometry/" data-title="【译】iOS 基础：Frames、Bounds 和 CGGeometry" data-url="http://cheng-kang.github.io/2016/03/26/【译】iOS 基础：Frames、Bounds 和 CGGeometry/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"chengkang"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div id="disqus_thread"></div><script>var disqus_shortname = 'chengkang';
var disqus_identifier = '2016/03/26/【译】iOS 基础：Frames、Bounds 和 CGGeometry/';
var disqus_title = '【译】iOS 基础：Frames、Bounds 和 CGGeometry';
var disqus_url = 'http://cheng-kang.github.io/2016/03/26/【译】iOS 基础：Frames、Bounds 和 CGGeometry/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//chengkang.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 <a href="http://cheng-kang.github.io">程康·Ant</a>, unless otherwise noted.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-75274957-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?ae1a81e6256aab436489ff79379d128d";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>